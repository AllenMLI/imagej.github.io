{{Help}}
= How to troubleshoot problems =

== Launching ImageJ from the console ==

To diagnose problems with ImageJ, it is often helpful to launch it in debug mode. There are several ways:

<ol>
<li>'''Launch with the <code>--debug</code> flag.'''
<ul>
<li>On Linux 64-bit (from a console):
<source lang="bash">$HOME/ImageJ.app/ImageJ-linux64 --debug</source>
</li>
<li>On OS X (from Terminal):
<source lang="bash">/Applications/ImageJ.app/Contents/MacOS/ImageJ-macosx --debug</source>
</li>
<li>On Windows 64-bit (from Command Prompt):
<source lang="bash">%HOMEPATH%\ImageJ.app\ImageJ-win64.exe --debug</source>
</ul>
</li>
<li>'''Set the <code>DEBUG</code> environment variable.''' E.g., on Linux:
<source lang="bash">DEBUG=1 $HOME/ImageJ.app/ImageJ-linux64</source>
</li>
<li>'''Rename the launcher.''' You can rename the executable from <code>ImageJ-xxx</code> to <code>debug</code> (<code>debug.exe</code> on Windows) before launching, and the launcher will be more verbose about what it is doing.
</li>
<li>'''Set <code>scijava.log.level</code>.''' You can control the log level more precisely by setting the <code>scijava.log.level</code> system property. E.g., on Linux:
<source lang="bash">$HOME/ImageJ.app/ImageJ-linux64 -Dscijava.log.level=trace --</source>
Valid levels include: <code>none</code>, <code>error</code>, <code>warn</code>, <code>info</code>, <code>debug</code> and <code>trace</code>. See the [[Logging]] page for more about SciJava logging.
</li>
</ol>

== The other debug mode ==

There is another debug mode, which can be enabled in the {{bc | Edit | Options | Misc...}} menu, by checking ''Debug mode''. This might reveal different information than using the techniques described above. For maximum debugitude, turn on both!

== If ImageJ freezes or hangs ==

If ImageJ appears to [https://en.wikipedia.org/wiki/Hang_(computing) hang]—i.e., it stops responding to inputs—it is often helpful to take a "snapshot" of where the program is at after the hang occurs. This information can give the developers valuable hints about how to fix the problem.

There are two ways to create such a snapshot, known as a "thread dump" or "stack trace":

# First, try pressing {{key|Shift}}+{{key|\}} in ImageJ itself. If successful, it will open a new window with the stack trace.
# If the first method does not work, and you can reproduce the hang: launch ImageJ again, this time [[#Launching ImageJ from the console|from the console]] as described above. Then press {{key|Ctrl}}+{{key|\}} in the same console to print the stack trace. On Windows, you may need to press {{key|Ctrl}}+{{key|Pause}} (i.e., {{key|Break}}) instead of {{key|Ctrl}}+{{key|\}}.

Either way, once you have the stack trace. you can copy and paste it into a [[Bugs|bug report]]!

== If ImageJ crashes ==

If ImageJ [https://en.wikipedia.org/wiki/Crash_(computing) crashes]—i.e., the program suddenly terminates, with or without an error message—it is very helpful to identify the steps which can reliably reproduce the crash:
* Launch ImageJ [[#Launching ImageJ from the console|from the console]] as described above.
* Perform the same actions which previously resulted in the crash.
* Take note of any error messages in the console window, which you can copy and paste it into a [[Bugs|bug report]].

== Advanced debugging techniques ==

If you are technically savvy, check out the [[Debugging]] page for additional—but more complicated—debugging techniques.

= Common issues =

== The image I loaded is displayed all black! But it is not black! ==

This problem usually arises when 12-bit or 14-bit images are loaded into ImageJ without autoscaling. In that case, they are treated as if they were 16-bit images, and therefore the dynamic range is all wrong. You can fix this by clicking on {{bc | Image | Adjust | Brightness/Contrast...}} and hitting the ''Auto'' button.

== The image colors do not match what I see in other programs! ImageJ is wrong! ==

In many cases, ImageJ performs autoscaling by default, to improve the contrast of your image. Otherwise, in many cases with scientific images you might see only a black square (see previous question).

You can override the autoscaling using the [http://imagej.net/docs/guide/146-28.html#sub:Adjust Brightness/Contrast] dialog.

It is important to understand that your image is a collection of samples, each of which has a numerical intensity value. The unit of these values is rather arbitrary and unspecified, depending on the type and calibration of your detector. Your file is stored with a certain [http://imagej.net/docs/guide/146-7.html#toc-Section-7 bit depth], meaning these intensities can range from 0 (no light detected) to a particular maximum value (the most light the detector is capable of detecting). For example, 8-bit images have a maximum value of 255, whereas 16-bit images have a maximum of 65535. In practice though, especially with higher bit depths, your detector will not typically record sample intensities across that entire range of values (and if it does record a significant number of values at the maximum, you probably oversaturated your detector, which will skew your analysis!).

Because the full range of values is typically much less than the maximum—e.g., in the case of a 12-bit detector the actual maximum range is 0-4095, and often even smaller in practice—ImageJ performs '''autoscaling''' to show you a meaningful or "pretty good" image by default, which is not just a black square (see previous question). That is: it maps the darkest actual intensity in your data to black, and the brightest actual intensity in your data to white. You can override this mapping using the [http://imagej.net/docs/guide/146-28.html#sub:Adjust Brightness/Contrast] dialog under the {{bc | Image | Adjust}} menu (shortcut: {{Key | shift}}+{{Key | C}}).

Alternately, to disable autoscaling during initial import, you can use the [[Bio-Formats]] plugin to import your data with the "Autoscale" option turned off:

* {{bc | File | Import | Bio-Formats}}
* Choose your file
* Uncheck the "Autoscale" box
* Click OK
* The data will be scaled to match the maximum of the bit depth, rather than autoscaled.

Further reading:
* [[Image Intensity Processing]]
* [[Image Processing Principles]]

== The same plugin gives different results on different machines! ==

While ImageJ strives for [[reproducible]] analysis, there are many reasons results can differ. Check the following:

* Ensure that the version of [[ImageJ]] is exactly the same on both machines.
** Click the status bar and you will see something like "ImageJ 2.0.0-rc-26/1.49p".
** If these two values differ between your machines, the versions are not the same.
** See also [[Frequently Asked Questions#How can I verify that my ImageJ is really 100% up to date?|How can I verify that my ImageJ is really 100% up to date?]].
** If the two versions of ImageJ differ and produce different numerical results, it is a bug—please [[Report a Bug|report it]]!
* Ensure that the ''options'' of ImageJ match between the machines.
** A fast way to ensure this is the {{bc | Edit | Options | Reset...}} command, which resets everything to its default state.
** Alternately, you can check the settings in the following dialog boxes:
*** All {{bc | Edit | Options}} dialog boxes
** {{bc | Process | Binary | Options...}} – a very common culprit of black-vs.-white issues is the "Black background" option.
** {{bc | Process | FFT | FFT Options...}}
** {{bc | Image | Overlay | Overlay Options...}}
** {{bc | Analyze | Gels | Gel Analyzer Options...}}
** Press L for the [[Command Finder]] and type "options" and double check any other options you think might be relevant.
* If you are running your analysis [[headless]], there might be a bug in the headless support.
** Try the analysis ''headless'' on both machines and see if the results match.
** Try the analysis ''headless'' vs. through the GUI on a single machine, and see if the results match.
** If the results differ due to headlessness, it is a bug—please [[Report a Bug|report it]]!

= Common error messages =

== OutOfMemoryError ==

{{Box | float=right |
'''Why does ImageJ not release any memory back to the system?'''

This is a characteristic of the Java runtime. In many cases, Java ''never'' releases memory back to the system, so memory monitors such as Windows Task Manager will always report an ever-growing amount of RAM used by the Java process, until the JVM shuts down.

The best way to monitor ImageJ's actual memory usage is to run the [http://imagej.net/docs/guide/146-31.html#toc-Subsubsection-31.3.5 Monitor Memory...] command. You can also click on the ImageJ status bar to trigger a garbage collection operation, which will typically decrease the memory use.

That said, some articles suggest that you can cause Java to give back free memory to the OS under certain conditions; see:

* [http://stackoverflow.com/q/324499 Java still uses system memory after deallocation of objects and garbage collection]
* [http://stackoverflow.com/q/16649601 java.exe process uses more memory and does not free it up]
* [http://stackoverflow.com/q/12017437 JVM Memory : Why memory on task manager difference with JProbe (or JConsole tool)]

To be clear, Java does reuse memory when you close and reopen images. The behavior described above is not a memory ''leak'' per se. It should be possible to leave ImageJ running for days or weeks at a time doing batch processing and it have it work just fine.

See also:

* [http://stackoverflow.com/q/22912063 Automatically release unused memory in ImageJ / Fiji]
}}
The error means ImageJ ran out of available [https://en.wikipedia.org/wiki/Random-access_memory computer memory] (''not'' hard drive space).

The first thing to do is make sure that ImageJ has a large enough "maximum heap" size:

* {{bc | Edit | Options | Memory &amp; Threads}}
* Change "Maximum Memory" to something larger (at most, 1000 MB less than your computer's total RAM).
* Restart ImageJ for the new memory settings to take effect.

Note that in most cases, the [[Launcher|ImageJ launcher]] will make an initial guess at a reasonable value: ~75% of physical RAM.

You can confirm how much memory is actually available by clicking on the status bar. You will see a "[used] of [max]" memory message, as pictured here:

[[File:MemoryStatus.png]]

If you are already at the limits of your computer's physical memory, the next step would be to add more.

'''About Java garbage collection:''' Java always automatically calls the garbage collector when the heap is getting full [http://stackoverflow.com/questions/8719071 [1]]. While it is possible to manually invoke the garbage collector by clicking ImageJ's status bar&mdash;or programmatically by calling <code>run("Collect Garbage")</code> in a macro or <code>System.gc()</code> in a plugin&mdash;it will not solve the fundamental problem of Java actually not having a sufficient amount of memory. (The only exception to this is a rare case where Java decides that garbage collection is happening too slowly, in which case you should see the message "GC overhead limit exceeded" [http://www.petefreitag.com/item/746.cfm [2]]).

== NegativeArraySizeException ==

This error usually means that your image planes are larger than the maximum supported size.

[[ImageJ1]] only supports image planes with 2 gigapixels or less. If your data has extremely large image planes—e.g., 50000 x 50000 pixels—you may need to analyze region by region. One way to do this is using the "Crop on import" feature of the [[Bio-Formats]] plugin.

[[ImageJ2]] supports larger image planes internally, but uses the [[ImageJ1]] user interface by default, which once again limits visualization to 2 gigapixels. The [[Contributors|ImageJ2 team]] is working to lift these size restrictions; see {{GitHub | org=imagej | repo=imagej | issue=87 | label=imagej/imagej#87}}.

= OS X issues =

== Why does ImageJ crash frequently? ==

This is most likely an AWT issue with Apple's version of Java 6. There is even a [http://fiji.sc/bugzilla/show_bug.cgi?id=197 bug in our bug tracker about it]. The problem is that we did not manage to find a work-around because the bug appears to be in the MacOSX-specific part of the Java Virtual Machine that was provided by Apple. It seems to be related to opening new windows while mouse updates are processed, though. If you have this issue, or find out what causes it, please comment on [http://fiji.sc/bugzilla/show_bug.cgi?id=197 this bug report].

== Why does ImageJ run so slowly? ==

On OS X, older versions of Java 7 and Java 8 (prior to 1.8.0_45) are extremely slow at displaying images. You should either [[FAQ#How_do_I_run_ImageJ_on_Yosemite.3F|upgrade to the latest version of Java 8]], or [[FAQ#How_do_I_set_up_Java_6_on_OS_X.3F|revert to Java 6]].
