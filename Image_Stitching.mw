{{Infobox Plugin
| name                   = Stitching
| software               = ImageJ
| author                 = Stephan Preibisch
| maintainer             = Stephan Preibisch
| filename               = Stitching_.jar
| source                 = [http://pacific.mpi-cbg.de/cgi-bin/gitweb.cgi?p=fiji.git;a=tree;f=src-plugins/Stitching_;hb=HEAD on gitweb]
| released               = October 2008
| latest version         = January 2012
| category               = [[:Category:Stitching|Stitching]]
| website                = [http://fly.mpi-cbg.de/~preibisch Stephan Preibisch's homepage]
}}

== Citation ==
Please note that the Stitching, as well as other plugins available through Fiji, is based on a publication. If you use it successfully for your research please be so kind to cite our work:
* S. Preibisch, S. Saalfeld, P. Tomancak (2009) "Globally optimal stitching of tiled 3D microscopic image acquisitions", ''Bioinformatics'', '''25'''(11):1463-1465. [http://bioinformatics.oxfordjournals.org/cgi/content/abstract/btp184 Webpage] [http://bioinformatics.oxfordjournals.org/cgi/reprint/25/11/1463.pdf PDF]

== Introduction ==
There is an increasing demand to image large biological specimen at high resolution. Typically those specimen do not fit in the field of view of the microscope. To overcome this drawback, motorized stages moving the sample are used to create a tiled scan of the whole specimen. The physical coordinates provided by the microscope stage are not precise enough to allow reconstruction (”Stitching”) of the whole image from individual image stacks.

The Stitching Plugin (2d-5d) is able to reconstruct big images/stacks from an arbitrary number of tiled input images/stacks, making use of the Fourier Shift Theorem that computes all possible translations (x, y[, z]) between two 2d/3d images at once, yielding the best overlap in terms of the cross correlation measure. If more than two input images/stacks are used the correct placement of all tiles is determined using a global optimization. The stitching is able to align an arbitrary amount of channels and supports timelapse registration. To remove brightness differences at the tile borders, non-linear intensity blending can be applied. 

Plase note: this is the new implementation of the Stitching plugin which is finally based on [[Imglib]] and supports a lot of new features:

* supports composite images and hyperstacks now
* it can write the stitched image slice-by-slice directly to disk (significantly reduces the RAM requirements)
* it can open the input images as Virtual Stacks (significantly reduces the RAM requirements)
* supports timelapse alignment with different stitching options
* subpixel-resolution
* supports many different types of grids (row-by-row, column-by-column, snake, ...)
* can read the approximate tile positions from the image metadata

Due to the virtual input stacks and the direct export of the result to disk It is now possible to stitch an arbitrary amount of image tiles with limited RAM resources.

The documentation of the '''old''' Stitching plugin collection can be found here: [[Stitching 2D/3D]].

== Overview of the Stitching Plugins ==

The Image Stitching package comes with 2 different plugins:

* '''[[Image Stitching#Pairwise Stitching | Pairwise Stitching]]''': Stitch two 2d-5d images, rectangular ROIs can be used to limit the area to search in.
* '''[[Image Stitching#Grid/Collection Stitching | Grid/Collection Stitching]]''': Stitch an arbitrary amount of 2d-5d input images. It supports cases where the approximate alignment is known (grid, stored in file, metadata) as well as completely unguided alignment.

Although both plugins make use of layered context-dependent Generic Dialogs, they are completely macro-scriptable.

== Pairwise Stitching ==
[[File:PairwiseStitching1.png|thumb|230px|Shows the selection of input images.]]
The Pairwise Stitching first queries for two input images that you intend to stitch. They can contain rectangular ROIs which limit the search to those areas, however, the full images will be stitched together. Once you selected the input images it will show the actual dialog for the Pairwise Stitching. The dialog will depend on the dimensionality of the input images. Please note that RGB input images will be converted into 8-Bit composite images.

There are several ''fusion methods'' available (new ones can be easily added by implementing this [http://fiji.sc/cgi-bin/gitweb.cgi?p=fiji.git;a=blob;f=src-plugins/Stitching_/mpicbg/stitching/fusion/PixelFusion.java interface]):
* '''Linear blending''': In the overlapping area the intensity are smoothly adjusted between the two images. 
* '''Average''': In the overlapping area the average intensity between all images is computed ([http://fiji.sc/cgi-bin/gitweb.cgi?p=fiji.git;a=blob;f=src-plugins/Stitching_/mpicbg/stitching/fusion/AveragePixelFusion.java example source code]).
* '''Median''': In the overlapping area the median intensity of all images is computed.
* '''Max. Intensity''': In the overlapping area the maximum intensity between all images is used int the output image.
* '''Min. Intensity''': In the overlapping area the minimum intensity between all images is used int the output image.
* '''Overlay into Composite''': all channels of all input images will be put into the output image as separate channels.
* '''Do not fuse images''': no output images will be computed, just the overlap is computed.
[[File:PairwiseStitching2.png|thumb|230px|Shows the Pairwise Stitching dialog.]]

The ''number of peaks'' defines the number of maxima in the Phase Correlation Matrix which are examined. If the stitching was not correct increasing this number might help.

If you do not check ''compute overlap'', the plugin will just apply the translation that can be inserted below.

If you check ''supixel accuracy'', the plugin will compute a subpixel precise alignment between the two images (it hardly costs any computation time but some RAM). Furthermore, if subpixel localization is activated, linear interpolation will be used for the fusion. Otherwise no interpolation will be applied.

When choosing the ''registration channels'' you define which part of the data will be used to compute the overlap. It has no influence on how the data is fused.

If the input stacks are time-lapse images, you will have different choices on how to align over time:
* '''Apply registration of first time-point to all other time-points''': The plugin will compute the stitching only for the first time-point and assume that this shift is correct for all time-points.
* '''Register images adjacently over time''': The stitching will compute the shift between all images of all time-points, as well as of each image to the same image of the next time-point. A global optimization scheme will be used to minimize the global error and reject outliers. The parameters for this global optimization will be queried in an additional dialog.
* '''Register all images over all time-points globally (expensive!)''': The stitching will compute the shift between all time-points and all images which will take a considerable amount of time. A global optimization scheme will be used to minimize the global error and reject outliers. The parameters for this global optimization will be queried in an additional dialog.

[[File:PairwiseStitching3.png|thumb|230px|Shows the extra option for Pairwise Stitching when aligning all timepoints to each other.]]

If a global optimization is necessary for time-point registration another dialog will pop up to ask for more parameters:
* '''Computation parameters''': If you choose ''Save memory (but be slower)'' the stitching will compute all pairwise correlations one after another. Although it is performed multi-threaded it is slower than computing as many pairwise correlations at the same time as processors are available done by the option ''Save computation time (but use more RAM)''.
* '''Max/avg displacement threshold''': After the overlap between all individual tiles has been computed the global optimization computes an optimal arrangement of all tiles. After that, some image pairs will be placed different to each other compared to the individual alignment, which we call displacement. If there are no major alignment errors the average and maximal displacement will be below or around 1 pixel. If one of the individual alignment between two images was wrong, this pair will be displaced a lot in the global optimization as all other connecting tiles pull it towards the correct global position. If the maximal displacement is much higher than the average one it means that this individual alignment is most likely wrong and will be removed. Note: An image will just be removed if there is no link to another image any more.
* '''Absolute displacement threshold''': Removes links between images if the absolute displacement is higher than this value.

== Grid/Collection Stitching ==
This plugin is able to stitch an arbitrary collection or grid of images, it does not matter if it is 2d, 3d, 4d or 5d images as long as all images are of the same type. In contrast to the Pairwise Stitching of two images, this plugins will load (and potentially save) the images from/to harddisc. 

[[File:GridStitching1.png|thumb|230px|Shows the grid/collection selection dialog.]]
Please note that you should take the chance to give the Grid/Collection Stitching a clue of what the approximate layout of the tiles is if you can. This will reduce the computational effort significantly and is much more likely to succeed. If this is not possible, choose the option '''Unknown positions''' and the Stitching will try to figure out the correct alignment without any help. 

The first dialog queries the type image collection or image grid that you want to assemble. For each major type there are typically several subtypes you can choose from. For an easier understanding each option is supported by a small figure:
* '''Grid: row-by-row''': The images are arranged in a grid, one line after the other. After a line is finished the new one always starts at the same position as the previous line (carriage return, like reading a text).
** ''Right & Down'': Start on the top left and go down line by line.
** ''Left & Down'': Start on the top right and go down line by line.
** ''Right & Up'': Start on the bottom left and go up line by line.
** ''Left & Up'': Start on the bottom right and go up line by line.
* '''Grid: column-by-column''': The images are arranged in a grid, one column after the other. After a column is finished the new one always starts at the same position as the previous column (carriage return).
** ''Down & Right'': Start on the top left and go right column by column.
** ''Down & Left'': Start on the top right and go left column by column.
** ''Up & Right'': Start on the bottom left and go right column by column.
** ''Left & Up'': Start on the bottom right and go left column by column.
* '''Grid: snake by rows''': The images are arranged in a grid, one line after the other. After a line is finished the next line starts in reverse order at the position where the previous line ended (no carriage return, like a snake).
** ''Right & Down'': Start on the top left and go right, then one line down, then left, then down, then right, ...
** ''Left & Down'': Start on the top right and go left, then one line down, then right, then down, then left, ...
** ''Right & Up'': Start on the bottom left and go right, then one line up, then left, then up, then right, ...
** ''Left & Up'': Start on the bottom right and go left, then one line up, then right, then up, then left, ...
* '''Grid: snake by columns''': The images are arranged in a grid, one column after the other. After a column is finished the next one starts in reverse order at the position where the previous one ended (no carriage return, like a snake).
** ''Down & Right'': Start on the top left and go down, then one column right, then up, then right, then down, ...
** ''Down & Left'': Start on the top right and go down, then one column left, then up, then left, then down, ...
** ''Up & Right'': Start on the bottom left and go up, then one column right, then down, then right, then up, ...
** ''Up & Left'': Start on the bottom right and go up, then one column left, then down, then left, then up, ...
* '''Filename defined positions''': The approximate positions of each tile are encoded in the filename.
* '''Unknown positions''': The positions of each tile are unknown and the Stitching will try to determine them.
* '''Positions from file''': The approximate position of each tile is defined in an extra file or by the metadata.
** ''Defined by TileConfiguration'': The next dialog will query for a tile configuration file that specifies the filenames as well as the approximate position of each tile in pixel coordinates. This is especially useful if the tiles are arranged in a way that is not covered by any of the other grid/snake options - or maybe also in z! Tile configuration files are created by any of the grid methods described above. If you want to manually or automatically create such a file I suggest creating one using grid stitching (even if you do not have any image data) and changing it accordingly.
