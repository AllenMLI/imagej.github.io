{{Notice | This page describes the ''technical'' structure of [[SciJava]] projects.<br>For information on their ''social'' structure, see the [[Governance]] page.}}
{{Development}}
= SciJava project structure =

The [[ImageJ]] project, and related projects in the [[SciJava]] software ecosystem, are carefully structured to foster [[extensibility]].

== Organizational structure ==

<imagemap>
Image:SciJava_Organization_Hierarchy.svg|right|frame|SciJava organizations
rect 43 178 277 307 [https://github.com/imglib]
rect 43 83 216 147 [https://github.com/scifio]
rect 30 50 230 260 [https://github.com/imagej]
rect 1 1 261 291 [https://github.com/scijava]
</imagemap>

There are four organizations on [https://github.com/ GitHub] which form the backbone of the [[SciJava]] ecosystem:

* [https://github.com/scijava scijava] - for [[SciJava]] projects: general-purpose, non-image-specific libraries.
* [https://github.com/imglib imglib] - for [[ImgLib2]] projects: flexible N-dimensional image processing.
* [https://github.com/imagej imagej] - for [[ImageJ]] projects: metadata-rich image library and application.
* [https://github.com/scifio scifio] - for [[SCIFIO]] projects: scientific image I/O and file formats.

Each organization contains several related projects under its respective umbrella: a core library (see below) and several extensions. In social terms, each organization represents a collection of conceptually related projects developed by a distinct [[Contributors|team of developers]].

Additional organizations further extend this structure:

* [https://github.com/fiji fiji] - for [[Fiji]] projects
* [https://github.com/trakem2 trakem2] - for [[TrakEM2]] projects
* [https://github.com/uw-loci uw-loci] - for [[User:LOCI|LOCI]] projects
* [https://github.com/slim-curve slim-curve] - for [[SLIM Curve]] projects
* <your organization here!>

The diagram on the right shows organizational relationships between SciJava software components.

== Git repositories ==

Each project is contained in its own [[Git]] repository, so that interested developers can cherry-pick only those parts of interest. Version control is an indispensable tool to ensure ''scientific reproducibility'' (see below) by tracking known-working states of the source code, and maintain a written recorded of how and why the code has changed over time. For technical details, see the [[Git]] section.

=== Why separate Git repositories? ===

With [[Maven]] it is possible to create a [http://maven.apache.org/guides/mini/guide-multiple-modules.html multi-module reactor] that unifies several project artifacts into a single build, typically within a single Git repository.

While many components of the SciJava software stack used to be structured this way, we found that lumping multiple components into a single Git repository with a multi-module build has disadvantages compared to separate Git repositories with single-module builds:
* Typically, components of a multi-module project are all versioned together, but we have opted for individual [[versioning]] of components, for [[Philosophy#Release_early.2C_release_often|reasons of rapid iteration]].
* Individual repositories make it easier for developers to cherry-pick only those components of interest, without building the rest of the code, since dependencies are fetched on demand from remote [[Maven]] repositories.
* Concerns are better separated, with each component encapsulating its own codebase, issues, pull requests and technical documentation.
* Since every component follows a consistent structure, the supporting tools (e.g., [https://github.com/scijava/scijava-scripts these scripts]) are simpler to develop and maintain.

Of course, there are downsides, too:
* Changes affecting multiple components must be done as separate patch sets (i.e., commits or pull requests).
* Issues relevant to multiple components must be filed separately in each issue tracker and cross-referenced.
* It can be more difficult to locate code of interest, since the codebase is spread across so many repositories.

As a rule of thumb, we find that multi-module [[Maven]] projects stored within a single Git repository are a natural fit for "big bang" software which is versioned in lockstep and carefully tested before each release, whereas single-module projects stored in separate Git repositories work well for the [[Philosophy#Release_early.2C_release_often|RERO]]-style release paradigm.

== Maven component structure ==

<graphviz border alignment="right" size="400px" caption="Parent POM hierarchy">
digraph poms {
    label="Parent POM hierarchy"
    "pom-scijava" [color=green, style=filled, URL="[https://github.com/scijava/pom-scijava]"]
    "pom-imglib2" [color=pink, style=filled, URL="[https://github.com/imglib/pom-imglib2]"]
    "pom-imagej" [color=yellow, style=filled, URL="[https://github.com/imagej/pom-imagej]"]
    "pom-scifio" [color=lightblue, style=filled, URL="[https://github.com/scifio/pom-scifio]"]
    "pom-fiji" [color=orange, style=filled, URL="[https://github.com/fiji/pom-fiji]"]
    "pom-trakem2" [color=lavender, style=filled, URL="[https://github.com/trakem2/TrakEM2]"]
    "pom-loci" [color=gray, style=filled, URL="[https://github.com/uw-loci/pom-loci]"]
    "pom-scijava" -> "pom-imagej"
    "pom-imagej" -> "pom-imglib2"
    "pom-imagej" -> "pom-scifio"
    "pom-imagej" -> "pom-fiji"
    "pom-fiji" -> "pom-trakem2"
    "pom-scijava" -> "pom-loci"
}
</graphviz>

All projects in these organizations use [[Maven]] for [[Project Management|project management]]. Each organization has its own Maven [http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-relationships.html#pom-relationships-sect-more-coordinates groupId], as well as a [http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-relationships.html#pom-relationships-sect-project-inheritance parent POM] that all other projects in that organization extend:

{| class="wikitable nicetable"
| '''Logo'''
| '''Project'''
| '''Organization'''
| '''groupId'''
| '''Parent POM'''
|-
| [[File:Scijava-icon.png|48px]]
| [[SciJava]]
| [https://github.com/scijava scijava]
| [http://maven.imagej.net/index.html#nexus-search;gav~org.scijava org.scijava]
| {{GitHub|org=scijava|repo=pom-scijava|label=pom-scijava}}
|-
| [[File:Imagej2-icon.png|48px]]
| [[ImageJ]]
| [https://github.com/imagej imagej]
| [http://maven.imagej.net/index.html#nexus-search;gav~net.imagej net.imagej]
| {{GitHub|org=imagej|repo=pom-imagej|label=pom-imagej}}
|-
| [[File:Imglib2-icon.png|48px]]
| [[ImgLib2]]
| [https://github.com/imglib imglib]
| [http://maven.imagej.net/index.html#nexus-search;gav~net.imglib2 net.imglib2]
| {{GitHub|org=imglib|repo=pom-imglib2|label=pom-imglib2}}
|-
| [[File:Scifio-icon.png|48px]]
| [[SCIFIO]]
| [https://github.com/scifio scifio]
| [http://maven.imagej.net/index.html#nexus-search;gav~io.scif io.scif]
| {{GitHub|org=scifio|repo=pom-scifio|label=pom-scifio}}
|-
| [[File:Fiji-icon.png|48px]]
| [[Fiji]]
| [https://github.com/fiji fiji]
| [http://maven.imagej.net/index.html#nexus-search;gav~sc.fiji sc.fiji]
| {{GitHub|org=fiji|repo=pom-fiji|label=pom-fiji}}
|-
| style="height: 48px" |
| [[TrakEM2]]
| [https://github.com/trakem2 trakem2]
| [http://maven.imagej.net/index.html#nexus-search;gav~sc.fiji sc.fiji]
| {{GitHub|org=trakem2|repo=TrakEM2|label=pom-trakem2}}
|-
| [[File:Slim-curve-icon.png|48px]]
| [[SLIM Curve]]
| [https://github.com/slim-curve slim-curve]
| [http://maven.imagej.net/index.html#nexus-search;gav~slim-curve slim-curve]
| -
|-
| [[File:loci-logo.png|48px]]
| [[LOCI]]
| [https://github.com/uw-loci uw-loci]
| [http://maven.imagej.net/index.html#nexus-search;gav~loci loci]
| {{GitHub|org=uw-loci|repo=pom-loci|label=pom-loci}}
|}

The hierarchy of organizational parent POMs is shown in the diagram to the right. The <code>pom-scijava</code> parent forms the foundation of all other Maven projects in the ecosystem.

== Bill of Materials ==

The <code>pom-scijava</code> parent includes a [http://howtodoinjava.com/2014/02/18/maven-bom-bill-of-materials-dependency/ Bill of Materials] (BOM) which declares compatible versions of all core SciJava software in its [http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management dependencyManagement section]. These versions are intended to be used together in downstream projects, preventing version skew (symptoms of which include <code>ClassNotFoundException</code> and <code>NoSuchMethodError</code>, as well as erroneous behavior in general). This BOM is especially important while some components are still in beta, since they may sometimes break [[backwards compatibility]].

Similarly, the <code>pom-imagej</code> parent includes a consolidated Bill of Materials for projects in the ImageJ, ImgLib2 and SCIFIO organizations, as well as for downstream projects which extend the <code>pom-imagej</code> parent. The rationale for this consolidation is that each of these three organizations has projects which depend on components within the other two organizations. So broadly speaking, these three organizations form an interdependent "triumvarate." However, there are no circular dependencies at the level of individual components. See [http://imagej.net/pipermail/imagej-devel/2014-October/002280.html this thread on the imagej-devel mailing list] for further details.

Other SciJava projects may extend the Bill of Materials further by providing their own <code>dependencyManagement</code> section. For example, Fiji's <code>pom-fiji</code> parent [https://github.com/fiji/pom-fiji/blob/pom-fiji-5.0.2/pom.xml#L21-L748 does this].

== Core libraries ==

<graphviz border alignment="right" caption="Core library hierarchy">
digraph libs {
    label="Core library hierarchy"
    
    "scijava-common" [color=green, style=filled, URL="[https://github.com/scijava/scijava-common]"]
    "imagej-common" [color=yellow, style=filled, URL="[https://github.com/imagej/imagej-common]"]
    "imagej-ops" [color=yellow, style=filled, URL="[https://github.com/imagej/imagej-ops]"]
    "imglib2" [color=pink, style=filled, URL="[https://github.com/imglib/imglib2]"]
    "scifio" [color=lightblue, style=filled, URL="[https://github.com/scifio/scifio]"]
    "scijava-common" -> "imagej-common"
    "imglib2" -> "imagej-common"
    "imagej-common" -> "scifio"
    "imagej-common" -> "imagej-ops"
}
</graphviz>

The [[SciJava]] software stack is composed of the following core libraries:

* [[SciJava Common]] - The SciJava application container and plugin framework.
* [[ImgLib2]] - The N-dimensional image data model.
* [[ImageJ Common]] - Metadata-rich image data structures and SciJava extensions.
* [[ImageJ OPS]] - The framework for reusable image processing operations.
* [[SCIFIO]] - The framework for N-dimensional image I/O.

These libraries form the basis of SciJava-based software.

The dependency hierarchy of library artifacts is shown in the diagram to the right.

=== Modularity ===

Much effort has been expended to ensure the design of these libraries provides a good [https://en.wikipedia.org/wiki/Separation_of_concerns separation of concerns]. Developers in need of specific functionality may choose to depend on only those components which are relevant, rather than needing to add a dependency to the entire SciJava software stack.

Along those lines, the libraries take great pains to be '''UI agnostic''', with no dependencies on packages such as <code>java.awt</code> or <code>javax.swing</code>. The idea is that it should be possible to build a [https://en.wikipedia.org/wiki/Graphical_user_interface user interface] (UI) on top of these libraries, without needing to change the library code itself. We have developed several proof-of-concept UIs for ImageJ using different UI frameworks, including [https://github.com/imagej/imagej-ui-swing Swing], [https://github.com/imagej/imagej-ui-awt AWT], [https://github.com/imagej/imagej-ui-swt Eclipse SWT] and [https://github.com/imagej/imagej-ui-pivot Apache Pivot].

== Reproducible builds ==

{{Sidebox
| title = Why are reproducible builds so essential for science?
| width = 40%
| text =
Arguably '''the most important thing''' in science is to gain insights about nature '''that can be verified by other researchers'''. It is this mission for which [[ImageJ]] and [[Fiji]] stand, and it is the central reason why they are [[Open Source]].

To verify results, it is absolutely necessary to be able to reproduce results claimed in scientific articles, and in the interest of efficiency, it should be '''easy''' to reproduce the results, and it should '''also''' be easy to scrutinize the used methods—incorrect results can be artifacts of flawed algorithms, after all.

To that end, it should be obvious that researchers '''need''' to have the ability to inspect the exact source code corresponding to the software used to generate the results to be verified. In other words, reproducible builds are required for sound scientific research.
}}=== What is a reproducible build? ===

A software ''version'' (or ''build'') is called '''reproducible''' if it is easy to regenerate the exact same software application from the source code.

For example, you can refer to "ImageJ 1.49g" as a ''reproducible build'', or to ''Sholl Analysis 3.4.3'', while referring to "ImageJ" is irreproducible.

It gets more subtle when making heavy use of software libraries (sometimes called ''dependencies''). It is known, for example, that many plugins in the now-defunct [[MBF|MacBiophotonics distribution of ImageJ]] worked fine with ImageJ 1.42l, but stopped working somewhere between that version and ImageJ 1.44e. That is: referring to, say, ''the Colocalisation Analysis plugin'' does '''not''' refer to a reproducible build because it is very hard to regenerate a working Colocalisation Analysis and ImageJ 1.x version that could be used to verify previously published results.

=== Advantages of reproducible builds ===

Some cardinal reasons to strive for reproducible builds are:

* It becomes possible to use a [https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow feature branch workflow] development style where the <code>master</code> branch is always release ready—or even a [https://en.wikipedia.org/wiki/Continuous_delivery continuous delivery] approach.
* Debugging with [http://git-scm.com/book/en/v2/Git-Tools-Debugging-with-Git#Binary-Search git-bisect] becomes feasible.
* As a consequence, it avoids [https://en.wikipedia.org/wiki/Technical_debt technical debt] in favor of a robust development style.
* It attracts more developers to the project, since things "just work" out of the box.

=== How SciJava achieves reproducible builds ===

For the reasons stated above, the SciJava software components strive for reproducible builds. The goal is to ensure that code which builds and runs today will continue to do so in exactly the same way for many years to come.

Each project depends on release [http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-pom-syntax.html#pom-reationships-sect-versions versions] of ''all'' its dependencies—never on [http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-pom-syntax.html#pom-relationships-sect-snapshot-versions snapshots] or [http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-dependencies.html#pom-relationships-sect-version-ranges version ranges]. A Maven snapshot is a moving target, and depending on one results in an irreproducible build. Similarly, all Maven plugins used, as well as the parent POM, are also declared at release versions. In short: all <code>&lt;version&gt;</code> tags specify release versions, never <code>SNAPSHOT</code> or <code>LATEST</code> versions. We use the [http://maven.apache.org/enforcer/maven-enforcer-plugin/ Maven Enforcer Plugin] to enforce this requirement (though it can be disabled by setting the <code>scijava.enforce.skip</code> system property).

=== Using snapshot couplings during development ===

For developing several projects in parallel in e.g. Eclipse, it is very useful to switch to <code>SNAPSHOT</code> dependency couplings.

There are two easy ways of going about this:
<ol type="A">
<li>When a small number of snapshot couplings are needed, you can override the version property of the dependency for which you wish to use a snapshot:
<source lang="xml">
<properties>
  <scijava-common.version>LATEST</scijava-common.version>
</properties>
</source></li>
<li>Alternately, if you wish to temporarily apply snapshot couplings en masse, you can switch on a "dev profile" (defined in the <code>pom-scijava</code> parent POM) by creating one or more "dev token" files:
* <code>~/.scijava/dev.imagej</code>
* <code>~/.scijava/dev.imglib2</code>
* <code>~/.scijava/dev.scifio</code>
* <code>~/.scijava/dev.scijava</code>
These files need not have any content; their mere existence will trigger the dev profile associated with the named organization, causing all artifacts of that organization to become coupled as <code>SNAPSHOT</code>s.</li>
</ol>
In the case of Eclipse, you may need to "Update Maven project" in order to see the snapshot couplings go into effect; the shortcut {{Key | Alt}}+{{Key | F5}} while selecting the affected project(s) accomplishes this quickly.

Either way, '''''be sure to work on a topic branch while developing code in this fashion.''''' You will need to clean up your Git history afterwards before merging things to the <code>master</code> branch, in order to achieve [[reproducible builds]].

== Versioning ==

The SciJava software stack uses the [http://semver.org/ Semantic Versioning] system. This scheme communicates information about the [[backwards compatibility]] (or lack thereof) between versions of each individual software component. In a nutshell:

<blockquote>Given a version number MAJOR.MINOR.PATCH, increment the:
* MAJOR version when you make incompatible API changes,
* MINOR version when you add functionality in a backwards-compatible manner, and
* PATCH version when you make backwards-compatible bug fixes.</blockquote>

SemVer is very useful for indicating how software has changed from one version to another in a programmatic way, but it can be unintuitive for humans, especially for non-developers. It is important to understand that a "major" version increase does not necessarily indicate a shiny new version of the software with lots of new features—but rather more likely to have removed deprecated classes and methods, and/or moved functionality from one place to another in a backwards-incompatible manner. Conversely, a "minor" version increase might indicate the addition of a single new method somewhere, or many significant new features—and SemVer does not specify a mechanism for quantifying which scenario it is in each case.

=== API vs. SPI backwards compatibility ===

SciJava uses SemVer for '''API''' [[compatibility]], but not necessarily '''SPI''' [[compatibility]]:

* '''API''' ([https://en.wikipedia.org/wiki/Application_programming_interface '''A'''pplication '''P'''rogramming '''I'''nterface]) refers to downstream ''consumers'' which ''invoke'' methods of classes. For example, if your code uses a {{Javadoc | package=org/scijava/module | class=ModuleService}} and calls the {{Javadoc | package=org/scijava/module | class=ModuleService | anchor=getModules()}} method, SemVer guarantees that that method will continue to exist with a compatible return type as long as the version number's major digit does not increase.
* '''SPI''' ([https://en.wikipedia.org/wiki/Service_provider_interface '''S'''ervice '''P'''rovider '''I'''nterface]) refers to downstream ''implementors'' which ''extend'' classes. For example, if your code provides its own implementation of the {{Javadoc | package=org/scijava/module | class=ModuleService}} interface, updating to a new version of <code>scijava-common</code> may break your code due to the addition of new method signatures which your class does not implement.

That said, the projects do make a best effort to limit such SPI breakages. In addition, each interface is accompanied by a corresponding abstract class and/or default implementation, intended as a future-resistant extension point for new implementations. So e.g. in the case of {{Javadoc | package=org/scijava/module | class=ModuleService}}, making your class extend {{Javadoc | package=org/scijava/module | class=DefaultModuleService}} instead of only implementing the interface would be an effective way of largely shielding yourself from future SPI breakages during dependency version upgrades. Some other examples:

{| class="wikitable"
|-
| '''Interface of interest'''
| '''Base class to extend'''
|-
| {{Javadoc | package=org/scijava/plugin | class=RichPlugin}}
| {{Javadoc | package=org/scijava/plugin | class=AbstractRichPlugin}}
|-
| {{Javadoc | package=org/scijava/command | class=Command}}
| {{Javadoc | package=org/scijava/command | class=ContextCommand}}
|-
| {{Javadoc | package=org/scijava/tool | class=Tool}}
| {{Javadoc | package=org/scijava/tool | class=AbstractTool}}
|-
| {{Javadoc | package=org/scijava/service | class=Service}}
| {{Javadoc | package=org/scijava/service | class=AbstractService}}
|-
| {{Javadoc | project=SCIFIO | package=io/scif | class=Format}}
| {{Javadoc | project=SCIFIO | package=io/scif | class=AbstractFormat}}
|}

= Managing releases =

The SciJava [[philosophy]] is to [[Philosophy#Release_early.2C_release_often|release early, release often]]. To make doing so as painless as possible, we employ several [[project management]] resources.

Intuitively, a feature has four "phases" of development:

# '''Developed on a topic branch.''' The source code is branched and the feature is developed on the branch, to avoid interfering with anyone else's work.
# '''Merged to master.''' The feature is merged to the <code>master</code> branch of the source code repository on GitHub.
# '''Deployed to Maven.''' A new release of the project is cut and ''deployed'' to the ImageJ Maven repository. This makes the feature available for use from downstream projects, by depending on the new release.
# '''Uploaded to ImageJ.''' A release is uploaded to an ImageJ [[update site]], putting it into the hands of end users.

The following sections describe how each [[project management]] resource facilitates these phases of development.

== Jenkins ==

The [http://jenkins.imagej.net/ ImageJ Jenkins server] tests builds and performs releases. It deploys <code>SNAPSHOT</code> builds to the [http://maven.imagej.net/ ImageJ Maven repository] in response to pushes to each code repository's <code>master</code> branch. So any downstream projects depending on a version of <code>LATEST</code> for a given component will match the last successful Jenkins build—i.e., the latest code on <code>master</code>.

== Maven repositories ==

SciJava projects use the [http://maven.imagej.net/ ImageJ Maven repository] (using [http://www.sonatype.com/nexus Sonatype Nexus]) for managing SciJava libraries. Such a repository serves two main purposes:

# '''Deployment.''' It provides a place to store our JAR artifacts, including snapshot versions, without the [http://maven.apache.org/guides/mini/guide-central-repository-upload.html red tape] of submitting to the central Maven repository.
# '''Proxying.''' It acts as an on-demand mirror for the public Maven repositories, reducing load on the central Maven server and potentially reducing local build times.

The first purpose is especially important for agile development across multiple components. For more details, see [http://books.sonatype.com/nexus-book/reference/repoman-sect-reasons.html Reasons to Use a Repository Manager].

=== Deploying artifacts ===

To deploy JARs, POMs and other artifacts to the ImageJ Maven repository, you will first need a user account. Assuming you have one, follow these steps:

<ol>
<li>Verify that you can log in to the [http://maven.imagej.net/ Nexus web UI] using your credentials.</li>
<li>Install the following <code>settings.xml</code> and <code>settings-security.xml</code> into your Maven configuration directory (typically <code>~/.m2</code>):
<p>
<code>settings-security.xml</code>
<source lang="xml">
<settingsSecurity>
  <master>[YOUR MASTER HASH]</master>
</settingsSecurity>
</source>
</p>
<p>
<code>settings.xml</code>
<source lang="xml">
<settings>

  <!--
  Credentials for artifact deployment to ImageJ Nexus; see:
  http://maven.apache.org/guides/mini/guide-encryption.html
  -->
  <servers>
    <server>
      <id>imagej.releases</id>
      <username>[YOUR USERNAME]</username>
      <password>[YOUR PASSWORD HASH]</password>
    </server>
    <server>
      <id>imagej.snapshots</id>
      <username>[YOUR USERNAME]</username>
      <password>[YOUR PASSWORD HASH]</password>
    </server>
  </servers>

  <!--
  ImageJ Nexus central mirror configuration; see:
  http://books.sonatype.com/nexus-book/reference/maven-sect-single-group.html
  -->

  <mirrors>
    <mirror>
      <!--This sends everything else to /public -->
      <id>nexus</id>
      <mirrorOf>*</mirrorOf>
      <url>http://maven.imagej.net/content/groups/public</url>
    </mirror>
  </mirrors>
  <profiles>
    <profile>
      <id>nexus</id>
      <!--Enable snapshots for the built in central repo to direct -->
      <!--all requests to nexus via the mirror -->
      <repositories>
        <repository>
          <id>central</id>
          <url>http://central</url>
          <releases><enabled>true</enabled></releases>
          <snapshots><enabled>true</enabled></snapshots>
        </repository>
      </repositories>
     <pluginRepositories>
        <pluginRepository>
          <id>central</id>
          <url>http://central</url>
          <releases><enabled>true</enabled></releases>
          <snapshots><enabled>true</enabled></snapshots>
        </pluginRepository>
      </pluginRepositories>
    </profile>
  </profiles>
  <activeProfiles>
    <!--make the profile active all the time -->
    <activeProfile>nexus</activeProfile>
  </activeProfiles>
</settings>
</source>
</p>
</li>
<li>Replace instances of <code>[YOUR USERNAME]</code> in <code>settings.xml</code> with your Nexus username.</li>
<li>Follow the [http://maven.apache.org/guides/mini/guide-encryption.html directions for encrypting your password] to generate a master hash and a password hash.</li>
<li>Replace <code>[YOUR MASTER HASH]</code> in <code>settings-security.xml</code> with your master hash.</li>
<li>Replace <code>[YOUR PASSWORD HASH]</code> in <code>settings.xml</code> with your password hash.</li>
</ol>
Once you have followed these steps, it should be possible to deploy snapshot JARs to the Nexus using the <code>mvn deploy</code> command. Note that if you deploy an umbrella project, it is normal to receive an eventual build failure when attempting to deploy the umbrella project itself—all component modules should deploy successfully before that, though.

== ImageJ update sites ==

TODO - [http://sites.imagej.net/ sites.imagej.net]
