{{Development}}= SciJava project structure =

The [[ImageJ]] project, and related projects in the [[SciJava]] software ecosystem, are carefully structured to foster [[extensibility]].

== Organizational hierarchy ==

<graphviz border alignment="right" caption="SciJava organization hierarchy">
digraph orgs {
    label="SciJava organization hierarchy"
    graph [ranksep="0.1"]
    node [shape=box, style=filled]
    "SciJava" [color=green, URL="[https://github.com/scijava]"]
    "ImgLib2" [color=pink, URL="[https://github.com/imglib]"]
    "ImageJ" [color=yellow, URL="[https://github.com/imagej]"]
    "SCIFIO" [color=lightblue, URL="[https://github.com/scifio]"]
    "SciJava" -> "ImgLib2"
    "ImgLib2" -> "ImageJ"
    "ImageJ" -> "SCIFIO"
}
</graphviz>

There are four organizations on [https://github.com/ GitHub] which form the backbone of the [[SciJava]] ecosystem:

* [https://github.com/scijava scijava] - for [[SciJava]] projects
* [https://github.com/imglib imglib] - for [[ImgLib2]] projects
* [https://github.com/imagej imagej] - for [[ImageJ]] projects
* [https://github.com/scifio scifio] - for [[SCIFIO]] projects

Each organization contains several related projects under its respective umbrella: a core library (see below) and several extensions. In social terms, each organization represents a collection of conceptually related projects developed by a distinct [[Contributors|team of developers]].

Additional organizations further extend this structure:

* [https://github.com/fiji fiji] - for [[Fiji]] projects
* [https://github.com/uw-loci uw-loci] - for [[User:LOCI|LOCI]] projects
* [https://github.com/slim-curve slim-curve] - for [[SLIM Curve]] projects
* <your organization here!>

The diagram on the right shows the SciJava software stack at the organizational level.
{{Notice | message=Please note that this picture is necessarily oversimplified: it is certainly not the case that e.g. ''all'' SCIFIO projects depend on ''all'' ImageJ projects. (Actually, the core <code>scifio</code> library depends only on the core <code>imagej-common</code> library; see below.) For various reasons, there are projects in each of the <code>imagej</code>, <code>imglib</code> and <code>scifio</code> organizations which depend on projects in both of the other organizations. However, while these three ''organizations'' are interdependent as a whole, we strive to avoid dependency cycles at the level of individual artifacts.}}

== Git repositories ==

Each project is contained in its own [[Git]] repository, so that interested developers can cherry-pick only those parts of interest. Version control is an indispensable tool to ensure ''scientific reproducibility'' (see below) by tracking known-working states of the source code, and maintain a written recorded of how and why the code has changed over time. For technical details, see the [[Git]] section.

=== Why separate Git repositories? ===

With [[Maven]] it is possible to create a [http://maven.apache.org/guides/mini/guide-multiple-modules.html multi-module reactor] that unifies several project artifacts into a single build, typically within a single Git repository.

While many components of the SciJava software stack used to be structured this way, we found that lumping multiple components into a single Git repository with a multi-module build has disadvantages compared to separate Git repositories with single-module builds:
* Typically, components of a multi-module project are all versioned together, but we have opted for individual [[versioning]] of components, for [[Philosophy#Release_early.2C_release_often|reasons of rapid iteration]].
* Individual repositories make it easier for developers to cherry-pick only those components of interest, without building the rest of the code, since dependencies are fetched on demand from remote [[Maven]] repositories.
* Concerns are better separated, with each component encapsulating its own codebase, issues, pull requests and technical documentation.
* Since every component follows a consistent structure, the supporting tools (e.g., [https://github.com/scijava/scijava-scripts these scripts]) are simpler to develop and maintain.

Of course, there are downsides, too:
* Changes affecting multiple components must be done as separate patch sets (i.e., commits or pull requests).
* Issues relevant to multiple components must be filed separately in each issue tracker and cross-referenced.
* It can be more difficult to locate code of interest, since the codebase is spread across so many repositories.

As a rule of thumb, we find that multi-module [[Maven]] projects stored within a single Git repository are a natural fit for "big bang" software which is versioned in lockstep and carefully tested before each release, whereas single-module projects stored in separate Git repositories work well for the [[Philosophy#Release_early.2C_release_often|RERO]]-style release paradigm.

== Maven component structure ==

<graphviz border alignment="right" size="400px" caption="Parent POM hierarchy">
digraph poms {
    label="Parent POM hierarchy"
    "pom-scijava" [color=green, style=filled, URL="[https://github.com/scijava/pom-scijava]"]
    "pom-imglib2" [color=pink, style=filled, URL="[https://github.com/imglib/pom-imglib2]"]
    "pom-imagej" [color=yellow, style=filled, URL="[https://github.com/imagej/pom-imagej]"]
    "pom-scifio" [color=lightblue, style=filled, URL="[https://github.com/scifio/pom-scifio]"]
    "pom-fiji" [color=orange, style=filled, URL="[https://github.com/fiji/pom-fiji]"]
    "pom-scijava" -> "pom-imglib2"
    "pom-scijava" -> "pom-imagej"
    "pom-scijava" -> "pom-scifio"
    "pom-imagej" -> "pom-fiji"
}
</graphviz>

All projects in these organizations use [[Maven]] for [[Project Management|project management]]. Each organization has its own Maven [http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-relationships.html#pom-relationships-sect-more-coordinates groupId], as well as a [http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-relationships.html#pom-relationships-sect-project-inheritance parent POM] that all other projects in that organization extend:

{| class="wikitable"
| '''Project'''
| '''Organization'''
| '''groupId'''
| '''Parent POM'''
|-
| [[SciJava]]
| [https://github.com/scijava scijava]
| [http://maven.imagej.net/index.html#nexus-search;gav~org.scijava org.scijava]
| {{GitHub|org=scijava|repo=pom-scijava|label=pom-scijava}}
|-
| [[ImageJ]]
| [https://github.com/imagej imagej]
| [http://maven.imagej.net/index.html#nexus-search;gav~net.imagej net.imagej]
| {{GitHub|org=imagej|repo=pom-imagej|label=pom-imagej}}
|-
| [[ImgLib2]]
| [https://github.com/imglib imglib]
| [http://maven.imagej.net/index.html#nexus-search;gav~net.imglib2 net.imglib2]
| {{GitHub|org=imglib|repo=pom-imglib2|label=pom-imglib2}}
|-
| [[SCIFIO]]
| [https://github.com/scifio scifio]
| [http://maven.imagej.net/index.html#nexus-search;gav~io.scif io.scif]
| {{GitHub|org=scifio|repo=pom-scifio|label=pom-scifio}}
|-
| [[Fiji]]
| [https://github.com/fiji fiji]
| [http://maven.imagej.net/index.html#nexus-search;gav~sc.fiji sc.fiji]
| {{GitHub|org=fiji|repo=pom-fiji|label=pom-fiji}}
|-
| [[SLIM Curve]]
| [https://github.com/slim-curve slim-curve]
| [http://maven.imagej.net/index.html#nexus-search;gav~slim-curve slim-curve]
| -
|-
| [[LOCI]]
| [https://github.com/uw-loci uw-loci]
| [http://maven.imagej.net/index.html#nexus-search;gav~loci loci]
| {{GitHub|org=uw-loci|repo=pom-loci|label=pom-loci}}
|}

The hierarchy of organizational parent POMs is shown in the diagram to the right. The <code>pom-scijava</code> parent forms the foundation of all other Maven projects in the ecosystem.

== Bill of Materials ==

The <code>pom-scijava</code> parent includes a [http://howtodoinjava.com/2014/02/18/maven-bom-bill-of-materials-dependency/ Bill of Materials] (BOM) which declares compatible versions of all core SciJava software in its [http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Management dependencyManagement section]. These versions are intended to be used together in downstream projects, preventing version skew (symptoms of which include <code>ClassNotFoundException</code> and <code>NoSuchMethodError</code>, as well as erroneous behavior in general). This BOM is especially important while some components are still in beta, since they may sometimes break backwards compatibility.

Similarly, the <code>pom-imagej</code> parent includes a consolidated Bill of Materials for projects in the ImageJ, ImgLib2 and SCIFIO organizations, as well as for downstream projects which extend the <code>pom-imagej</code> parent. The rationale for this consolidation is that each of these three organizations has projects which depend on components within the other two organizations. So broadly speaking, these three organizations form an interdependent "triumvarate." However, there are no circular dependencies at the level of individual components. See [http://imagej.net/pipermail/imagej-devel/2014-October/002280.html this thread on the imagej-devel mailing list] for further details.

== Core libraries ==

<graphviz border alignment="right" caption="Core library hierarchy">
digraph libs {
    label="Core library hierarchy"
    
    "scijava-common" [color=green, style=filled, URL="[https://github.com/scijava/scijava-common]"]
    "imagej-common" [color=yellow, style=filled, URL="[https://github.com/imagej/imagej-common]"]
    "imagej-ops" [color=yellow, style=filled, URL="[https://github.com/imagej/imagej-ops]"]
    "imglib2" [color=pink, style=filled, URL="[https://github.com/imglib/imglib2]"]
    "scifio" [color=lightblue, style=filled, URL="[https://github.com/scifio/scifio]"]
    "scijava-common" -> "imagej-common"
    "imglib2" -> "imagej-common"
    "imagej-common" -> "scifio"
    "imagej-common" -> "imagej-ops"
}
</graphviz>

The [[SciJava]] software stack is composed of the following core libraries:

* [[SciJava Common]] - The SciJava application container and plugin framework.
* [[ImgLib2]] - The N-dimensional image data model.
* [[ImageJ Common]] - Metadata-rich image data structures and SciJava extensions.
* [[ImageJ OPS]] - The framework for reusable image processing operations.
* [[SCIFIO]] - The framework for N-dimensional image I/O.

The dependency hierarchy of library artifacts is shown in the diagram to the right.

== Reproducible builds ==

{{Sidebox
| title = Why are reproducible builds so essential for science?
| width = 40%
| body =
Arguably '''the most important thing''' in science is to gain insights about nature '''that can be verified by other researchers'''. It is this mission for which [[ImageJ]] and [[Fiji]] stand, and it is the central reason why they are [[Open Source]].

To verify results, it is absolutely necessary to be able to reproduce results claimed in scientific articles, and in the interest of efficiency, it should be '''easy''' to reproduce the results, and it should '''also''' be easy to scrutinize the used methods—incorrect results can be artifacts of flawed algorithms, after all.

To that end, it should be obvious that researchers '''need''' to have the ability to inspect the exact source code corresponding to the software used to generate the results to be verified. In other words, reproducible builds are required for sound scientific research.
}}=== What is a reproducible build? ===

A software ''version'' (or ''build'') is called '''reproducible''' if it is easy to regenerate the exact same software application from the source code.

For example, you can refer to "ImageJ 1.49g" as a ''reproducible build'', or to ''Sholl Analysis 3.4.3'', while referring to "ImageJ" is irreproducible.

It gets more subtle when making heavy use of software libraries (sometimes called ''dependencies''). It is known, for example, that many plugins in the now-defunct [[MBF|MacBiophotonics distribution of ImageJ]] worked fine with ImageJ 1.42l, but stopped working somewhere between that version and ImageJ 1.44e. That is: referring to, say, ''the Colocalisation Analysis plugin'' does '''not''' refer to a reproducible build because it is very hard to regenerate a working Colocalisation Analysis and ImageJ 1.x version that could be used to verify previously published results.

=== Advantages of reproducible builds ===

Some cardinal reasons to strive for reproducible builds are:

* It becomes possible to use a [https://www.atlassian.com/git/tutorials/comparing-workflows/feature-branch-workflow feature branch workflow] development style where the <code>master</code> branch is always release ready—or even a [https://en.wikipedia.org/wiki/Continuous_delivery continuous delivery] approach.
* Debugging with [http://git-scm.com/book/en/v2/Git-Tools-Debugging-with-Git#Binary-Search git-bisect] becomes feasible.
* As a consequence, it avoids [https://en.wikipedia.org/wiki/Technical_debt technical debt] in favor of a robust development style.
* It attracts more developers to the project, since things "just work" out of the box.

=== How SciJava achieves reproducible builds ===

For the reasons stated above, the SciJava software components strive for reproducible builds. The goal is to ensure that code which builds and runs today will continue to do so in exactly the same way for many years to come.

Each project depends on release [http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-pom-syntax.html#pom-reationships-sect-versions versions] of ''all'' its dependencies—never on [http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-pom-syntax.html#pom-relationships-sect-snapshot-versions snapshots] or [http://books.sonatype.com/mvnref-book/reference/pom-relationships-sect-project-dependencies.html#pom-relationships-sect-version-ranges version ranges]. A Maven snapshot is a moving target, and depending on one results in an irreproducible build. Similarly, all Maven plugins used, as well as the parent POM, are also declared at release versions. In short: all <code>&lt;version&gt;</code> tags specify release versions, never <code>SNAPSHOT</code> or <code>LATEST</code> versions. We use the [http://maven.apache.org/enforcer/maven-enforcer-plugin/ Maven Enforcer Plugin] to enforce this requirement (though it can be disabled by setting the <code>scijava.enforce.skip</code> system property).

== Versioning ==

The SciJava software stack uses the [http://semver.org/ Semantic Versioning] system. This scheme communicates information about the backwards compatibility (or lack thereof) between versions of each individual software component. In a nutshell:

<blockquote>Given a version number MAJOR.MINOR.PATCH, increment the:
* MAJOR version when you make incompatible API changes,
* MINOR version when you add functionality in a backwards-compatible manner, and
* PATCH version when you make backwards-compatible bug fixes.</blockquote>

SemVer is very useful for indicating how software has changed from one version to another in a programmatic way, but it can be unintuitive for humans, especially for non-developers. It is important to understand that a "major" version increase does not necessarily indicate a shiny new version of the software with lots of new features—but rather more likely to have removed deprecated classes and methods, and/or moved functionality from one place to another in a backwards-incompatible manner. Conversely, a "minor" version increase might indicate the addition of a single new method somewhere, or many significant new features—and SemVer does not specify a mechanism for quantifying which scenario it is in each case.

=== API vs. SPI backwards compatibility ===

SciJava uses SemVer for '''API''' compatibility, but not necessarily '''SPI''' compatibility:

* '''API''' ([https://en.wikipedia.org/wiki/Application_programming_interface '''A'''pplication '''P'''rogramming '''I'''nterface]) refers to downstream ''consumers'' which ''invoke'' methods of classes. For example, if your code uses a {{Javadoc | package=org/scijava/module | class=ModuleService}} and calls the {{Javadoc | package=org/scijava/module | class=ModuleService | anchor=getModules()}} method, SemVer guarantees that that method will continue to exist with a compatible return type as long as the version number's major digit does not increase.
* '''SPI''' ([https://en.wikipedia.org/wiki/Service_provider_interface '''S'''ervice '''P'''rovider '''I'''nterface]) refers to downstream ''implementors'' which ''extend'' classes. For example, if your code provides its own implementation of the {{Javadoc | package=org/scijava/module | class=ModuleService}} interface, updating to a new version of <code>scijava-common</code> may break your code due to the addition of new method signatures which your class does not implement.

That said, the projects do make a best effort to limit such SPI breakages. In addition, each interface is accompanied by a corresponding abstract class and/or default implementation, intended as a future-resistant extension point for new implementations. So e.g. in the case of {{Javadoc | package=org/scijava/module | class=ModuleService}}, making your class extend {{Javadoc | package=org/scijava/module | class=DefaultModuleService}} instead of only implementing the interface would be an effective way of largely shielding yourself from future SPI breakages during dependency version upgrades. Some other examples:

{| class="wikitable"
|-
| '''Interface of interest'''
| '''Base class to extend'''
|-
| {{Javadoc | package=org/scijava/plugin | class=RichPlugin}}
| {{Javadoc | package=org/scijava/plugin | class=AbstractRichPlugin}}
|-
| {{Javadoc | package=org/scijava/command | class=Command}}
| {{Javadoc | package=org/scijava/command | class=ContextCommand}}
|-
| {{Javadoc | package=org/scijava/tool | class=Tool}}
| {{Javadoc | package=org/scijava/tool | class=AbstractTool}}
|-
| {{Javadoc | package=org/scijava/service | class=Service}}
| {{Javadoc | package=org/scijava/service | class=AbstractService}}
|-
| {{Javadoc | project=SCIFIO | package=io/scif | class=Format}}
| {{Javadoc | project=SCIFIO | package=io/scif | class=AbstractFormat}}
|}

= Managing releases =

The SciJava [[philosophy]] is to [[Philosophy#Release_early.2C_release_often|release early, release often]]. To make doing so as painless as possible, we employ several [[project management]] resources.

== Jenkins ==

The [http://jenkins.imagej.net/ ImageJ Jenkins server] tests builds and performs releases. It deploys <code>SNAPSHOT</code> builds to the [http://maven.imagej.net/ ImageJ Maven repository] in response to pushes to each code repository's <code>master</code> branch. So any downstream projects depending on a version of <code>LATEST</code> for a given component will match the last successful Jenkins build—i.e., the latest code on <code>master</code>.

== Maven repositories ==

TODO - [http://maven.imagej.net/ ImageJ Maven repository] vs. Maven Central

== ImageJ update sites ==

TODO - [http://sites.imagej.net/ sites.imagej.net]
