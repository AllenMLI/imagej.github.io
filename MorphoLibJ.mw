{{Infobox
| name                   = MorphoLibJ
| software               = IJPB-plugins
| author                  = David Legland, {{Person|Iarganda}}
| maintainer             = David Legland, {{Person|Iarganda}}
| source                 = {{GitHub|org=ijpb|repo=MorphoLibJ}}
| released               = July 3<sup>rd</sup>, 2014
| latest version         = January 12<sup>th</sup>, 2016 ([[MorphoLibJ]] v1.1.1)
| status                 = stable, active
| category               = [[:Category:Analysis|Analysis]], [[:Category:Filtering|Filtering]], [[:Category:Segmentation|Segmentation]], [[:Category:Mathematical_morphology|Mathematical morphology]]
}}
Collection of [[wikipedia:Mathematical morphology|mathematical morphology]] methods and '''plugins''' for ImageJ, created at [http://www-ijpb.versailles.inra.fr/en/bc/equipes/modelisation-imagerie/ INRA-IJPB Modeling and Digital Imaging lab].

The library implements several functionalities that were missing in ImageJ, and that were not or only partially covered by other plugins. Namely:

* '''Morphological filtering''' for 2D/3D and binary or grey level images: erosion & dilation, closing & opening, morphological gradient & Laplacian, top-hat...

* '''Morphological reconstruction''', for 2D/3D and binary or grey level images, allowing fast detection of regional or extended extrema, removing of borders, or hole filling

* '''Watershed segmentation''' + GUI, making it possible to segment 2D/3D images of cell tissues

* '''2D/3D measurements''': volume, surface area, inertia ellipse/ellipsoid...

* '''Binary / label images utilities''' for removing or keeping largest connected component, perform size opening, fill holes, kill borders...

== Morphological filters ==
Morphological filters are very common filters that can be combined together to provide a large variety of solutions. They are local filters, in the sense that they consider the neighborhood of each pixel/voxel.

Morphological filters are defined according to a '''structuring element''' of a given size and
shape. Common structuring element include squares, discrete disks and octogons. Linear structuring element of various orientations may also be used to assess local orientation of the
structures.

=== Principles ===
==== Erosion and dilation ====
The most basic morphological filters are the '''morphological dilation''' and the '''morphological erosion'''. The morphological dilation computes for each pixel the maximum within its neighbourhood (defined by the structuring element), whereas the morphological erosion considers the minimum value within the neighborhood.
[[Image:MorphoLibJ-grains-dilation-erosion.png|thumb|center|700px|Some examples of morphological filters on a grey level image. From left to right: original image, result of dilation with a square structuring element, and result of erosion with the same structuring element.]]
Applying a  dilation or an erosion changes the size of the structures in the image: the grains in the result of the dilated image are larger. Morphological erosion can also be used on binary images to help separating touching particles.

==== Opening and closing ====
Morphological dilation and erosion are often used in combination. For example, the result of a dilation followed by an erosion is called a '''morphological closing''', and removes dark structures smaller than the structuring element. It can also connect bright structures that were separated by a thin dark space.

In a symmetric way, the result of an erosion followed by a dilation is called a '''morphological opening''', and removes bright structures smaller than the structuring element.

[[Image:MorphoLibJ-grains-closing-opening.png|thumb|480px|center|Some examples of composed morphological filters. From left to right: morphological closing, and morphological opening.]]

Note that even if opening and closing better preserve the size of the structures in the original image, the shape is slightly altered. For example, the result of morphological closing on the figure above creates artificial connections between grains. Choosing the best size for the structuring element is often a compromise between noise removal and preservation of structure shape.

==== Morphological gradients ====
More complicated combinations of elementary operations can be used. The '''morphological gradient''', computed as the difference of the result of a morphological dilation with the
result of a morphological erosion, reveals the '''boundaries''' of the structures within the image. The '''morphological Laplacian''' is defined as half the sum of a morphological
dilation and a morphological erosion with the same structuring element, minus the original
image. It results in enhancing the edges of the image.

==== Top-hats ====
The '''white top-hat''' first computes a morphological opening (resulting in removing bright structures smaller than structuring elements), and removes the result from the original image. When applied with a large structuring element, the result is an homogenization of the background, making bright structures easier to segment. Similarly, the '''dark top-hat''' can be used to enhance dark structures observed on an non-homogeneous background.
[[Image:MorphoLibJ-grains-gradient-Laplacian-whiteTopHat.png|thumb|center|700px|More examples of composed morphological filters. From left to right: morphological gradient, morphological Laplacian, morphological white top-hat.]]

=== Usage ===
[[Image:MorphoLibJ-mosaic-filters.png|right|thumb|550px|MorphoLibJ filter examples: DAPI stained nuclei image and the result of applying different morphological filters with an octagon of radius 5 as structuring element.]]
The collection of morphological filters is available in the {{bc | Plugins | MorphoLibJ}} menu. Filters are '''implemented both for 2D and 3D images''', and work for binary, gray level or color (RGB) images.
==== Planar images ====
Morphological filters for planar images are available {{bc | Plugins | MorphoLibJ | Morphological filters}}. The dialog let the user choose the structuring element shape, radius, and eventually preview the result. The following list of operations can be chosen:
* '''erosion''' keeps the minimum value within the neighborhood defined by the structuring element.

* '''dilation''' keeps the maximum value within the neighborhood defined by the structuring element.

* '''closing''' consists in the succession of a dilation with an erosion. Morphological closing makes dark structures smaller than the structuring element disappear.

* '''opening''' consists in the succession of an erosion with a dilation. Morphological opening makes bright structures smaller than the structuring element disappear.

* '''morphological gradient''' is defined as the difference of a morphological dilation and a morphological erosion with the same structuring element, and enhances edges of the original images.

* '''morphological Laplacian''' is defined as half the sum of a morphological dilation and a morphological erosion with the same structuring element, minus the original image, and enhances edges of the image.

* '''black top-hat''' consists in subtracting the original image from the result of a morphological closing, and results in the enhancement of dark structures smaller than structuring element.

* '''white top-hat''' consists in subtracting the result of a morphological opening from the original image, and results in the enhancement of bright structures smaller than structuring element.

The following structuring elements can be used for 2D images:

* disk 
* square
* octagon
* diamond
* line with angle of 0, 90, 45 or 135 degrees

==== 3D images ====
Morphological filters for 3D images are available {{bc | Plugins | MorphoLibJ | Morphological filters (3D)}}. The dialog let the user choose the structuring element shape and radius. The same list of operations as for planar images is provided. Planar structuring elements can be used (the operation is simply repeated on each slice), as well as a cubic or spherical structuring element. For most structuring elements, the size can be chosen for each direction.

== Morphological reconstruction ==
The morphological reconstruction is at the basis of many useful algorithms, such as border removing, hole filling, or detection of regional minima or maxima in grey level images.
=== Principle ===
The principle of geodesic reconstruction is to repeat '''conditional dilations or erosions''' until idempotence. Conditional dilation is the result of a dilation, combined with a mask image using a logical operation. Conditional dilations are repeated until no more modification occur (idempotence condition).

The following figure shows several steps of a geodesic reconstruction by dilation on a pair of binary images. The mask image is shown in gray, and the marker image is shown in black on the first image. The reconstructed images at each step are shown in black. The markers propagates within the mask until they fill the chosen regions.
[[Image:MorphoLibJ-geodesic-reconstruction.png|thumb|center|750px|Principle of the geodesic reconstruction algorithm. From left to right: original image in gray with marker superimposed in black, and result of conditional dilations with increasing sizes.]]

=== Applications to binary images ===
By choosing the marker image, several operations may be automatized. For example, computing geodesic reconstruction with image of borders, and combining with original image will '''remove particles or regions touching the borders'''. In a similar way, computing geodesic reconstruction by using the border of the complement of the image makes it possible to '''fill holes''' that may appear in particles.
[[Image:MorphoLibJ-kill-borders-fill-holes.png|thumb|400px|center|Some applications of geodesic reconstruction. From left to right: original image, result of kill borders, result of fill holes.]]
=== Applications to grey level images ===
Geodesic reconstructions can be applied to grey level images. By manually choosing binary markers such that they overlay specific structures, and after applying a geodesic reconstruction by dilation, it is possible to obtain a grey level image containing only the chosen structures. The '''border kill''' operation can also be applied on grey level images, making possible to rapidly remove structures touching the image borders.
[[Image:MorphoLibJ-grains-markers-reconstruction-by-dilation-border-kill.png|thumb|700px|center|Some applications of geodesic reconstruction on grey level images. From left to right: original image with superimposed markers, result of geodesic reconstruction by dilation, result of border kill operation.]]
=== Regional and extended extrema ===
'''Regional minima''' are defined as connected regions of elements (pixels or voxels) with the same value, and whose neighboring elements all have values greater than that of the region. Similarly, '''regional maxima''' are regions of connected pixels or voxels with same value, whose neighbors all have smaller value.

One problem arising with regional minima or maxima is that they are very sensitive to noise. It is often more convenient to use so-called extended extrema. The principle is to define a tolerance value for filtering the extrema. For example, '''extended maxima''' are defined as a connected region containing elements such that the difference of the value of each element within the region with the maximal value within the region is lower than the tolerance, and such that the neighbors of the regions all have values smaller than the maximum within the region minus the tolerance. This definition allows the identification of larger extrema, that better takes into account the noise within the image. The '''extended minima''' are defined in a similar way, and are efficiently used as pre-processing step for watershed segmentation.

Both extended maxima and minima are computed using the geodesic reconstruction algorithm. More details can be found in the book of Soille (2003).
[[Image:MorphoLibJ-grains-regional-and-extended-maxima.png|thumb|700px|center|Regional and extended maxima on a grey-level image. Left: original image. Middle: result of regional maxima. Right: result of extended maxima.]]

=== Usage ===
The following operations are available in the {{bc | Plugins | MorphoLibJ}} menu. Some plugins correspond to common operations and encompass several processing steps:

* '''Kill Borders''': remove the particles touching the border of a binary or grey level image, in 2D or 3D.
* '''Fill Holes''': remove holes inside particles in binary images, or remove dark regions surrounded by bright crests in grey level images. Works for both 2D and 3D images.
Several plugins allow the computation of binary minima or maxima from grey level images, and their combination with grey level images:
* '''Regional Min / Max''': compute regional minima or extrema in grey level or binary image, with specified connectivity.
* '''Regional Min / Max 3D''': compute regional minima or extrema in 3D grey level or binary image, with specified connectivity.
* '''Extended Min / Max''': compute extended minima or extrema in grey level image, with specified connectivity.
* '''Extended Min / Max 3D''': compute extended minima or extrema in 3D grey level or binary image, with specified connectivity.
* '''Impose Min / Max''': impose minima or maxima on a grey level image.
* '''Impose Min / Max 3D''': impose minima or maxima on a 3D grey level image.
The geodesic reconstruction algorithm is provided as a plugin to allow its inclusion in user-designed macros or plugins:
* '''Geodesic Reconstruction''': compute the geodesic reconstruction by erosion or dilation using a marker image and a mask image, and a specified connectivity.
* '''Geodesic Reconstruction 3D''': compute the geodesic reconstruction by erosion or dilation on a 3D image.

== Watershed segmentation ==
[[Image:Classic-Watershed-lines-blur-blobs.png|thumb|200px|Overlay of watershed lines on blurred blobs.]] The watershed algorithm assimilates the grey level image to a digital elevation model, and aims at detecting the different catchment basins. In the grey-level image, the catchment basins correspond to dark regions surrounded by bright structures (the "crests"). It is a very popular technique specially used to segment touching objects. The MorphoLibJ suite contains several implementations of the algorithm and plugins that make use of it:

* [[Classic Watershed]], plugin implementing the original watershed algorithm by Pierre Soille and Luc M. Vincent (1990) to segment 2D/3D grayscale images.
* [[Marker-controlled Watershed]], a plugin to perform watershed by flooding from specific seed points or markers by Meyer and Beucher (1990).
* [[Morphological Segmentation]], a plugin with a graphical user interface to segment 2D/3D images based on morphological operations and the watershed algorithm.

== Measurements ==
=== Geometric measurements ===
Several measurements are provided for '''binary or label''' 2D or 3D images. The results are provided in a ResultsTable, whose name contains the name of the original image. The plugin calculating these measurements is found under {{bc | Plugins | MorphoLibJ | Analyze | Geometric Measurements 3D}}:

* '''Bounding box''' returns the minimal and maximal coordinates in each direction for each label.
* '''Volume / surface area''' computes the volume, the surface area, and a sphericity index, defined as <math>36\pi V^{2}/S^{3}</math>. Surface area is computed using a discretized version of the [https://en.wikipedia.org/wiki/Crofton_formula Crofton formula], that computes intersections with line grids of various orientations (currently either 3 or 13).
* '''Inertia ellipse / ellipsoid''' returns the centroid (center of gravity) as well as the size and the orientation of the inertia ellipse or ellipsoid of each particle. Radiuses are sorted in decreasing order. Angles are given in degrees, and correspond to the azimut ("yaw"), the elevation ("pitch"), and the roll around the main axis.

=== Intensity measurements ===

Other measurements are provided for pairs of grayscale and label 2D or 3D images ({{bc | Plugins | MorphoLibJ | Analyze | Measure 3D}}). The plugin calculates the '''mean''', the '''standard deviation''', the '''maximum''' and the '''minimum intensity''' value of each labeled region in the grayscale image. The results are displayed as well in a ResultsTable.

==Binary and label image utilities==
The MorphoLibJ library provides several utility functions for processing binary and label images.
=== Utilities for binary images ===
[[Image:MorphoLibJ-grains-binary-label-distance.png|thumb|700px|right|Binary image, result of connected components labeling, and computation of distance map on the complement of binary image.]]
Some functions are specific for the processing of binary images, namely:
* '''Connected Components Labeling''' transforms the binary image into a label image by assigning a specific number (label) to each connected component.
* '''Chamfer Distance Map''' computes an approximate distance map from a binary image between each foreground pixel to the nearest background pixel.
* '''Geodesic Distance Map''' computes the geodesic distance between each foreground pixel of a binary mask image to the closest pixel of a marker image, while staying within the particle represented by the mask image.
[[Image:MorphoLibJ-geodesic-distance-example.png|thumb|350px|right|Computation of the geodesic distance map on a binary image from the DRIVE database (Staal et al., 2004). Left: original image with marker superimposed in red. Right: result of geodesic distance map, hot colors correspond to large distances, cold colors correspond to small distances.]]
* '''Chamfer Distance Map 3D''' computes an approximate distance map from a 3D binary image between each foreground voxel to the nearest background voxel.
* '''Keep / Remove Largest Region''' identifies the largest connected component, and keeps it or removes it.
* '''Size Opening''' computes the size (area in 2D, volume in 3D) of each connected component, and remove all particles whose size is below the value specified by the user.

Algorithms work for both 2D or 3D images. Default connectivity 4 (resp. 6) is used for 2D (resp. 3D) images.

=== Utilities for label images ===
Some functions are specific for the processing of label images, in which the pixel/voxel value is used to identify the particle it belongs to. The value 0 is assumed to correspond to the background. The number of labels that can be represented depends on the image type: 255 for byte images, 65535 for short images...
[[Image:MorphoLibJ-grains-binary-label-remove-border-largest-size-opening.png|thumb|700px|center|MorphoLibJ utilities for label images. From left to right: original label image, remove border labels, remove largest region, apply size opening for keeping only regions with at least 150 pixels.]]

* '''Remove Border Labels''' is similar to "kill borders" function, but operates faster as no morphological reconstruction is required.
* '''Select Label(s)''' enters a set of labels, and creates a new label image containing only the selected labels.
* '''Crop Label''' creates a new binary image containing only the label specified by the user. The size of the new image is fitted to the region.
* '''Replace Value''' replaces the value of a region by another value. Can be used to “clear” a label, by replacing its value by 0, or to merge to adjacent regions.
* '''Label Boundaries''' creates a new binary image containing value 255 for pixels/voxels having a neighbour with a different value.
* '''Keep / Remove Largest Label''' identifies the largest label, and keeps it or removes it.
* '''Label Size Opening''' computes the size (area in 2D, volume in 3D) of each region, and removes all labels whose size is below the value specified by the user.
* '''Assign Measure To Label''' combines a label image with a results table, and creates a new image for which each pixel/voxel is assigned the measurement value corresponding to the label it belongs to.
* '''Set Label Map''' allows to choose the color map used to display a label image. In particular, shuffling the color map and/or choosing a specific color for background allows better visualization that only grey levels.
* '''Label To RGB''' converts a label image to true RGB image. Similar to ImageJ native conversion, but this plugin avoids confusion between background pixels and regions with low labels.
[[Image:MorphoLibJ-grains-labels-assign-measure.png|thumb|480px|center|MoprphoLibJ: assign result of a measurement to a label image. In this example, the elongation is represented using a color code, between dark purple (circular) to yellow (very elongated).]]

== Library interoperability ==
A key design concept of MorphoLibJ was the modularity of the implementation to facilitate its reusability.
Three layers with different programming abstraction can be identified:
* For final users, plugins provide graphical display and intuitive tuning of parameters. Such plugins can easily be incorporated into a macro:
<source lang="java">
// Calls the Regional Min/Max plugin on current ImagePlus instance
run("Regional Min & Max", "operation=[Regional Maxima] connectivity=4");
</source>
* For plugin developers, operators are available through collections of static methods, making it possible to apply most operations with a single line of code. Example:
<source lang="java">
// Computes regional maxima using the 4-connectivity
ImageProcessor maxima = MinimaAndMaxima.regionalMaxima(image, 4);
</source>
* For core developers, algorithms are implementations of abstract interfaces, making it possible to choose or develop the most appropriate one, and to monitor execution events. For example:
<source lang="java">
// choose and setup the appropriate algorithm
RegionalExtremaAlgo algo = new RegionalExtremaByFlooding();
algo.setExtremaType(ExtremaType.MAXIMA);
algo.setConnectivity(4);
// add algorithm monitoring
algo.addAlgoListener(new DefaultAlgoListener());
// compute result on a given ImageProcessor
ImageProcessor result = algo.applyTo(image);
</source>

In total, the library provides nearly two hundred classes and interfaces.

===Library organization===
The library follows a logic structure of folders divided by topics aiming at their re-usability from other plugins or scripts, among others:
* <code>inra.ijpb.data</code> contains generic data structures for manipulating 2D or 3D images
* <code>inra.ijpb.binary</code> contains the set of utilities for working on binary images (connected component labeling, distance transform, geodesic distance transform...)
* <code>inra.ijpb.label</code> contains the utilities for label images (cropping, size opening, remove border labels, etc)
* <code>inra.ijpb.measure</code> contains the tools for geometric and grey level characterization of 2D or 3D images
* <code>inra.ijpb.morphology</code> contains the collection of mathematical morphology operators
* <code>inra.ijpb.watershed</code> contains the classes implementing the different versions of the watershed algorithm
* <code>inra.ijpb.plugins</code> contains the set of plugins that is accessible from ImageJ/Fiji Plugins menu

All major methods have a general class with '''static methods''' that allow calling the methods on 2D and 3D images in a transparent way.

=== Scripting MorphoLibJ ===
One advantage of this organization of the library and the use of public static methods is that it allows very easy and fast prototyping of morphological algorithms and pipelines.
==== Segmentation pipeline prototype====
Let's see an example in a complete [[BeanShell_Scripting|Beanshell script]] that takes the active 2D or 3D image and finds a reasonable segmentation combining a set of morphological operations (gradient, extended minima and watershed):

<source lang="java">
// @ImagePlus imp

// ImageJ imports
import ij.IJ;
import ij.ImagePlus;
import ij.ImageStack;
// MorphoLibJ imports
import inra.ijpb.binary.BinaryImages;
import inra.ijpb.morphology.MinimaAndMaxima3D;
import inra.ijpb.morphology.Morphology;
import inra.ijpb.morphology.Strel3D;
import inra.ijpb.watershed.Watershed;
 
// create structuring element (cube of radius 1)
strel = Strel3D.Shape.CUBE.fromRadius( 1 );
// apply morphological gradient to input image
image = Morphology.gradient( imp.getImageStack(), strel );
// find regional minima on gradient image with dynamic value of 30 and 6-connectivity
regionalMinima = MinimaAndMaxima3D.extendedMinima( image, 30, 6 );
// impose minima on gradient image
imposedMinima = MinimaAndMaxima3D.imposeMinima( image, regionalMinima, 6 );
// label minima using connected components (32-bit output)
labeledMinima = BinaryImages.componentsLabeling( regionalMinima, 6, 32 );
// apply marker-based watershed using the labeled minima on the minima-imposed 
// gradient image (the "true" value indicates the use of dams in the output)
resultStack = Watershed.computeWatershed( imposedMinima, labeledMinima, 6, true );
 
// create image with watershed result
resultImage = new ImagePlus( "watershed", resultStack );
// assign right calibration
resultImage.setCalibration( imp.getCalibration() );
// and show it
resultImage.show();

</source>
==== Label visualization in 3D viewer ====
Making use of MorphoLibJ's label methods and the [[3D_Viewer|ImageJ 3D Viewer]]'s visualization tools it is quite simple to create a script to display each label of an image as 3D surfaces of the corresponding colors provided by the image look-up table:

<source lang="java">
// @ImagePlus imp

import inra.ijpb.label.LabelImages;
import ij3d.Image3DUniverse;
import ij3d.ContentConstants;
import org.scijava.vecmath.Color3f;
import ij.IJ;
import isosurface.SmoothControl;

// set to true to display messages in log window
verbose = false;

// set display range to 0-255 so the displayed colors
// correspond to the LUT values
imp.setDisplayRange( 0, 255 );
imp.updateAndDraw();

// calculate array of all labels in image
labels = LabelImages.findAllLabels( imp );

// create 3d universe
univ = new Image3DUniverse();
univ.show();

// read LUT from input image
lut = imp.getLuts()[0];

// add all labels different from zero (background)
// to 3d universe
for( i=0; i<labels.length; i++ )
{	
	if( labels[ i ] > 0 )
	{
		labelToKeep = new int[ 1 ];
		labelToKeep[ 0 ] = labels[ i ];
		if( verbose )
			IJ.log( "Reconstructing label " + labels[ i ] + "..." );
		// create new image containing only that label
		labelImp = LabelImages.keepLabels( imp, labelToKeep );
		// convert image to 8-bit
		IJ.run( labelImp, "8-bit", "" );
		
		// use LUT label color
		color = new Color3f( new java.awt.Color( lut.getRed( labels[ i ] ),
			lut.getGreen( labels[ i ] ),
			lut.getBlue( labels[ i ] ) ) );
			
		if ( verbose )
			IJ.log( "RGB( " + lut.getRed( labels[ i ] ) +", " 
				+ lut.getGreen( labels[ i ] )
				+ ", " + lut.getBlue( labels[ i ] ) + ")" );

		channels = new boolean[3];
		channels[ 0 ] = false;
		channels[ 1 ] = false;
		channels[ 2 ] = false;
		
		// add label image with corresponding color as an isosurface
		univ.addContent( labelImp, color, "label-"+labels[i], 0, channels, 2, ContentConstants.SURFACE);
	}
}

// launch smooth control
sc = new SmoothControl( univ );
</source>
At the end of the script a dialog is shown to smooth the surfaces at will. Each label is added to the 3D scene independently with the nanme "label-X" where X is its label value.
[[Image:MorphoLibJ-visualize-labels-in-3d-viewer.png|thumb|center|750px|From left to right: input label image, script output, smoothed label surfaces and example of individually translated surfaces in the 3D viewer.]]

== Documentation ==
Each [https://github.com/ijpb/MorphoLibJ/releases released version of MorphoLibJ] comes with a [https://github.com/ijpb/MorphoLibJ/releases/download/v1.1.1/MorphoLibJ-manual-v1.1.1.pdf User Manual in PDF format].

The main source code directory is on GitHub under [http://github.com/ijpb/MorphoLibJ/tree/master/src/main/java/inra/ijpb src/main/java/inra/ijpb].

You can browse the [http://ijpb.github.io/MorphoLibJ/javadoc/ javadoc] for more information about its API.

== Installation ==

* In ImageJ, download the [https://github.com/ijpb/MorphoLibJ/releases latest released jar] into the ''plugins'' folder.

* In Fiji, you just need to [[How_to_follow_a_3rd_party_update_site#Add_update_sites | add]] the IJPB-plugins site to your list of update sites:

::: 1) Select {{bc | Help | Update...}} from the Fiji menu to start the updater.

::: 2) Click on ''Manage update sites''. This brings up a dialog where you can activate additional update sites.

::: 3) Activate the IJPB-plugins update site and close the dialog. Now you should see an additional jar file for download.

::: 4) Click ''Apply changes'' and restart Fiji.
== License ==
This program is '''free software'''; you can redistribute it and/or modify it under the terms of the '''GNU General Public License''' as published by the Free Software Foundation ([http://www.gnu.org/licenses/gpl.txt http://www.gnu.org/licenses/gpl.txt]).

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. 

[[Category:Analysis]]
[[Category:Filtering]]
[[Category:Segmentation]]
[[Category:Mathematical_morphology]]
