= Morphological operations in Imglib2. =

The presentation of what are morphological operations is left to [http://en.wikipedia.org/wiki/Mathematical_morphology Wikipedia].



== Package content and location. ==

This Imglib2 package ships only (yet) the basic morphological operations:
* erosion
* dilation
* opening 
* closing
These 4 operations are implemented for arbitrary dimensionalities (2D, 3D, 4D, etc...). The package reuses standard Imglib2 interfaces and classes. It also conforms to the public static methods accessors for low level algorithms, as the [https://github.com/imglib/imglib2-algorithm/tree/master/src/main/java/net/imglib2/algorithm/gauss3 gauss3] package does.
Apart from this, it is strongly inspired by the morphological operation methods in the Image Processing Toolbox of the [http://fr.mathworks.com/help/images/morphological-filtering.html MATLAB] software.

It also ships facilities to generate structuring elements, and allows the use of decomposed structuring elements for performance optimization. This part is documented below.

Classes can be found in the <code>[https://github.com/imglib/imglib2-algorithm/tree/master/src/main/java/net/imglib2/algorithm/morphology net.imglib2.algorithm.morphology]</code> package of the [https://github.com/imglib/imglib2-algorithm imglib2-algorithm library].



== Gray morphology and flat structuring elements. ==

This set of methods does ''gray morphology''. It applies to source images that can be of any scalar numerical type (8-bit, 12-bit, 16-bit, booleans, floats, signed or unsigned, ...), not only black and white images. 

It actually applies to more than this: The type of the source image only needs to extend <code>Type</code> (the Imglib2 mother interface for values) and <code>Comparable</code>  (the java interface for objects than can be compared to others). This is detailed later. 

However, we use the Imglib2 [https://github.com/imglib/imglib2-algorithm/blob/master/src/main/java/net/imglib2/algorithm/region/localneighborhood/Shape.java Shape interface] for structuring elements. This restricts structuring elements to ''flat'' structuring elements, which do not have a weight, or value, associated to each location. This prevents us from developing a ''stricto sensu'' rolling-ball background subtraction algorithm based on this package (but a rolling-disk version is possible).



== Morphological operations on <code>Comparable</code> type. ==

Morphological operations are defined on types that have very little requirement. The data does not have to be made of numerical pixels at all. Mathematically, they are defined on partially ordered sets (complete lattices, see for instance [http://en.wikipedia.org/wiki/Dilation_(morphology)#Dilation_on_complete_lattices ''Dilation on complete lattices'']).

In Imglib2, we require a little bit more than that. The data type you can use with morphological operations needs to be comparable. In practice, it must extends <code>Type</code> and <code>Comparable</code>: <code>T extends Type< T > & Comparable< T ></code>. With this, it is perfectly possible to dilate an image of strings by a 3x3 square strel:

Before:
<pre>Upcycle       Sexting       Unfriend      Droolworthy   Noob          Muggle        
Woot          Po-po         Purple State  Guyliner      Screenager    Crunk         
Obvs          Mankini       Locavore      Bling         Textspeak     Muffin Top    
Infomania     Grrrl         Truthiness    Bromance      D'oh          Twitterati    
La-la Land    Whatevs       Illiterati    OMG           Hater         Jeggings      
Jean-Yves     Mini-Me       Chillax       Frankenfood   Totes         Whovian       </pre>


After full dilation:
<pre>Upcycle       Upcycle       Upcycle       Unfriend      Unfriend      Noob          Noob          Muggle        
Woot          Woot          Woot          Unfriend      Unfriend      Screenager    Screenager    Muggle        
Woot          Woot          Woot          Unfriend      Unfriend      Textspeak     Textspeak     Muggle        
Woot          Woot          Woot          Truthiness    Truthiness    Twitterati    Twitterati    Twitterati    
Obvs          Whatevs       Whatevs       Whatevs       Truthiness    Twitterati    Twitterati    Twitterati    
La-la Land    Whatevs       Whatevs       Whatevs       Truthiness    Whovian       Whovian       Whovian       
La-la Land    Whatevs       Whatevs       Whatevs       Totes         Whovian       Whovian       Whovian       
Jean-Yves     Mini-Me       Mini-Me       Mini-Me       Totes         Whovian       Whovian       Whovian       </pre>


After standard dilation:<ref>These are the 35 words added by the Oxford Online Dictionary during summer 2012. And another one.</ref>
<pre>Woot          Woot          Unfriend      Unfriend      Screenager    Screenager    
Woot          Woot          Unfriend      Unfriend      Textspeak     Textspeak     
Woot          Woot          Truthiness    Truthiness    Twitterati    Twitterati    
Whatevs       Whatevs       Whatevs       Truthiness    Twitterati    Twitterati    
Whatevs       Whatevs       Whatevs       Truthiness    Whovian       Whovian       
Whatevs       Whatevs       Whatevs       Totes         Whovian       Whovian       </pre>




= Usage. =


The 4 basic operations are accessed through 4 classes:
* [https://github.com/tinevez/imglib2-algorithm/blob/morphology/src/main/java/net/imglib2/algorithm/morphology/Dilation.java net.imglib2.algorithm.morphology.Dilation]
* [https://github.com/tinevez/imglib2-algorithm/blob/morphology/src/main/java/net/imglib2/algorithm/morphology/Erosion.java net.imglib2.algorithm.morphology.Erosion]
* [https://github.com/tinevez/imglib2-algorithm/blob/morphology/src/main/java/net/imglib2/algorithm/morphology/Opening.java net.imglib2.algorithm.morphology.Opening]
* [https://github.com/tinevez/imglib2-algorithm/blob/morphology/src/main/java/net/imglib2/algorithm/morphology/Closing.java net.imglib2.algorithm.morphology.Closing]


Each of these classes contains only static methods that performs the desired operation. There can be up to 16 flavors of the same operation. They exist to cover all cases, which fall in 4 categories:

* You want to operate on an [https://github.com/imglib/imglib2/blob/master/src/main/java/net/imglib2/img/Img.java Img] and return a '''new Img''' with the results. Then you need to call for instance:
<source lang="java">
Img< FloatType > result = Dilation.dilate( img, strel, 1 );
</source>
[[File:DilatedToNewImgExample.png|600px]]

* You want to perform to '''full''' dilation or erosion on a source Img. Full version of these operations means the new image will have a size increased or shrunk as if the structuring element would actually dilate or erode the source border:
<source lang="java">
Img< FloatType > result = Dilation.dilateFull( img, strel, 1 );
</source>
[[File:DilatedToNewFullImgExample.png|600px]]


* You want to operate on a source [https://github.com/imglib/imglib2/blob/master/src/main/java/net/imglib2/RandomAccessibleInterval.java RandomAccessibleInterval], in place (write the results in the source):
<source lang="java">
Dilation.dilateInPlace( rai, interval, strel, 1 );
</source>
[[File:DilatedInPlaceExample.png|600px]]


* You want to operate on a source [https://github.com/imglib/imglib2/blob/master/src/main/java/net/imglib2/RandomAccessible.java RandomAccessible], and write the results in a provided [https://github.com/imglib/imglib2/blob/master/src/main/java/net/imglib2/IterableInterval.java IterableInterval]:
<source lang="java">
Dilation.dilate( source, target, strel, 1 )
</source>
[[File:DilatedToTargetExample.png|600px]]


Now, each of these category are declined in 4 specifics methods:

* Depending on the source type: 

** If the source type inherits from [https://github.com/imglib/imglib2/blob/master/src/main/java/net/imglib2/type/numeric/RealType.java RealType] - which is the case for most numeric types and all the native types - then you can use directly the above methods without any extras.

** But you may have a source which might be <code>T extends Comparable & Type</code>. Then you have to provided the maximal value or the minimal value or both for this type. Then you have to call the methods whose signature are like:
<source lang="java">
public static < T extends Type< T > & Comparable< T > > Img< T > dilate( final Img< T > source, final Shape strel, final T minVal, final int numThreads )
</source>

* Depending on whether you have the structuring element as a single Shape or decomposed in a list of Shape, there is a version of all those methods for this case or the other. 





= Structuring elements. =

This chapter documents and details implemented structuring elements, their decomposition and how do they perform in time.



== Rectangular structuring element. ==


=== Decomposition. ===

A rectangle can be decomposed in a series of orthogonal lines, in any dimensions, considerably diminishing the number of pixels to iterate. 


==== 2D case. ====

If the image has <code>M</code> pixels, and that the rectangle is a square of side 
<code>R</code>, then the non-optimized case should have a processing time proportional to <code>M × R²</code>. The optimized case replace iterating over the square by iterating twice over a line of length <code>R</code>. Therefore its processing time should be proportional to <code> 2 × M × R</code>. 

The performance improvement should therefore be equal to <code>R / 2</code>. A linear fit of the actual curve rather shows that the law is <code> 0.73 × R + 0.37</code>. This extra benefit - I don't why it's there. 

<gallery heights="300" widths="300" mode="packed-hover">
File:RectangleStrel2DPerformance.png|Processing time for the dilation of a 100x100 image.
File:RectangleStrel2DPerformanceComparison.png|Processing time ratio.
</gallery>


==== 3D case. ====

Here the standard case takes a time proportional to <code>M × R³</code>, and the optimized case a time proportional to <code> 3 × M × R</code>. Therefore the performance ratio should be  <code>R² / 3</code>. A fit shows that this ratio follows <code>0.63 × R² + 0.57 × R + 0.48</code>.

<gallery heights="300" widths="300" mode="packed-hover">
File:RectangleStrel3DPerformance.png|Processing time for the dilation of a 40x40x40 image.
File:RectangleStrel3DPerformanceComparison.png|Processing time ratio.
</gallery>



== Square structuring element ==


=== Decomposition. ===

The square is just a special case of the rectangle, implemented for convenience. It has the same decomposition principle. And similar conclusions can be reached: 


==== 2D case. ====

<gallery heights="300" widths="300" mode="packed-hover">
File:SquareStrel2DPerformance.png|Processing time for the dilation of a 100x100 image.
File:SquareStrel2DPerformanceComparison.png|Processing time ratio.
File:SquareStrel2DPerformanceWMATLAB.png|First image zoomed to highlight MATLAB performance.
</gallery>


==== 3D case. ====

<gallery heights="300" widths="300" mode="packed-hover">
File:SquareStrel3DPerformance.png|Processing time for the dilation of a 49x49x49 image.
File:SquareStrel3DPerformanceComparison.png|Processing time ratio.
File:SquareStrel3DPerformanceWMATLAB.png|First image zoomed to highlight MATLAB performance.
</gallery>



== Diamond structuring element ==

=== Shape ===

A diamond strel has the following shape in 2D, for instance with a radius of 3 (It extends over 7 pixels wide):
<pre>┌───────┐
│   █   │
│  ███  │
│ █████ │
│███████│
│ █████ │
│  ███  │
│   █   │
└───────┘</pre>

And in 3D:
<pre>Z = 0:    Z = 1:    Z = 2:    Z = 3:    Z = 4:    Z = 5:    Z = 6:    
┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐ ┌───────┐ 
│       │ │       │ │       │ │   █   │ │       │ │       │ │       │ 
│       │ │       │ │   █   │ │  ███  │ │   █   │ │       │ │       │ 
│       │ │   █   │ │  ███  │ │ █████ │ │  ███  │ │   █   │ │       │ 
│   █   │ │  ███  │ │ █████ │ │███████│ │ █████ │ │  ███  │ │   █   │ 
│       │ │   █   │ │  ███  │ │ █████ │ │  ███  │ │   █   │ │       │ 
│       │ │       │ │   █   │ │  ███  │ │   █   │ │       │ │       │ 
│       │ │       │ │       │ │   █   │ │       │ │       │ │       │ 
└───────┘ └───────┘ └───────┘ └───────┘ └───────┘ └───────┘ └───────┘ </pre>

It is the crudest approximation of a sphere.


=== Decomposition. ===

The diamond strel can be effectively decomposed in 2D (and 1D) using the logarithmic decomposition in extreme sets, as explained in <ref name="BoomgardVanBalen">Rein van den Boomgard and Richard van Balen, [http://www.sciencedirect.com/science/article/pii/1049965292900553.htm Methods for Fast Morphological Image Transforms Using Bitmapped Binary Images], CVGIP: Models and Image Processing, vol. 54, no. 3, May 1992, pp. 252-254.</ref>. The shape is then decomposed in a minimal series of smaller diamond and diamond tips. The decomposition is exact, giving the same result that of the non-decomposed version. 

In 3D and higher dimensionalities, the logarithmic decomposition cannot be done, and we rely on a more classical linear decomposition (also well explained in <ref name="BoomgardVanBalen"/>). Here is a comparison on how the decomposed version performs versus the non-decomposed one.


==== 2D performance ====

<gallery heights="300" widths="300" mode="packed-hover">
File:DiamondStrel2DPerformance.png|Processing time for the dilation of a 100x100 image.
File:DiamondStrel2DPerformanceComparison.png|Processing time ratio.
</gallery>

It is worth using a decomposition above a radius of 4.


==== 3D performance. ====


<gallery heights="300" widths="300" mode="packed-hover">
File:DiamondStrel3DPerformance.png|Processing time for the dilation of a 40x40x40 image.
File:DiamondStrel3DPerformanceComparison.png|Processing time ratio.
</gallery>

It is worth using a decomposition in almost any cases.


==== Comparison with MATLAB. ====

MATLAB comes with a very nice morphology package. I actually took inspiration from to it to write the Imglib2 code. It is tempting to compare the performance of MATLAB vs Imglib2, even if this kind of comparison is always tricky and clumsy. Anyway, here it is. I just timed the duration required to perform the dilation of a provided source image, including the time required to generate the structuring element. Imglib2 tests above time the same process. But of course, the time required to generate the source image and to start MATLAB or to launch the Java tests are not included. I took care to include a 'warm-up' run to allow the JIT compiler to kick-in in all cases.

<gallery heights="300" widths="300" mode="packed-hover">
File:DiamondStrel2DPerformanceWMATLAB.png|Processing time for the dilation of a 100x100 image.
File:DiamondStrel3DPerformanceWMATLAB.png|Processing time for the dilation of a 40x40x40 image.
</gallery>

For the 2D case (only), MATLAB offers to generate optimized structuring elements, like for this Imglib2 code. This is why there is two MATLAB curves on the 2D graph. We can see that in all cases, the MATLAB code is faster than the Imglib2 code (respective to optimized vs optimized and the converse).  This may be explained by the fact that MATLAB benefitiates on my computer (a 2012 MacPro) from the Intel Integrated Performance Primitives ([http://software.intel.com/en-us/intel-ipp IPP]), that strongly improves block processing algorithms. Fortunately, the difference is not too taxing in the optimized case.

In 3D, MATLAB does not offer a structuring element decomposition (yet). So the performance curve as the expected cubic shape, though it outperforms Imglib2 in the non-optimized case. For large radius, the Imglib2 optimization manages to beat it.



== Disk structuring element. ==

=== 2D Decomposition in periodic lines. ===

In the 2D case, a disk structuring element can be decomposed in a succession of 4, 6 or 8 periodic lines<ref name="RolfAdams">Rolf Adams, [http://www.sciencedirect.com/science/article/pii/S1049965283710242 Radial Decomposition of Discs and Spheres], CVGIP: Graphical Models and Image Processing, vol. 55, no. 5, September 1993, pp. 325-332.</ref>. Doing so, the shape of the disk is only an approximate one. The first plot below indicates the percentage of pixels that are a mismatch compared to the "true" disk (by "true" I mean as best as digitizing a disk on a square matrix can be). In practice, this plot is rather uninformative. The second plot gives the effective aspect of the decomposed disks:

<gallery heights="300" widths="300" mode="packed-hover">
File:DiskDecompError.png|Error percentage when approximating a disk STREL with a PL decomposition.
File:DiskDecompErrorLook.png|Aspect of the disk STREL decomposition in periodic lines, with varying radius.
</gallery>

As for performance, you can see below that it is always best to use any decomposition as soon as the radius is larger than 3. This is a lucky limit, because the periodic line decomposition gives very approximated shapes for small radii.

<gallery heights="300" widths="300" mode="packed-hover">
File:DiskDecompPerformance.png|Processing time for the dilation of a 100x100 image.
File:DiskDecompPerformanceComparison.png|Processing time ratio.
</gallery>


=== Decomposition for other dimensionalities. ===

I am unable to derive an efficient decomposition of the disk STREL for the 3D case. Also, I was unable so far to find an implementation example or clear literature about such a decomposition. The closest I reach was this [http://ismm.dpi.inpe.br/col/dpi.inpe.br/ismm@80/2007/03.20.04.48/doc/ISMM2007fullpaper/fullpaper.pdf publication] that describes a possible method (proposed in [http://dsp.stackexchange.com/questions/12675/decomposition-of-3d-structuring-elements-for-morphological-operations this DSP thread]) but it missed the implementation details that could make it practical.

= References and links. =

<references/>



[[User:JeanYvesTinevez|JeanYvesTinevez]] ([[User talk:JeanYvesTinevez|talk]])
