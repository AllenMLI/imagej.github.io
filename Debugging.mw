= Switching on ImageJ's debug mode =

ImageJ itself outputs a lot of debug messages, when asked for them: Simply check ''Debug mode'' in the dialog popping up when clicking on the ''Edit>Options>Misc...'' menu item.

= Monitoring system calls =

== Linux ==

On Linux, you should call Fiji using the [http://www.linuxmanpages.com/man1/strace.1.php strace command]:

<source lang="bash">
strace -Ffo syscall.log ./fiji <args>
</source>

== MacOSX ==

Use the ''dtruss'' wrapper around [http://developer.apple.com/documentation/Darwin/Reference/ManPages/man1/dtrace.1.html dtrace] to monitor system calls:

<source lang="bash">
dtruss ./fiji <args>
</source>

== Windows ==

To monitor all kinds of aspects of processes on Windows, use [http://technet.microsoft.com/en-us/sysinternals/bb896645.aspx Sysinternal's Process Monitor].

= Debugging JVM hangs =

When the Java VM hangs, the reason might be a dead-lock. You can often find out what is happening by reading the thread dump which you can get via ''Ctrl+\'' in the console where you started Fiji. On Linux and MacOSX, you can also send the signal ''3'' via the ''kill'' command.

You can also attach to the JVM using the ''jvisualvm'' program that you can find in ''java/<platform>/<jdk>/bin/''.

= Debugging hard JVM crashes =

When you have found an issue that crashes the JVM, and you can repeat that crash reliably, there are a number of options to find out what is going on.

== Using gdb ==

Typically when you debug a program that crashes, you start it in a debugger, to inspect the stack trace and the variables at the time of the crash. However, there are substantial problems with gdb when starting the Java VM; either gdb gets confused by segmentation faults (used by the JVM to handle NullPointerExceptions in an efficient manner), or it gets confused by the threading system -- unless you compile gdb yourself.

But there is a very easy method to use gdb to inspect serious errors such as segmentation faults or trap signals nevertheless:

<source lang="bash">
./fiji -XX:OnError="gdb - %p" --
</source>

== Using the ''hs_err_pid<pid>.log'' files ==

The Java virtual machine (JVM) frequently leaves files of the format ''hs_err_pid<number>.log'' in the current working directory after a crash. Such a file starts with a preamble similar to this:

<pre>
#
# A fatal error has been detected by the Java Runtime Environment:
#
#  SIGSEGV (0xb) at pc=0x00007f3dc887dd8b, pid=12116, tid=139899447723792
#
# JRE version: 6.0_20-b02
# Java VM: Java HotSpot(TM) 64-Bit Server VM (16.3-b01 mixed mode linux-amd64 )
# Problematic frame:
# C  [libc.so.6+0x86d8b]  memcpy+0x15b
#
# If you would like to submit a bug report, please visit:
#   http://java.sun.com/webapps/bugreport/crash.jsp
# The crash happened outside the Java Virtual Machine in native code.
# See problematic frame for where to report the bug.
#
</pre>

followed by thread dumps and other useful information including the command-line arguments passed to the JVM.

The most important part is the line after the line ''# Problematic frame:'' because it usually gives you an idea in which component the crash was triggered.

= Debugging Java code with jdb =
== How to attach the Java debugger jdb to a running fiji process ==
This requires two separate processes, fiji itself and the debugger.  You can do this either in one shell, backgrounding the first process or in two shells, this is recommended.  In the two shells do the following:

;Shell 1
:In the first shell, start fiji with special parameters to open a port (8000 in this case) to which jdb can connect afterwards:
<source lang="bash">
./fiji -Xdebug -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=y --</source>
:(Tested with Java 1.5.0, ymmv)
;Shell 2
:In the second shell, tell jdb to attach to that port:
<source lang="bash">
jdb -attach 8000
</source>

== This is an ultra quick start to jdb, the default Java debugger ==

Hopefully you are a little familiar with gdb, since jdb resembles it lightly.

Notable differences:
* a breakpoint is set with "stop in <class>.<method>" or "<class>:<line>".  Just remember that the class must be fully specified, i.e. <package>.<subpackages...>.<classname>
* no tab completion
* no readline (cursor up/down)
* no shortcuts; you have to write "run", not "r" to run the program
* no listing files before the class was loaded
* much easier method to specify the location of the source: "use <dir>"
* "until" is "step", "step" is "stepi"

Okay, so here you go, a little demonstration:

(If you attach jdb to a running fiji process, you have to use the line from the previous section instead.)

 $ jdb -classpath ij.jar ij.ImageJ
 > stop in ij.ImageJ.main
 Deferring breakpoint ij.ImageJ.main.
 It will be set after the class is loaded.
 > run
 run ij.ImageJ
 Set uncaught java.lang.Throwable
 Set deferred uncaught java.lang.Throwable
 >
 VM Started: Set deferred breakpoint ij.ImageJ.main
 
 Breakpoint hit: "thread=main", ij.ImageJ.main(), line=466 bci=0
 
 main[1] use .
 main[1] list
 462             //prefs.put(IJ_HEIGHT, Integer.toString(size.height));
 463     }
 464
 465     public static void main(String args[]) {
 466 =>          if (System.getProperty("java.version").substring(0,3).compareTo("1.4")<0) {
 467                     javax.swing.JOptionPane.showMessageDialog(null,"ImageJ "+VERSION+" requires Java 1.4.1 or later.");
 468                     System.exit(0);
 469             }
 470             boolean noGUI = false;
 471             arguments = args;
 main[1] print args[0]
 java.lang.IndexOutOfBoundsException: Invalid array range: 0 to 0
  args[0] = null
 main[1] print args.length
  args.length = 0
 main[1] step
 >
 Step completed: "thread=main", ij.ImageJ.main(), line=470 bci=28
 470             boolean noGUI = false;
 
 main[1] step
 >
 Step completed: "thread=main", ij.ImageJ.main(), line=471 bci=30
 471             arguments = args;
 
 main[1] set noGUI = true
  noGUI = true = true
 main[1] cont
 >
 The application exited

= Inspecting serialized objects =

If you have a file with a serialized object, you can use this Beanshell in the [[Script Editor]] to open a tree view of the object (double-click to open/close the branches of the view):

<source lang="java">
import fiji.debugging.Object_Inspector;

import ij.io.OpenDialog;

import java.io.FileInputStream;
import java.io.ObjectInputStream;

dialog = new OpenDialog("Classifier", null);
if (dialog.getDirectory() != null) {
	path = dialog.getDirectory() + "/" + dialog.getFileName();
	in = new FileInputStream(path);
	in = new ObjectInputStream(in);
	object = in.readObject();
	in.close();
	Object_Inspector.openFrame("classifier", object);
}
</source>

= Debugging Java3D issues =

When Java3D does not work, the first order of business is to use ''Plugins>Utilities>Debugging>Test Java3D''. If this shows a rotating cube, but the [[3D Viewer]] does not work, please click on ''Help>Java3D
Properties...'' in the [[3D Viewer]]'s menu bar.

== Command line debugging ==

If this information is not enough to solve the trouble, or if ''Test Java3D'' did not work, then you need to call Fiji from the command line to find out more.

From the command line, you have several options to show more or less information about Java3D.

=== Windows ===
On Windows, you <u>must</u> pass the ''--console'' option in any case. Example:

<source lang="bash">
cd Desktop\Fiji.app
fiji-win32 --console
</source>

'''Note:''' you may have unpacked Fiji somewhere else than the Desktop. If so, you have to use a different ''cd'' call.
'''And note, too:''' on Windows 64, the executable is called ''fiji-win64'', of course.

=== MacOSX ===
On MacOSX, you need to remember that any application is just a directory with a special layout. So you can call Fiji like this from the ''Terminal'' (which you will find in the Finder by clicking on ''Go>Utilities''. Example command line:

<source lang="bash">
cd /Applications/Fiji.app
Contents/MacOS/fiji-macosx
</source>

'''Note:''' on Tiger, you need to call ''fiji-tiger'' instead of ''fiji-macosx''.

=== Linux ===

As you might have guessed, on Linux it is a simple matter of

<source lang="bash">
cd /path/to/Fiji.app
./fiji-linux
</source>

'''Note:''' on 64-bit Linux, the executable is called ''fiji-linux64'' instead.

== Show Java3D debug messages ==

<source lang="bash">
./fiji -Dj3d.debug=true --
</source>

(Of course, you need to substitute the ''./fiji'' executable name with the appropriate name for your platform.)

'''Note:''' do not forget the trailing ''--''; without them, Fiji mistakes the first option for an ImageJ option rather than a Java one.
'''Note, too:''' on Windows, you <u>must not</u> forget to pass the ''--console'' option (this can be anywhere on the command line).

== Windows-specific stuff ==

On Windows, you can choose between OpenGL and Direct3D by passing ''-Dj3d.rend=ogl'' or ''-Dj3d.rend=d3d'', respectively.

Further, some setups require enough RAM to be reserved, so you might need to pass an option like ''--mem=1200m'' (make sure that you have enough RAM free before starting Fiji that way, though!). If it turns out that memory was the issue, you can make the setting permanent by clicking Fiji's ''Edit>Options>Memory & Threads...'' menu entry.

== More Java 3D properties ==

You can control quite a few things in Java 3D through setting Java properties. Remember, you can set properties using a command line like this:

<source lang="bash">
./fiji -D<property-name>=<property-value> --
</source>

where you substitute ''<property-name>'' and ''<property-values>'' appropriately. You can have more than one such option, but make sure that they are appearing before the ''--'' on the command line, otherwise Fiji will mistake them for ImageJ options.

This list of Java 3D properties was salvaged from the now-defunct j3d.org website:

{|
! Property
! Values
! Java 3D version
! Explanation
|-
|j3d.rend
|"ogl" or "d3d"
|1.3.2
|Win32-only. Specifies which underlying rendering API should be used (thus allowing both Direct3D and OpenGL native DLLs to be installed on a singe machine. (default value "ogl")
|-
|j3d.deviceSampleTime
|A time in millseconds
|1.1
|The sample time for non-blocking input devices (default value is 5ms).
|-
|j3d.disablecompile
|N/A
|1.2
|If set turns off the ability to internally .compile() the scenegraph.
|-
|j3d.docompaction
|true or false
|1.3
|Default true. Controls whether or not objects are removed from the render cache when they haven't been visibile for a while. If it is disabled, they stay in the render cache from when they are first visible until they are removed from the scene graph.
|-
|j3d.forceReleaseView
|true or false
|1.3.2
|Default false. If this flag is set to true, the view is released after the Canvas3D is removed from the view. Can be used if you have memory leaks after disposing Canvas3D. Note: Setting this flag as true disables the bug fix 4267395 in View deactivate()
|-
|j3d.implicitAntialiasing
|true or false
|1.3
|Default false. By default, full scene antialiasing is disabled if a multisampling pixel format (or visual) is chosen. To honor a display drivers multisample antialiasing setting (e.g. force scene antialiasing), set the implicitAntialiasing property to true. This causes Java3D to ignore its own scene antialias settings, letting the driver implicitly implement the feature
|-
|j3d.optimizeForSpace
|true or false
|1.3
|Default true Java3d only builds display list for by-copy geometry. Set to false will cause Java3d to build display list for by-ref geometry and infrequently changing geometry using more space, but having greater speed.
|-
|j3d.renderLock
|true or false
|1.3
|JDK requires getting the JAWT_DrawingSurfaceInfo and lock the surface before Java3D render on the canvas. (see comment on jdk/include/jawt.h in the SDK) Default false causes Java3D to lock the surface before rendering and unlock it afterwards for onScreen rendering in the Renderer thread. For OffScreen rendering and for front/back buffer swapping the lock will not acquired. Setting the value to true will force Java3D lock the surface using the AWT mechanism before swap() and for offScreen rendering. This may be useful for some driver/OS to workaround problem. But in general the default should work.
|-
|j3d.threadLimit
|An integer
|1.2
|Controls how many threads may run in parallel regardless of how many cpu's the system has. Setting it to "1" will make the system act like a traditional OpenGL render loop. The default value is the number of CPUs in your machine + 1.
|-
|j3d.transparentOffScreen
|true or false
|1.3.2
|Default false. If this flag is set to true the background of the off screen canvas is set to transparent.
|-
|j3d.usePbuffer
|true or false
|1.3.2
|Default true. If this flag is set to false pbuffer will not be use for off screen rendering.
|-
|j3d.viewFrustumCulling
|true or false
|1.3.2
|Default true. If this flag is set to false, the renderer view frustum culling is turned off. Java 3D uses a 2 pass view culling. The first pass is a loose view culling of the spatial tree, and the second pass is a tight view frustum culling in the renderer before sending the geometry down to the low level graphics API. This property is to control the renderer view frustum culling, and it will not affect the first pass view culling.
|-
|javax.media.j3d.compileStats
|N/A
|??
|Output scenegraph compilation statistics
|-
|javax.media.j3d.compileVerbose
|N/A
|??
|Output verbose message when compiling scenegraph
|-
!colspan=4|<br/>OpenGL Only
|-
|j3d.backgroundtexture
|true or false
|1.3
|Prior to Java3D 1.3 OGL version of Java3D used glDrawPixels() to render background, which is known to be very slow under Windows since most window driver did not accelerate the function. To workaround this performance problem current release uses textures for the backgrond under windows by default (glDrawPixels() is used as default under Solaris). Setting this flag to false will force Java3D fall back to use glDrawPixels() instead of texture when drawing background texture in case it provide better performance under some drivers.
|-
|j3d.disableSeparateSpecular
|true or false
|1.2
|Default true enables the use of specular highlights in textures when using OpenGL 1.2.
|-
|j3d.disableXinerama
|true or false
|1.3
|Solaris version only. Allows major performance boost when using dual screen environments with the X11 Xinerama extension enabled. To disable this feature you need JDK1.4. Detailed information in the release notes.
|-
|j3d.displaylist
|true or false
|1.2
|Default true to use display lists (an OpenGL performance enhancing feature). False to disable for debugging.
|-
|j3d.g2ddrawpixel
|true or false
|1.1
|If false, this will use texture mapping instead of glDrawPixel to flush the graphics2D to the screen. glDrawPixel is not accelerated on some older video cards (windows).
|-
|j3d.sharedctx
|true or false
|1.2
|Default true for Solaris and false for windows. Shared contexts are used in OpenGL for DisplayLists and Texture Objects to improve performance. However some drivers have bugs causing weird rendering artifacts. This can be used to disable their use to see if this is the problem.
|-
|j3d.sharedstereozbuffer
|true or false
|1.2
|Some framebuffers only have one Z buffer and share this between the left and right eyes. This may be the reason why they don't have quad buffer but can still support stereo by setting this flag to true.
|-
|j3d.usecombiners
|true or false
|1.3
|Default false, uses the standard OpenGL all environment options. When set to true, it will make use of the Nvidia register combiner extensions to OpenGL for for Texture combine modes such as COMBINE_INTERPOLATE, COMBINE_DOT3. (ie GL_NV_register_combiners instead of standard OpenGL call glTexEnvi(GL_TEXTURE_ENV, ...)). It can be use in case like Dot3 texture when the driver does not support OpenGL extension GL_ARB_texture_env_dot3/GL_EXT_texture_env_dot3 but it supports the GL_NV_register_combiners extension instead.
|-
!colspan="4"|<br/>DirectX only
|-
|j3d.d3ddevice
|"emulation" or "hardware" or "tnlhardware" or "reference"
|1.2
|Forces the software to use a particular mode for the underlying graphics accelaration. The reference option is only available if you have the Direct3D SDK installed (very unlikely).
|-
|j3d.d3ddriver
|idx
|1.2
|For cards like Voodoo that run fullscreen 3D only. idx is the order DirectX enumerates its driver using DirectDrawEnumerateEx(). This number starts at 1. This will force Java3D to use the driver specified by the user (may fail if the driver is not compatible with display). The driver number and details can be found by using the j3d.debug property. For a typical setup of a 3D only card attach to a graphics card in a single monitor system, use idx=2. This will automatically toggle to fullscreen hardware accelerated mode since if the 3D card support 3D only.
|-
|j3d.debug
|true or false
|1.1
|Prints out startup and running information. Useful for finding out information about the underlying hardware setup.
|-
|j3d.fullscreen
|PREFERRED or REQUIRED or UNNECESSARY
|1.2
|Option to force Java3D to run in fullscreen mode for video cards that will only use hardware accelaration when using fullscreen (non-windowed) mode, like the older Voodoo series.
|-
|j3d.vertexbuffer
|true or false
|1.2
|false to turn off the use of vertex buffers (a D3D performance enhancing feature equivalent to OpenGL display lists). Some drivers have implementation problems so it might be worth turning this off if you get crashes.
Utility Classes
|-
|j3d.audiodevice
|A quote string containing a class name
|1.3.2
|SimpleUniverse utility classes. Takes the name of a concrete subclass of com.sun.j3d.audioengines.AudioEngine3DL2 that will be constructed by Viewer.createAudioDevice(). The default value is null, which means that audio is disabled by default for applications that call Viewer.createAudioDevice().
j3d.configURL	Unknown	1.3.1	Found in the ConfiguredUniverse class. Functionality unknown currently.
|-
|j3d.io.ImageCompression
|"None" or "GZIP" or "JPEG"
|1.3.1
|Found in the scenegraph I/O package. Functionality unknown currently.
|-
|j3d.stereo
|PREFERRED or REQUIRED
|1.1
|Only used by SimpleUniverse. If you roll your own VirtualUniverse, this property is not used. Controls whether you want Java3D to definitely create stereo mode capable canvases or not
|-
|sun.java2d.d3d
|true or false
|??
|Default true. Enable Direct3D in Java 2D (not Java 3D, actually).
|-
|sun.java2d.ddoffscreen
|true or false
|??
|Default true. Enable DirectDraw and Direct3D by Java 2D for off screen images, such as the Swing back buffer (not Java 3D, actually).
|-
|sun.java2d.noddraw
|true or false
|??
|Default false. Completely disable DirectDraw and Direct3D by Java 2D (not Java 3D, actually). This avoids any problems associated with use of these APIs and their respective drivers.
|}

[[Category:Development]]
