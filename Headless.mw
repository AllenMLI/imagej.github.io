ImageJ 1.* was never meant as anything else than a desktop application with one user in front of one screen attached to one computer.

However, it acquired macro capabilities, a batch mode for such macros, and even [[:Category:Scripting|scripting support through Fiji]].

Naturally, users want to execute such macros or scripts in environments such as clusters where there is no graphical user interface available.

= The problem =

Java ''does'' support a headless mode via the <code>java.awt.headless</code> property; setting this property to <code>true</code> enables it.

Unfortunately, with X11-based Java (such as on Linux, which is the most prevalent platform for running clusters), headless mode does not allow to instantiate any GUI components that would want to display text. The reason is that the font-metrics on X11 are provided by the X11 server (and are indeed different between servers) and therefore the dimensions of such elements simply cannot be calculated without a graphical desktop.

Since ImageJ 1.* was devised as a desktop application, everything -- including macros -- works through the GUI. For example, a simple <code>run("Open...");</code> will look for the action in the menu.

On MacOSX, there is no problem: Aqua provides GUI-independent text rendering (mapping to the actual display using anti-aliasing). There, running in headless mode allows instantiating GUI elements such as the menu bar.

= Possible solutions =

== The <code>--headless</code> mode ==

<div style="background:#ffd; padding: 10px 10px 0 10px; border: 1px solid black;">
'''Historical note:''' Headless support was originally a branch in [[ImageJA]]; it worked by putting rewritten versions of three core ImageJ classes into a file called ''headless.jar'', which was put into the class path ''before'' <code>ij.jar</code> so they would override ImageJ's versions.

Nowadays, we use [[Javassist]] for run-time patching, through the [https://github.com/imagej/ij1-patcher ImageJ 1.x patcher] project. <span style="color: red">You do not need to do anything special to take advantage of this feature, except pass the <code>--headless</code> flag when launching Fiji from the command line.</span>

In the ''unlikely'' situation that you still require a <code>headless.jar</code> file (e.g., because your Java environment does not allow run-time modification of Java classes), you can [[Downloading_and_Building_Fiji_From_Source|check out fiji.git]] and run <code>./Build.sh </code>and then <code>./Build.sh misc/headless.jar</code>.
</div>

Fiji provides the capability to execute ImageJ plugins, macros and scripts in headless mode. This feature uses bytecode manipulation to patch ImageJ 1.x's behavior at runtime, making it possible to start ImageJ in batch mode without instantiating GUI components.

'''Shortcoming:''' There are plugins which are even more bound to a GUI than ImageJ 1.x is. Naturally, these plugins will still try to instantiate GUI elements when being called in headless mode, failing.

=== Running macros in headless mode ===

To run a ''macro'' in headless mode, use the <code>-macro</code> command line argument along with the <code>--headless</code> option, as follows:

  ImageJ --headless -macro path-to-Macro.ijm

If the macro resides in ImageJ's macro directory, it is possible to specify the macro name instead of the actual file path. The file extension is always very recommended but for backwards compatibility, it is not strictly required ''only'' when specifying the macro name instead of a path.

=== Running scripts in headless mode ===

To run a ''script'' (JRuby, Jython, etc.) simply skip the <code>-batch</code> argument and pass the path to the script only.

  ImageJ --headless path-to-script

== Xvfb ==

Another method is to have a virtual desktop, e.g. [https://en.wikipedia.org/wiki/Xvfb Xvfb]. This will allow Fiji to start with a virtualised graphical desktop.

'''Advantage:''' No run-time patching is required.

'''Shortcomings:''' It is slower than it needs to be because of the overhead of starting the GUI, it is harder to configure, and plugins might get stuck because they wait for user input which never comes.

'''Example:''' Here is an example shell script that wraps a macro for use with Xvfb (thanks to Nestor Milyaev!):

<source lang="bash">
export DISPLAY=:1
Xvfb $DISPLAY -auth /dev/null &
(
# the '(' starts a new sub shell. In this sub shell we start the worker processes:

script=$scriptDir"lsmrotate2nrrd.ijm \"dir="$1"&angle-x=$2&angle-y=
$3&angle-z=$4&reverse=$5\" -batch"
$fijiBin -macro $script # running the actual ijm script

wait # waits until all 'program' processes are finished
# this wait sees only the 'program' processes, not the Xvfb process
)
</source>

== Rewriting as scripts or plugins ==

The most robust method is to rewrite macros as scripts that do not require interaction with the GUI to begin with. Unfortunately, this is the most involved solution, too, since it usually takes some time to convert macros.
