<seo metak="local maxima,local minima,extrema,inflection point, signal processing, spectral analysis" metad="local maxima,local minima,extrema,inflection point, signal processing, spectral analysis" />
{{Infobox Plugin
| software        = ImageJ/Fiji
| name            = Find Peaks
| author          = Tiago Ferreira
| maintainer     = [mailto:tiago_dot_ferreira_at_mail_dot_mcgill_dot_ca Tiago Ferreira]
| filename        = [https://raw.github.com/tferr/Scripts/master/Analysis/Find_Peaks.bsh Find_Peaks.bsh]
| source         = [https://github.com/tferr/Scripts/tree/master/Analysis#find-peaks on GitHub]
| released        = February 2014
| status          = Experimental
| category        = [[:Category:Analysis|Analysis]], [[:Category:Scripting|Scripting]], [[:Category:Plugins|Plugins]]
}}

A [[Beanshell_Scripting|BeanShell]] script that retrieves local maxima and minima from an ImageJ plot.

== Options ==
;Peak amplitude
:The smallest depth (in Y-axis units) that a qualified valley must exceed. By default, it is set to one standard deviation of the data. 

;Min. value of maxima
:The smallest value (in Y-axis units) a qualified maxima must exceed. This filter is disabled when set to ''NaN'' (Not a Number).

;Max. value of minima
:The highest value (in Y-axis units) a qualified minima must not exceed. This filter is disabled when set to ''NaN'' (Not a Number).

;Min. peak distance
:The smallest separation between peaks (in X-axis units). When this value is not zero (the default), smaller peaks within the specified vicinity will be ignored. This works in the following way: 1) Identified peaks that fulfill all of the above criteria  are sorted in descending order (largest to smallest amplitude); 2) Beginning with the largest peak, the script ignores all remaining peaks that are not separated by more than the specified ''Min. peak distance''. Applies to both maxima and minima.

;Exclude peaks on edges of plot
:If active, a peak is only accepted if it is separated by two qualified valleys. If disabled (the default), peaks at the limits of the data range (i.e., flanked only by one valley) are also considered.

[[File:FindPeaksSnapshot.png|thumb|right|550px|Analysis of synthetic data plotted from a .csv file. CSV files can be imported into ImageJ by drag and drop, or by using <span style="border-bottom:1px dotted #ccc;">File▷ Import▷ Results</span>. Once [[#options|options]] are specified, coordinates of retrieved peaks are logged to the table of a new plot window]]


== Notes ==
* Both maxima (highlighted in red) and minima (highlighted in blue) are listed in descending order, from the largest to smallest amplitude
* Peaks with flat tops are retrieved at their centers
* Peak coordinates are logged according to the following layout: [''X0,Y0'']: Original data; [''X1,Y1'']: Maxima; [''X2,Y2'']: Minima
* ''Min. peak distance'' can be used for peak width filtering


== Installation ==
Open the [[Script Editor]], select ''Language>Beanshell'' and paste the following script (you can double-click the text to select it after which the usual ''Edit>Copy'', ''[focus on the editor window]'', ''Edit>Paste'' stanza works just fine):

<source lang="java">
/* Find Peaks: Returns the local maxima and minima of an ImageJ plot.
 * https://github.com/tferr/Scripts#scripts
 *
 * Requires ImageJ 1.48d or newer. See http://fiji.sc/Find_Peaks for details.
 * Tiago Ferreira, v1.0.1 2014.02.23
 */

double tolerance;
double minPeakDistance;
double minMaximaValue = Double.NaN;
double maxMinimaValue = Double.NaN;
boolean excludeOnEdges;

int[] findPositions(double[] values, double tolerance, boolean minima) {
	int[] positions = null;
	MaximumFinder maxFinder = new MaximumFinder();
	if (minima)
		positions = maxFinder.findMinima(values, tolerance, excludeOnEdges);
	else
		positions = maxFinder.findMaxima(values, tolerance, excludeOnEdges);
	return positions;
}

int[] findMaxima(double[] values, double tolerance) {
	return findPositions(values, tolerance, false);
}

int[] findMinima(double[] values, double tolerance) {
	return findPositions(values, tolerance, true);
}

double[] getCoordinates(double[] values, int[] positions) {
	int size = positions.length;
	double[] cc = new double[size];
	for (int i=0; i<size; i++)
		cc[i] = values[ positions[i] ];
	return cc;
}

void prompt() {
	GenericDialog gd = new GenericDialog("Find Local Maxima/Minima...");
	gd.addNumericField("Min._peak_amplitude:",tolerance,2);
	gd.addNumericField("Min._peak_distance:",minPeakDistance,2);
	gd.addNumericField("Min._value of maxima:",minMaximaValue,2,6,"(NaN: no filtering)");
	gd.addNumericField("Max._value of minima:",maxMinimaValue,2,6,"(NaN: no filtering)");
	gd.addCheckbox("Exclude peaks on edges of plot",excludeOnEdges);
	gd.addHelp("http://fiji.sc/Find_Peaks");
	gd.showDialog();
	if (gd.wasCanceled()) return;
	tolerance = gd.getNextNumber();
	minPeakDistance = gd.getNextNumber();
	minMaximaValue = gd.getNextNumber();
	maxMinimaValue = gd.getNextNumber();
	excludeOnEdges = gd.getNextBoolean();
}

int[] trimPeakHeight(int[] positions, boolean minima) {
	int size1 = positions.length; int size2 = 0;
	for (int i=0; i<size1; i++) {
		if ( filteredHeight(yvalues[positions[i]], minima) )
			size2++;
		else
			break; // positions are sorted by amplitude
	}
	int[] newpositions = new int[size2];
	for (int i=0; i<size2; i++)
		newpositions[i] = positions[i];
	return newpositions;
}

boolean filteredHeight(double height, boolean minima) {
	if (minima)
		return (height < maxMinimaValue);
	else
		return (height > minMaximaValue);
}

int[] trimPeakDistance(int[] positions) {
	int size = positions.length;
	int[] temp = new int[size];
	int newsize = 0;
	for (int i=size-1; i>=0; i--) {
		int pos1 = positions[i];
		boolean trim = false;
 		for (int j=i-1; j>=0; j--) {
 			int pos2 = positions[j];
 			if (Math.abs(xvalues[pos2] - xvalues[pos1]) < minPeakDistance)
 				{ trim = true; break; }
 		}
 		if (!trim) temp[newsize++] = pos1;
	}
	int[] newpositions = new int[newsize];
	for (int i=0; i<newsize; i++)
		newpositions[i] = temp[i];
	return newpositions;
}


double[] xvalues;
double[] yvalues;
PlotWindow pw;

ImagePlus imp = WindowManager.getCurrentImage();
if (imp==null)
	{ IJ.error("There are no plots open."); return; }
ImageWindow win = imp.getWindow();
if (win!=null && (win instanceof PlotWindow)) {
	pw = (PlotWindow)win;
	float[] fyvalues = pw.getYValues();
	ArrayUtil stats = new ArrayUtil(fyvalues);
	tolerance = Math.sqrt(stats.getVariance());
	yvalues = Tools.toDouble(fyvalues);
	xvalues = Tools.toDouble(pw.getXValues());
} else {
	IJ.error(imp.getTitle() +" is not a plot window.");
	return;
}

prompt();
maxima = findMaxima(yvalues, tolerance);
minima = findMinima(yvalues, tolerance);
if (!Double.isNaN(minMaximaValue))
	maxima = trimPeakHeight(maxima, false);
if (!Double.isNaN(maxMinimaValue))
	minima = trimPeakHeight(minima, true);
if (minPeakDistance>0) {
	maxima = trimPeakDistance(maxima);
	minima = trimPeakDistance(minima);
}
xMaxima = getCoordinates(xvalues, maxima);
yMaxima = getCoordinates(yvalues, maxima);
xMinima = getCoordinates(xvalues, minima);
yMinima = getCoordinates(yvalues, minima);

String plotTitle = imp.getTitle();
Plot plot = new Plot("Peaks in "+ plotTitle, "", "", xvalues, yvalues);
plot.setLineWidth(2);
plot.setColor(Color.RED);
plot.addPoints(xMaxima, yMaxima, Plot.CIRCLE);
plot.addLabel(0.00, 0, maxima.length +" maxima");
plot.setColor(Color.BLUE);
plot.addPoints(xMinima, yMinima, Plot.CIRCLE);
plot.addLabel(0.25, 0, minima.length +" minima");
plot.setColor(Color.BLACK);
plot.addLabel(0.50, 0, "Min. amp.: "+ IJ.d2s(tolerance,2)
			+"  Min. dx.: "+ IJ.d2s(minPeakDistance,2) );
plot.setLineWidth(1);
if (plotTitle.startsWith("Peaks in"))
	pw.drawPlot(plot);
else
	plot.show();
</source>


== License ==
This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the [http://www.gnu.org/licenses/gpl.txt Free Software Foundation]. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.


[[Category:Scripting]]
[[Category:Analysis]]
[[Category:Plugins]]
