<seo metak="local maxima,local minima,extrema,inflection point, signal processing, spectral analysis" metad="local maxima,local minima,extrema,inflection point, signal processing, spectral analysis" />
{{Infobox Plugin
| software        = ImageJ/Fiji
| name            = Find Peaks
| maintainer     = [[BAR#Installation| BAR update site]]
| author          = [mailto:tiago_dot_ferreira_at_mail_dot_mcgill_dot_ca Tiago Ferreira]
| filename        = [https://raw.github.com/tferr/Scripts/master/Data_Analysis/Find_Peaks.bsh Find_Peaks.bsh]
| source         = [https://github.com/tferr/Scripts/tree/master/Data_Analysis#find-peaks on GitHub]
| released        = February 2014
| category        = [[:Category:Analysis|Analysis]], [[:Category:Scripting|Scripting]], [[:Category:Plugins|Plugins]]
}}

A [[BAR]] script (written in [[Beanshell_Scripting|BeanShell]]) that retrieves local maxima and minima from an ImageJ plot. The easiest way to install ''Find Peaks'' is by [[BAR#Installation|subscribing]] to the BAR [[List_of_update_sites|update site]].

== Options ==
[[File:FindPeaksSnapshot.png|thumb|right|550px|Analysis of synthetic data plotted from a .csv file. CSV files can be imported into ImageJ by drag and drop, or by using <span style="border-bottom:1px dotted #ccc;">File▷ Import▷ Results</span>. Once [[#options|options]] are specified, coordinates of retrieved peaks are logged to the table of a new plot window]]
;Peak amplitude
:The smallest depth (in Y-axis units) that a qualified valley must exceed. By default, it is set to one standard deviation of the data. 

;Min. value of maxima
:The smallest value (in Y-axis units) a qualified maxima must exceed. This filter is disabled when set to ''NaN'' (Not a Number).

;Max. value of minima
:The highest value (in Y-axis units) a qualified minima must not exceed. This filter is disabled when set to ''NaN'' (Not a Number).

;Min. peak distance
:The smallest separation between peaks (in X-axis units). When this value is not zero (the default), smaller peaks within the specified vicinity will be ignored. This works in the following way: 1) Identified peaks that fulfill all of the above criteria  are sorted in descending order (largest to smallest amplitude); 2) Beginning with the largest peak, the script ignores all remaining peaks that are not separated by more than the specified ''Min. peak distance''. Applies to both maxima and minima.

;Exclude peaks on edges of plot
:If active, a peak is only accepted if it is separated by two qualified valleys. If disabled (the default), peaks at the limits of the data range (i.e., flanked only by one valley) are also considered.

== Notes ==
* Both maxima and minima are listed in descending order, from the largest to smallest amplitude
* Peaks with flat tops are retrieved at their centers
* Peak coordinates are logged according to the following layout: [''X0,Y0'']: Original data; [''X1,Y1'']: Maxima; [''X2,Y2'']: Minima
* ''Min. peak distance'' can be used for peak width filtering
* Find Peaks was initially though as a [[Sholl_Analysis#Complementary_Tools|complementary tool]] for [[Sholl Analysis]] but it that can be applied to any dataset. For this reason, it is now part of [[BAR]]

== Related Resources ==
Analysis of 1D-signals was discussed in March 2014 on the [https://list.nih.gov/cgi-bin/wa.exe?A1=ind1403&L=IMAGEJ#32 ImageJ mailing list]. That discussion highlighted the following alternatives to ''Find Peaks'':
* [http://simon.bio.uva.nl/objectj/examples/PeakFinder/peakfinder.html PeakFinder Tool] by  Norbert Vischer, a [[Introduction_into_Macro_Programming|macro]] tool that retrieves intensity peaks along a straight line ROI.
* [http://cmci.embl.de/documents/120206pyip_cooking/python_imagej_cookbook#rmulti-peak_fitting_using_r Multi-Peak fitting using R] by Kota Miura, a [[Jython_Scripting|Jython]] script that calls the [http://www.r-project.org R] package [http://cran.r-project.org/web/packages/Peaks/index.html Peaks]. Requires [http://www.rforge.net/Rserve/doc.html Rserve] ([http://cmci.embl.de/documents/101105ij_r_jython#using_r_from_imagej_via_rserve instructions])
* [http://imagejdocu.tudor.lu/doku.php?id=plugin:filter:fast_filters:start Fast Filters plugin] by Michael Schmid, a collection of unidirectional filters that can be applied to to rows or columns in an image ([https://list.nih.gov/cgi-bin/wa.exe?A2=ind1403&L=IMAGEJ&F=&S=&P=136934 instructions]). 

== Installation ==
Drag this [https://raw.github.com/tferr/Scripts/master/Data_Analysis/Find_Peaks.bsh direct download link] and drop it into the main Fiji window. Alternatively, open the [[Script Editor]], select ''Language>Beanshell'' and paste the following script (you can double-click the text to select it after which the usual ''Edit>Copy'', ''[focus on the editor window]'', ''Edit>Paste'' stanza works just fine):

<source lang="java">
/* Find Peaks: Returns the local maxima and minima of an ImageJ plot.
 * https://github.com/tferr/Scripts#scripts
 *
 * Requires ImageJ 1.48d or newer. See http://fiji.sc/Find_Peaks for details.
 * Tiago Ferreira, v1.0.3 2014.06.19
 */

import ij.IJ;
import ij.ImagePlus;
import ij.WindowManager;
import ij.gui.GenericDialog;
import ij.gui.ImageWindow;
import ij.gui.Plot;
import ij.gui.PlotWindow;
import ij.plugin.filter.MaximumFinder;
import ij.util.ArrayUtil;
import ij.util.Tools;


double tolerance;
double minPeakDistance;
double minMaximaValue = Double.NaN;
double maxMinimaValue = Double.NaN;
boolean excludeOnEdges;

int[] findPositions(double[] values, double tolerance, boolean minima) {
	int[] positions = null;
	MaximumFinder maxFinder = new MaximumFinder();
	if (minima)
		positions = maxFinder.findMinima(values, tolerance, excludeOnEdges);
	else
		positions = maxFinder.findMaxima(values, tolerance, excludeOnEdges);
	return positions;
}

int[] findMaxima(double[] values, double tolerance) {
	return findPositions(values, tolerance, false);
}

int[] findMinima(double[] values, double tolerance) {
	return findPositions(values, tolerance, true);
}

double[] getCoordinates(double[] values, int[] positions) {
	int size = positions.length;
	double[] cc = new double[size];
	for (int i=0; i<size; i++)
		cc[i] = values[ positions[i] ];
	return cc;
}

boolean prompt() {
	GenericDialog gd = new GenericDialog("Find Local Maxima/Minima...");
	gd.addNumericField("Min._peak_amplitude:", tolerance, 2);
	gd.addNumericField("Min._peak_distance:", minPeakDistance, 2);
	gd.addNumericField("Min._value of maxima:", minMaximaValue, 2, 6, "(NaN: no filtering)");
	gd.addNumericField("Max._value of minima:", maxMinimaValue, 2, 6, "(NaN: no filtering)");
	gd.addCheckbox("Exclude peaks on edges of plot", excludeOnEdges);
	gd.addHelp("http://fiji.sc/Find_Peaks");
	gd.showDialog();
	boolean dialogOKed = (gd.wasCanceled()) ? false : true;
	tolerance = gd.getNextNumber();
	minPeakDistance = gd.getNextNumber();
	minMaximaValue = gd.getNextNumber();
	maxMinimaValue = gd.getNextNumber();
	excludeOnEdges = gd.getNextBoolean();
	return dialogOKed;
}

int[] trimPeakHeight(int[] positions, boolean minima) {
	int size1 = positions.length; int size2 = 0;
	for (int i=0; i<size1; i++) {
		if ( filteredHeight(yvalues[positions[i]], minima) )
			size2++;
		else
			break; // positions are sorted by amplitude
	}
	int[] newpositions = new int[size2];
	for (int i=0; i<size2; i++)
		newpositions[i] = positions[i];
	return newpositions;
}

boolean filteredHeight(double height, boolean minima) {
	if (minima)
		return (height < maxMinimaValue);
	else
		return (height > minMaximaValue);
}

int[] trimPeakDistance(int[] positions) {
	int size = positions.length;
	int[] temp = new int[size];
	int newsize = 0;
	for (int i=size-1; i>=0; i--) {
		int pos1 = positions[i];
		boolean trim = false;
 		for (int j=i-1; j>=0; j--) {
 			int pos2 = positions[j];
 			if (Math.abs(xvalues[pos2] - xvalues[pos1]) < minPeakDistance)
 				{ trim = true; break; }
 		}
 		if (!trim) temp[newsize++] = pos1;
	}
	int[] newpositions = new int[newsize];
	for (int i=0; i<newsize; i++)
		newpositions[i] = temp[i];
	return newpositions;
}


double[] xvalues;
double[] yvalues;
PlotWindow pw;

ImagePlus imp = WindowManager.getCurrentImage();
if (imp==null)
	{ IJ.error("There are no plots open."); return; }
ImageWindow win = imp.getWindow();
if (win!=null && (win instanceof PlotWindow)) {
	pw = (PlotWindow)win;
	float[] fyvalues = pw.getYValues();
	ArrayUtil stats = new ArrayUtil(fyvalues);
	tolerance = Math.sqrt(stats.getVariance());
	yvalues = Tools.toDouble(fyvalues);
	xvalues = Tools.toDouble(pw.getXValues());
} else {
	IJ.error(imp.getTitle() +" is not a plot window.");
	return;
}

if (!prompt()) return;
int[] maxima = findMaxima(yvalues, tolerance);
int[] minima = findMinima(yvalues, tolerance);
if (!Double.isNaN(minMaximaValue))
	maxima = trimPeakHeight(maxima, false);
if (!Double.isNaN(maxMinimaValue))
	minima = trimPeakHeight(minima, true);
if (minPeakDistance>0) {
	maxima = trimPeakDistance(maxima);
	minima = trimPeakDistance(minima);
}
double[] xMaxima = getCoordinates(xvalues, maxima);
double[] yMaxima = getCoordinates(yvalues, maxima);
double[] xMinima = getCoordinates(xvalues, minima);
double[] yMinima = getCoordinates(yvalues, minima);

String plotTitle = imp.getTitle();
Plot plot = new Plot("Peaks in "+ plotTitle, "", "", xvalues, yvalues);
plot.setLineWidth(2);
plot.setColor(Color.RED);
plot.addPoints(xMaxima, yMaxima, Plot.CIRCLE);
plot.addLabel(0.00, 0, maxima.length +" maxima");
plot.setColor(Color.BLUE);
plot.addPoints(xMinima, yMinima, Plot.CIRCLE);
plot.addLabel(0.25, 0, minima.length +" minima");
plot.setColor(Color.BLACK);
plot.addLabel(0.50, 0, "Min. amp.: "+ IJ.d2s(tolerance,2) +"  Min. dx.: "+ IJ.d2s(minPeakDistance,2) );
plot.setLineWidth(1);
if (plotTitle.startsWith("Peaks in"))
	pw.drawPlot(plot);
else
	plot.show();
</source>

== License ==
This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the [http://www.gnu.org/licenses/gpl.txt Free Software Foundation]. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.


[[Category:Scripting]]
[[Category:Analysis]]
[[Category:Plugins]]
