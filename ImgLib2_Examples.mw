== Introduction & required files ==

This page shows ten increasingly complex examples of how to program with ImgLib2. The intention of these examples are not to explain ImgLib2 concepts, but rather to give some practical hints how to work with the library and to grasp the principles in a learning-by-doing way.

All examples presented on this page are always entire classes including a main method to run them. Simply copying them into your favorite editor (e.g. the [[Script Editor]]) and compile & run them. The required Java libraries (jar files) are part of Fiji and can be found in ''Fiji.app/jars/'':

* imglib2.jar (the core)
* imglib2-algorithms.jar (algorithms implemented in ImgLib2)
* imglib2-io.jar (input/output using LOCI bioformats)
* imglib2-ij.jar (the ImageJ interaction)
* ij.jar (ImageJ core, used for display)
* mpicbg.jar (for RealSum in example 3b)

and ''Fiji.app/plugins/'':

* loci_tools.jar (LOCI [[Bio-Formats]])

=== Overview of examples ===

* '''[[ImgLib2 Examples#Example 1 - Opening, creating and displaying images | Example 1]]''': opening, creating and displaying images

== Example 1 - Opening, creating and displaying images ==

The first example illustrates the most basic operations of opening, creating, and displaying image content in ImgLib2. It will first focus on entires images ('''Img<T>'''), but also show how to display subsets only.

=== Example 1a - Wrapping ImageJ images ===

If you are already an ImageJ programmer, you might find it the easiest way to simply wrap an ImageJ image into ImgLib2. Here, the data is not copied, so editing the image in ImgLib2 will also modify the ImageJ ImagePlus. 

Internally, we use a compatibility '''Img''' to represent the data which is as fast as ImageJ but in the case of higher dimensionality (>2d) is slower than ImgLib2 can do with the '''ArrayImg'''. Furthermore you are limited in dimensionality (2d-5d), in the type of data ('''UnsignedByteType''', '''UnsignedShortType''', '''FloatType''' and '''ARGBType''') and maximal size of each 2d-plane (max. 46000x46000).

<source lang="java">
import java.io.File;

import net.imglib2.img.ImagePlusAdapter;
import net.imglib2.img.Img;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.type.numeric.NumericType;

import ij.ImageJ;
import ij.ImagePlus;
import ij.io.Opener;

/**
 * Opens a file with ImageJ and wraps it into an ImgLib {@link Image}.
 *
 * @author Stephan Preibisch &amp; Stephan Saalfeld
 *
 */
public class Example1a
{
	// within this method we define <T> to be a NumericType (depends on the type of ImagePlus)
	// you might want to define it as RealType if you know it cannot be an ImageJ RGB Color image
	public < T extends NumericType< T > > Example1a()
	{
		// define the file to open
		File file = new File( "DrosophilaWing.tif" );

		// open a file with ImageJ
		final ImagePlus imp = new Opener().openImage( file.getAbsolutePath() );

		// display it via ImageJ
		imp.show();

		// wrap it into an ImgLib image (no copying)
		final Img< T > image = ImagePlusAdapter.wrap( imp );

		// display it via ImgLib using ImageJ
		ImageJFunctions.show( image );
	}

	public static void main( String[] args )
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example1a();
	}
}
</source>

=== Example 1b - Opening an ImgLib2 image ===

The typical way to open an image in ImgLib2 is to make use of the LOCI bioformats importer. Below you see two examples of how open to an image as ''(a)'' its own type (e.g. '''UnsignedByteType''') and ''(b)'' as float ('''FloatType'''). For ''(a)'' we assume, however, that the file contains some real valued numbers as defined by the interface '''RealType''' (see here for a complete Type hierarchy). Color images are opened as well and color is represented as its own dimension (like in the ImageJ Hyperstacks). 

Note that for ''(a)'' we use an '''ArrayImg''' to hold the data. This means the data is held in one single java basic type array which results in optimal performance. The absolute size of image is, however, limited to 2^31-1 (~2 billion) pixels. The type of '''Img''' to use is defined by an '''ImgFactory'''. The '''ArrayImgFactory''' in this case has no arguments.

In ''(b)'' we use the '''CellImg''' instead. It partitions the image data into n-dimensional cells each holding only a part of the data. The size of each cell is defined in the '''CellImgFactory'''. If you use the maximal cell size of 2^31-1 pixels (i.e. a maximally sized java native type array), you can address up to 2^62 pixels (~4 exapixels or 4 billion gigapixels) in one '''Img'''.

The LOCI opener also requires '''Types''' that implement '''NativeType''', which means it is able to map the data into an java basic type array. All available '''Types''' until now are implementing '''NativeType''', if you want to work with some self-developed '''Type''' it would be easiest to copy the opened '''Img''' afterwards. Please also note that until now, the only '''Img''' that supports non-native types is the '''ListImg''' which stores every pixel as an individual object!

'''Important''': it does not matter which type of '''Img''' you use to hold the data as we will use '''Iterators''' and '''RandomAccesses''' to access the image content. It might be, however, important if you work on two '''Img''' at the same time using '''Iterators''', see Example2.

<source lang="java">
import java.io.File;

import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.img.ImgFactory;
import net.imglib2.img.array.ArrayImgFactory;
import net.imglib2.img.cell.CellImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.NativeType;
import net.imglib2.type.numeric.RealType;
import net.imglib2.type.numeric.real.FloatType;

import ij.ImageJ;

/**
 * Opens a file with ImgOpener Bioformats as an ImgLib2 Img.
 */
public class Example1b
{
	// within this method we define <T> to be a RealType and a NativeType which means the  	
	// Type is able to map the data into an java basic type array  
	public < T extends RealType< T > & NativeType< T > > Example1b() 
		throws ImgIOException, IncompatibleTypeException
	{
		// define the file to open
		File file = new File( "DrosophilaWing.tif" );

		// open with ImgOpener using an ArrayImgFactory, here the return type will be 
		// defined by the opener
		// the opener will ignore the Type of the ArrayImgFactory
		ImgFactory< ? > imgFactory = new ArrayImgFactory< T >();
		Img< T > image = new ImgOpener().openImg( file.getAbsolutePath(), imgFactory );

		// display it via ImgLib using ImageJ
		ImageJFunctions.show( image );

		// open with ImgOpener as Float using a CellImgFactory, it will be opened as float 	
		// independent of the type of the image
		// to enforce to open it as FloatType, an instance of FloatType has to be passed along
		Img< FloatType > imageFloat = new ImgOpener().openImg( file.getAbsolutePath(), 
			new CellImgFactory< FloatType >( 10 ), new FloatType() );

		// display it via ImgLib using ImageJ
		ImageJFunctions.show( imageFloat );
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example1b();
	}
}
</source>

=== Example 1c - Creating a new ImgLib2 image ===

Another important way to instantiate a new ImgLib2 '''Img''' is to create a new one from scratch. This requires you to define its '''Type''' as well as the '''ImgFactory''' to use. It additionally need one instance of the '''Type''' that it is supposed to hold. 

Once you have one instance of an '''Img''', it is very easy to create another one using the same '''Type''' and '''ImgFactory''', even if it has a different size. Note that the call '''img.firstElement()''' returns the first pixel of any '''Iterable''', e.g. an '''Img'''.

<source lang="java">
import net.imglib2.img.Img;
import net.imglib2.img.ImgFactory;
import net.imglib2.img.cell.CellImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.type.numeric.real.FloatType;
import ij.ImageJ;

/**
 * Create a new ImgLib2 Img of Type FloatType
 */
public class Example1c
{
	public Example1c()
	{
		// create the ImgFactory based on cells (cellsize = 5x5x5...x5) that will 
		// instantiate the Img
		final ImgFactory< FloatType > imgFactory = new CellImgFactory< FloatType >( 5 );

		// create an 3d-Img with dimensions 20x30x40 (here cellsize is 5x5x5)Ã˜
		final Img< FloatType > img1 = imgFactory.create( new long[]{ 20, 30, 40 }, new FloatType() );

		// create another image with the same size
		// note that the input provides the size for the new image as it implements 
		// the Interval interface
		final Img< FloatType > img2 = imgFactory.create( img1, img1.firstElement() );

		// display both (but they are empty)
		ImageJFunctions.show( img1 );
		ImageJFunctions.show( img2 );
	}

	public static void main( String[] args )
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example1c();
	}
}
</source>

=== Example 1d - Displaying images partly using Views ===

Using the concept of '''Views''' it is possible to display only parts of the image, display a rotated view and many more cool things. Note that you can also concatenate them. '''Views''' are much more powerful than shown in this example, they will be increasingly used throughout the examples.

A '''View''' almost behaves are like an '''Img''', they share important concepts. Both are '''RandomAccessible''' and '''Views''' that are not infinite are also an '''Interval''' (i.e. have a defined size) and can therefore be made '''Iterable''' (see example 2c). In ImgLib2, all algorithms are implemented for these abstract concepts like '''RandomAccessible''', '''Iterable''' or '''Interval'''. This enables us, like in this example, to simply display a '''View''' the same way as an '''Img'''.

<source lang="java">
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.img.array.ArrayImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.numeric.real.FloatType;
import net.imglib2.view.Views;
import ij.ImageJ;

/**
 * Open an ArrayImg< FloatType > and display partly and rotated  
 */
public class Example1d
{
	public Example1d() throws ImgIOException, IncompatibleTypeException
	{
		// open file as float
		Img< FloatType > img = new ImgOpener().openImg( "DrosophilaWing.tif", 
				new ArrayImgFactory< FloatType >(), new FloatType() );

		// display image
		ImageJFunctions.show( img );
		
		// use a View to define an interval (min and max coordinate, including) to display
		RandomAccessibleInterval< FloatType > view = 
				Views.interval( img, new long[] { 200, 200 }, new long[]{ 500, 350 } );
		
		// display only the part of the Img
		ImageJFunctions.show( view );
		
		// or the same area rotated by 90 degrees (x-axis (0) and y-axis (1) switched)
		ImageJFunctions.show( Views.rotate( view, 0, 1 ) );
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example1d();
	}
}
</source>

[[Image:ImgLib2example1d.jpg|780px]]
''Shows the original image, the View of an interval, as well as the by 90 degree rotated version of the view. Note that only the original image in kept in memory, both Views are completely virtual.''

== Example 2 - How to use Cursor, RandomAccess and Type ==

The following examples illustrate how to access pixels using '''Cursor''' and '''RandomAccess''', their basic properties, and how to modify pixel values using '''Type'''.

Accessing pixels using a '''Cursor''' means to iterate all pixels in a way similar to iterating Java collections. However, a '''Cursor''' only ensures to visit each pixel exactly once, the order of iteration is not fixed in order to optimize the speed of iteration. This implies that that the order of iteration on two different '''Img''' is not necessarily the same, see [[ImgLib2 Examples#Example 2b - Duplicating an Img using a different ImgFactory | example 2b]]! '''Cursors''' can be created by any object that implements '''IterableInterval''', such as an '''Img'''. '''Views''' that are not infinite can be made iterable (see example 2c). ''Note that in general a '''Cursor''' has significantly higher performance than a '''RandomAccess''' and should therefore be given preference if possible''.

In contrast to iterating image data, a '''RandomAccess''' can be placed at arbitrary locations. It is possible to set them to a specific n-dimensional coordinate or move them relative to their current position. Note that relative movements are usually more performant. A '''RandomAccess''' can be created by any object that implements '''RandomAccessible''', like an '''Img''' or a '''View'''.

'''Localizable''' is implemented by '''Cursor''' as well as '''RandomAccess''', which means they are able to report their current location. However, for '''Cursor''' we differentiate between a '''LocalizingCursor''' and a normal '''Cursor'''. A '''LocalizingCursor''' updates his position on every move, no matter if it is queried or not whereas a normal '''Cursor''' computes its location on demand. Using a '''LocalizingCursor''' is more efficient if the location is queried for every pixel, a '''Cursor''' will be faster when localizing only occasionally.

The '''Sampler''' interface implemented by '''Cursor''' and '''RandomAccess''' provides access to the '''Type''' instance of the current pixel. Using the '''Type''' instance it is possible to read and write its current value. Depending on the capabilities of the '''Type''' more operations are available, e.g. +,-,*,/ if it is a '''NumericType'''.

Note that '''IterableInterval''' implements the java.lang.Iterable interface, which means it is compatible to specialized Java language constructs:
<source lang="java">
// add 5 to every pixel
for ( UnsignedByteType type : img )
	type.add( 5 );
</source>

=== Example 2a - Duplicating an Img using a generic method ===

The goal of this example is to make a copy of an existing '''Img'''. For this task it is sufficient to employ '''Cursors'''. The order of iteration for both '''Img''''s will be the same as they are instantiated using the same '''ImgFactory'''. It is possible to test if two '''IterableInterval''' have the same iteration order:
<source lang="java">
boolean sameIterationOrder = interval1.equalIterationOrder( interval2 );
</source>

The copy method itself is a generic method, it will work on any kind of '''Type'''. In this particular case it works on a '''FloatType''', but would also work on anything else like for example a '''ComplexDoubleType'''. The declaration of the generic type is done in the method declaration:
<source lang="java">
public < T extends Type< T > > Img< T > copyImage( ... )
</source>
'''< T extends Type< T > >''' basically means that '''T''' can be anything that extends '''Type'''. These can be final implementations such as '''FloatType''' or also intermediate interfaces such as '''RealType'''. This, however, also means that in the method body only operations supported by '''Type''' will be available. Note that the method returns a '''T''', which also means that in the constructor from which we call method it will also return an '''Img<FloatType>''' as we provide it with one. 

<source lang="java">
import ij.ImageJ;
import net.imglib2.Cursor;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.img.array.ArrayImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.Type;
import net.imglib2.type.numeric.real.FloatType;

/**
 * Here we want to copy an Image into another one using a generic method
 *
 * @author Stephan Preibisch &amp; Stephan Saalfeld
 *
 */
public class Example2a
{
	public Example2a() throws ImgIOException, IncompatibleTypeException
	{
		// open with ImgOpener using an ArrayImgFactory
		Img< FloatType > img = new ImgOpener().openImg( "DrosophilaWing.tif",
			new ArrayImgFactory< FloatType >(), new FloatType() );

		// copy the image, as it is a generic method it also works with FloatType
		Img< FloatType > duplicate = copyImage( img );

		// display the copy
		ImageJFunctions.show( duplicate );
	}

	/**
	 * Generic, type-agnostic method to create an identical copy of an Img
	 * 
	 * @param input - the Img to copy
	 * @return - the copy of the Img
	 */
	public < T extends Type< T > > Img< T > copyImage( final Img< T > input )
	{
		// create a new Image with the same properties
		// note that the input provides the size for the new image as it implements 
		// the Interval interface
		Img< T > output = input.factory().create( input, input.firstElement() );

		// create a cursor for both images
		Cursor< T > cursorInput = input.cursor();
		Cursor< T > cursorOutput = output.cursor();

		// iterate over the input
		while ( cursorInput.hasNext())
		{
			// move both cursors forward by one pixel
			cursorInput.fwd();
			cursorOutput.fwd();

			// set the value of this pixel of the output image to the same as the input,
			// every Type supports T.set( T type )
			cursorOutput.get().set( cursorInput.get() );
		}

		// return the copy
		return output;
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example2a();
	}
}
</source>

=== Example 2b - Duplicating an Img using a different ImgFactory ===

<span style="color:#FF0000">'''WARNING: The first code in this example makes a mistake on purpose!'''</span> It intends to show that the iteration order of '''Cursors''' is important to consider. The goal is to copy the content of an '''ArrayImg''' (i.e. an '''Img''' that was created using an '''ArrayImgFactory''') into a '''CellImg'''. Using only '''Cursors''' for both images will have a wrong result as an '''ArrayImg''' and a '''CellImg''' have different iteration orders. An '''ArrayImg''' is iterated linearly, while a '''CellImg''' is iterate cell-by-cell, but linearly within each cell.

<source lang="java">
import ij.ImageJ;
import net.imglib2.Cursor;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.img.ImgFactory;
import net.imglib2.img.array.ArrayImgFactory;
import net.imglib2.img.cell.CellImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.Type;
import net.imglib2.type.numeric.real.FloatType;

/**
 * Here we want to copy an ArrayImg into a CellImg using a generic method,
 * but we cannot do it with simple Cursors as they have a different iteration order.
 *
 * @author Stephan Preibisch &amp; Stephan Saalfeld
 *
 */
public class Example2b
{

	public Example2b() throws ImgIOException, IncompatibleTypeException
	{
		// open with ImgOpener using an ArrayImgFactory
		Img< FloatType > img = new ImgOpener().openImg( "DrosophilaWing.tif", 
			new ArrayImgFactory< FloatType >(), new FloatType() );

		// copy the image into a CellImg with a cellsize of 20x20
		Img< FloatType > duplicate = copyImage( img, new CellImgFactory< FloatType >( 20 ) );

		// display the copy and the original
		ImageJFunctions.show( img );
		ImageJFunctions.show( duplicate );
	}

	public < T extends Type< T >> Img< T > copyImage( final Img< T > input, 
		final ImgFactory< T > imgFactory )
	{
		// create a new Image with the same dimensions but the other imgFactory
		// note that the input provides the size for the new image as it 
		// implements the Interval interface
		Img< T > output = imgFactory.create( input, input.firstElement() );

		// create a cursor for both images
		Cursor< T > cursorInput = input.cursor();
		Cursor< T > cursorOutput = output.cursor();

		// iterate over the input cursor
		while ( cursorInput.hasNext())
		{
			// move both forward
			cursorInput.fwd();
			cursorOutput.fwd();

			// set the value of this pixel of the output image, every Type supports T.set( T type )
			cursorOutput.get().set( cursorInput.get() );
		}

		//. return the copy
		return output;
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example2b();
	}
}
</source>

[[Image:ImgLib2example2b.png|780px]]
''Shows the result if two Cursors are used that have a different iteration order. Here we are wrongly copying an ArrayImg (left) into a CellImg (right).''

<span style="color:#FF0000">The correct code for the copy-method requires the use of a '''RandomAccess'''.</span> We use a '''Cursor''' to iterate over all pixels of the input and a '''RandomAccess''' which we set to the same location the output. Note that the ''setPosition()'' call of the '''RandomAccess''' directly takes the '''Cursor''' as input, which is possible because '''Cursor''' implements '''Localizable'''. Please also note that we use a '''LocalizingCursor''' instead of a normal '''Cursor''' because we need the location of the '''Cursor''' at every pixel.

<source lang="java">
public < T extends Type< T >> Img< T > copyImage( final Img< T > input, 
	final ImgFactory< T > imgFactory )
{
	// create a new Image with the same dimensions but the other imgFactory
	// note that the input provides the size for the new image by implementing the Interval interface
	Img< T > output = imgFactory.create( input, input.firstElement() );

	// create a cursor that automatically localizes itself on every move
	Cursor< T > cursorInput = input.localizingCursor();
	RandomAccess< T > randomAccess = output.randomAccess();

	// iterate over the input cursor
	while ( cursorInput.hasNext())
	{
		// move input cursor forward
		cursorInput.fwd();

		// set the output cursor to the position of the input cursor
		randomAccess.setPosition( cursorInput );

		// set the value of this pixel of the output image, every Type supports T.set( T type )
		randomAccess.get().set( cursorInput.get() );
	}

	// return the copy
	return output;
}
</source>

=== Example 2c - Generic copying of image data ===

In order to write a method that generically copies data requires an implementation for the underlying concepts of '''RandomAccessible''', '''Interable''' and '''Interval'''. In that way, it will run on '''Img''', '''View''' and any other class implemented for these interfaces (even if they do not exist yet).

Therefore we design the copy method in a way that the ''target'' is an '''IterableInterval''' and the ''source'' is '''RandomAccessible'''. In this way, we simply iterate over the ''target'' and copy the corresponding pixels from the ''source''. 

As the ''source'' only needs to be '''RandomAccessible''', it can be basically anything that can return a value at a certain location. This can be as simple as an '''Img''', but also interpolated sparse data, a function, a ray-tracer, a '''View''', ....

As the ''target'' needs to be an '''IterableInterval''', it is more confined. This, however does not necessarily mean it can only an '''Img''' or a '''View''' that is not infinite. It simply means it has to be something that is iterable and not infinite, which for example also applies to sparse data (e.g. a list of locations and their values).

<source lang="java">
import ij.ImageJ;
import net.imglib2.Cursor;
import net.imglib2.IterableInterval;
import net.imglib2.RandomAccess;
import net.imglib2.RandomAccessible;
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.img.array.ArrayImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.Type;
import net.imglib2.type.numeric.real.FloatType;
import net.imglib2.view.Views;

/**
 * Here we want to copy an Image into another with a different Container one using a generic method,
 * using a LocalizingCursor and a RandomAccess
 *
 * @author Stephan Preibisch &amp; Stephan Saalfeld
 *
 */
public class Example2d
{
	public Example2d() throws ImgIOException, IncompatibleTypeException
	{
		// open with ImgOpener using an ArrayImgFactory
		Img< FloatType > img = new ImgOpener().openImg( "DrosophilaWing.tif", 
			new ArrayImgFactory< FloatType >(), new FloatType() );

		// copy & display an image
		Img< FloatType > duplicate = img.factory().create( img, img.firstElement() );
		copy( img, duplicate );
		ImageJFunctions.show( duplicate );
		
		// use a View to define an interval as source for copying
		//
		// Views.offsetInterval() does not only define where it is, but also adds a translation 
		// so that the minimal coordinate (upper left) of the view maps to (0,0)
		RandomAccessibleInterval< FloatType > viewSource = Views.offsetInterval( img, 
			new long[] { 100, 100 }, new long[]{ 250, 150 } );

		// and as target
		RandomAccessibleInterval< FloatType > viewTarget = Views.offsetInterval( img, 
			new long[] { 500, 200 }, new long[]{ 250, 150 } );
		
		// now we make the target iterable 
		// (which is possible because it is a RandomAccessibleInterval)
		IterableInterval< FloatType > iterableTarget = Views.iterable( viewTarget );
		
		// copy it into the original image (overwriting part of img)
		copy( viewSource, iterableTarget );
		
		// show the original image
		ImageJFunctions.show( img );
	}

	/**
	 * Copy from a source that is just RandomAccessible to an IterableInterval. Latter one defines 
	 * size and location of the copy operation. It will query the same pixel locations of the
 	 * IterableInterval in the RandomAccessible. It is up to the developer to ensure that these 
	 * coordinates match. 
	 * 
	 * Note that both, input and output could be Views, Img or anything that implements 
	 * those interfaces.
	 * 
	 * @param source - a RandomAccess as source that can be infinite
	 * @param target - an IterableInterval as target
	 */
	public < T extends Type< T > > void copy( final RandomAccessible< T > source, 
		final IterableInterval< T > target )
	{
		// create a cursor that automatically localizes itself on every move
		Cursor< T > targetCursor = target.localizingCursor();
		RandomAccess< T > sourceRandomAccess = source.randomAccess();

		// iterate over the input cursor
		while ( targetCursor.hasNext())
		{
			// move input cursor forward
			targetCursor.fwd();

			// set the output cursor to the position of the input cursor
			sourceRandomAccess.setPosition( targetCursor );

			// set the value of this pixel of the output image, every Type supports T.set( T type )
			targetCursor.get().set( sourceRandomAccess.get() );
		}
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example2d();
	}
}
</source>

== Example 3 -  Writing generic algorihms ==

Examples 1 and 2 tried to introduce important tools you need in order to implement algorithms with ImgLib2. This example will show three generic implementations of algorithms computing the 
[[ImgLib2 Examples#Example 3a - Min/Max search | min/max]], average as well as the center of mass.

The core idea is to implement algorithms as generic as possible in order to maximize code-reusability. In general, a good way to start is to think: ''What are the minimal requirements in order to implement algorithm X?'' This applies to all of the following three concepts:
* '''Type:''' You should always use the most abstract '''Type''' possible, i.e. the one that just offers enough operations to perform your goal. In this way, the algorithm will be able to run on '''Types''' you might not even have thought about when implementing it. A good example is the min&max search in example 3a. Instead of implementing it for '''FloatType''' or the more abstract '''RealType''', we implement it for the even more abstract '''Comparable & Type'''.
* '''Image data:''' Every algorithm should only demand those interfaces that it requires, not specific implementations of it like '''Img'''. You might require '''RandomAccessible''' (infinite), '''RandomAccessibleInterval''' (finite), '''Iterable''' (values without location), '''IterableInterval''' (values and their location) or their corresponding interfaces for ''real-valued locations'' '''RealRandomAccessible''', '''RealRandomAccessibleRealInterval''' and '''IterableRealInterval'''. Note that you can concatenate them if you need more than one property.
* '''Dimensionality:''' Usually there is no reason to restrict an algorithm to a certain dimensionality (like only for two-dimensional images), at least we could not really come up with an convincing example<br />''If the application or plugin your are developing addresses a certain dimensionality (e.g. stitching of panorama photos) it is understandable that you do not want to implement everything n-dimensionally. But try to implement as many as possible of the smaller algorithm you are using as generic, n-dimensional methods. For example, everything that requires only to '''iterate''' the data is usually inherently n-dimensional.''

Following those ideas, your newly implemented algorithm will be applicable to any kind of data and dimensionality it is defined for, not only a very small domain you are currently working with. Also note that quite often this actually makes the implementation simpler.

=== Example 3a -  Min/Max search ===

Searching for the minimal and maximal value in a dataset is a very nice example to illustrate generic algorithms. In order to find min/max values, '''Types''' only need to be able to compare themselves. Therefore we do not need any numeric values, we only require them to implement the (Java) interface '''Comparable'''. Additionally, no random access to the data is required, we simply need to iterate all pixels, also their location is irrelevant. The image data we need only needs to be '''Iterable'''.

Below we show '''three''' small variations of the min/max search. [[ImgLib2 Examples#Example 3a - Variation 1 | First]] we show the implementation as described above. [[ImgLib2 Examples#Example 3a - Variation 2 | Second]] we illustrate that this also works on a standard Java '''ArrayList'''. [[ImgLib2 Examples#Example 3a - Variation 3 | Third]] we show how the implementation changes if we do not only want the min/max value, but also their location. This requires to use '''IterableInterval''' instead, as '''Cursor''' can return their location.

==== Example 3a - Variation 1 ====

<source lang="java">
import ij.ImageJ;

import java.util.Iterator;

import net.imglib2.Cursor;
import net.imglib2.RandomAccess;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.NativeType;
import net.imglib2.type.Type;
import net.imglib2.type.numeric.RealType;

/**
 * Perform a generic min & max search
 *
 * @author Stephan Preibisch &amp; Stephan Saalfeld
 *
 */
public class Example3a
{
	public < T extends RealType< T > & NativeType< T > > Example3a() 
		throws ImgIOException, IncompatibleTypeException
	{
		// open with ImgOpener (he will decide which Img is best)
		Img< T > img = new ImgOpener().openImg( "DrosophilaWing.tif" );

		// create two empty variables
		T min = img.firstElement().createVariable();
		T max = img.firstElement().createVariable();

		// compute min and max of the Image
		computeMinMax( img, min, max );

		System.out.println( "minimum Value (img): " + min );
		System.out.println( "maximum Value (img): " + max );
	}

	/**
	 * Compute the min and max for any {@link Iterable}, like an {@link Img}.
	 *
	 * The only functionality we need for that is to iterate. Therefore we need no {@link Cursor} 
	 * that can localize itself, neither do we need a {@link RandomAccess}. So we simply use the
	 * most simple interface in the hierarchy.
	 *
	 * @param input - the input that has to just be {@link Iterable}
	 * @param min - the type that will have min
	 * @param max - the type that will have max
	 */
	public < T extends Comparable< T > & Type< T > > void computeMinMax( 
		final Iterable< T > input, final T min, final T max )
	{
		// create a cursor for the image (the order does not matter)
		final Iterator< T > iterator = input.iterator();

		// initialize min and max with the first image value
		T type = iterator.next();

		min.set( type );
		max.set( type );

		// loop over the rest of the data and determine min and max value
		while ( iterator.hasNext() )
		{
			// we need this type more than once
			type = iterator.next();

			if ( type.compareTo( min ) < 0 )
				min.set( type );

			if ( type.compareTo( max ) > 0 )
				max.set( type );
		}
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example3a();
	}
</source>

==== Example 3a - Variation 2 ====

Note that this example would just the same way if the input is not an '''Img''', but for example just a standard Java '''ArrayList'''

<source lang="java">
public Example3a()
{
	// it will work as well on a normal ArrayList
	ArrayList< FloatType > list = new ArrayList< FloatType >();
		
	// put values 0 to 10 into the ArrayList		
	for ( int i = 0; i <= 10; ++i )
		list.add( new FloatType( i ) );

	// create two empty variables
	FloatType min = new FloatType();
	FloatType max = new FloatType();

	// compute min and max of the ArrayList
	computeMinMax( list, min, max );

	System.out.println( "minimum Value (arraylist): " + min );
	System.out.println( "maximum Value (arraylist): " + max );
}

</source>

==== Example 3a - Variation 3 ====

If we want to compute the location of the minimal and maximal pixel value, an '''Iterator''' will not be sufficient as we need location information. Instead the location search will demand an '''IterableInterval''' as input data which can create '''Cursors'''. Apart from that, the algorithm looks quite similar. Note that we do not use a '''LocalizingCursor''' but only a '''Cursor''' the location happens only when a new maximal or minimal value has been found while iterating the data.

<source lang="java">
import ij.ImageJ;
import net.imglib2.Cursor;
import net.imglib2.IterableInterval;
import net.imglib2.Point;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.NativeType;
import net.imglib2.type.Type;
import net.imglib2.type.numeric.RealType;

/**
 * Perform a generic min/max search.
 *
 * @author Stephan Preibisch &amp; Stephan Saalfeld
 *
 */
public class Example3a
{
	public < T extends RealType< T > & NativeType< T > > Example3a() 
		throws ImgIOException, IncompatibleTypeException
	{
		// open with ImgOpener (he will decide which Img is best)
		Img< T > img = new ImgOpener().openImg( "DrosophilaWing.tif" );

		// create two location objects
		Point locationMin = new Point( img.numDimensions() );
		Point locationMax = new Point( img.numDimensions() );

		// compute location of min and max
		computeMinMaxLocation( img, locationMin, locationMax );

		System.out.println( "location of minimum Value (img): " + locationMin );
		System.out.println( "location of maximum Value (img): " + locationMax );
	}

	/**
	 * Compute the location of the minimal and maximal intensity for any IterableInterval,
	 * like an {@link Img}.
	 *
	 * The functionality we need is to iterate and retrieve the location. Therefore we need a 
	 * Cursor that can localize itself.
	 * Note that we do not use a LocalizingCursor as localization just happens from time to time.
	 *
	 * @param input - the input that has to just be {@link IterableInterval}
	 * @param min - the location for the minimal value
	 * @param max - the location of the maximal value
	 */
	public < T extends Comparable< T > & Type< T > > void computeMinMaxLocation(
		final IterableInterval< T > input, final Point minLocation, final Point maxLocation )
	{
		// create a cursor for the image (the order does not matter)
		final Cursor< T > cursor = input.cursor();

		// initialize min and max with the first image value
		T type = cursor.next();
		T min = type.copy();
		T max = type.copy();

		// loop over the rest of the data and determine min and max value
		while ( cursor.hasNext() )
		{
			// we need this type more than once
			type = cursor.next();

			if ( type.compareTo( min ) < 0 )
			{
				min.set( type );
				minLocation.setPosition( cursor );
			}

			if ( type.compareTo( max ) > 0 )
			{
				max.set( type );
				maxLocation.setPosition( cursor );
			}
		}
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example3a();
	}
}
</source>

=== Example 3b - Computing average ===

In a very similar way one can compute the average intensity for image data. Note that we restrict the '''Type''' of data to '''RealType'''. In theory, we could use '''NumericType''' as it offers the possibility to ''add'' up values. However, we cannot ensure that '''NumericType''' provided is capable of adding up millions of pixels without overflow. And even if we would ask for a second '''NumericType''' that is capable of adding values up, it might still have numerical instabilities. ''Note that actually every Java native type has those instabilities''. Therefore we use the '''RealSum''' class that offers correct addition of even very large amounts of pixels. As this implementation is only available for double values, we restrict the method here to '''RealType'''.

<source lang="java">
import ij.ImageJ;
import mpicbg.util.RealSum;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.NativeType;
import net.imglib2.type.numeric.RealType;

/**
 * Perform a generic computation of average intensity
 *
 * @author Stephan Preibisch &amp; Stephan Saalfeld
 *
 */
public class Example3b
{
	public < T extends RealType< T > & NativeType< T > > Example3b() throws 
		ImgIOException, IncompatibleTypeException
	{
		// open with ImgOpener using an ArrayImgFactory
		Img< T > img = new ImgOpener().openImg( "DrosophilaWing.tif" );

		// compute average of the image
		double avg = computeAverage( img );
		System.out.println( "average Value: " + avg );
	}

	/**
	 * Compute the average intensity for an {@link Iterable}.
	 *
	 * @param input - the input data
	 * @return - the average as double
	 */
	public < T extends RealType< T > > double computeAverage( final Iterable< T > input )
	{
		// Count all values using the RealSum class.
		// It prevents numerical instabilities when adding up millions of pixels
		RealSum realSum = new RealSum();
		long count = 0;

		for ( final T type : input )
		{
			realSum.add( type.getRealDouble() );
			++count;
		}

		return realSum.getSum() / count;
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example3b();
	}
}
</source>

== Example 4 - Specialized iterables ==

Example 4 will focus on how to work with specialized '''iterables'''. They are especially useful when performing operations in the local neighborhood of many pixels - like finding local minima/maxima, texture analysis, convolution with non-separable, non-linear filters and many more. One elegant solution is to write a specialized '''Iterable''' that will iterate all pixels in the local neighborhood. We implemented two examples:
* A '''HyperSphere''' that will iterate a n-dimensional sphere with a given radius at a defined location.
* A '''LocalNeighborhood''' that will iterate n-dimensionally all pixels adjacent to a certain location, but skip the central pixel (this corresponds to an both neighbors in 1d, an 8-neighborhood in 2d, a 26-neighborhood in 3d, and so on ...)

=== Example 4a - Drawing a sphere full of spheres ===

In the first sample we simply draw a sphere full of little spheres. We therefore create a large '''HyperSphere''' in the center of a '''RandomAccessibleInterval'''. Note that the '''HyperSphere''' only needs a '''RandomAccessible''', we need the additional '''Interval''' simply to compute the center and the radius of the large sphere. When iterating over all pixels of this large sphere, we create small '''HyperSpheres''' at every n'th pixel and fill them with a random intensity.

This example illustrates the use of specialized '''Iterables''', and emphasizes the fact that they can be stacked on the underlying '''RandomAccessible''' using the location of one as the center of a new one. Note that we always create new instances of '''HyperSphere'''. The code reads very nicely but might not offer the best performance. We therefore added ''update'' methods to the '''HyperSphere''' and its '''Cursor''' that could be used instead.

Another interesting aspect of this example is the use of the '''ImagePlusImgFactory''', which is the compatibility container for ImageJ. If the required dimensionality and '''Type''' is available in ImageJ, it will internally create an ImagePlus and work on it directly. In this case, one can request the ImagePlus and show it directly. It will, however, fail if '''Type''' and dimensionality is not supported by ImageJ and throw a '''ImgLibException'''.

<source lang="java">
import ij.ImageJ;
import ij.ImagePlus;

import java.util.Random;

import net.imglib2.Point;
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.algorithm.region.hypersphere.HyperSphere;
import net.imglib2.algorithm.region.hypersphere.HyperSphereCursor;
import net.imglib2.exception.ImgLibException;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.img.imageplus.ImagePlusImg;
import net.imglib2.img.imageplus.ImagePlusImgFactory;
import net.imglib2.io.ImgIOException;
import net.imglib2.type.numeric.RealType;
import net.imglib2.type.numeric.integer.UnsignedByteType;
import net.imglib2.util.Util;

/**
 * Draw a sphere full of little spheres
 */
public class Example4a
{
	public Example4a() throws ImgIOException, IncompatibleTypeException
	{
		// open with ImgOpener using an ImagePlusImg
		ImagePlusImg< UnsignedByteType, ?> img 
			= new ImagePlusImgFactory< UnsignedByteType >().create( 
				new long[] { 256, 256, 256 }, new UnsignedByteType() );

		// draw a small sphere for every pixel of a larger sphere
		drawSpheres( img, 0, 255 );
		
		// display output and input
		try 
		{
			ImagePlus imp = img.getImagePlus();
			imp.show();
		} 
		catch ( ImgLibException e )
		{
			System.out.println( "This ImagePlusImg does not hold a native ImagePlus as container,
				either because the dimensionality is too high or because the type is not
				supported." );
			ImageJFunctions.show( img );
		}
	}
	
	/**
	 * Draws a sphere that contains lots of small spheres into the center of the interval
	 * 
	 * @param randomAccessible - the image data to write to
	 * @param minValue - the minimal intensity of one of the small spheres
	 * @param maxValue - the maximal intensity of one of the small spheres
	 */
	public < T extends RealType< T > > void drawSpheres( 
		final RandomAccessibleInterval< T > randomAccessible, 
		final double minValue, final double maxValue )
	{	
		// the number of dimensions
		int numDimensions = randomAccessible.numDimensions();
		
		// define the center and radius
		Point center = new Point( randomAccessible.numDimensions() );
		long minSize = randomAccessible.dimension( 0 );
		
		for ( int d = 0; d < numDimensions; ++d )
		{
			long size = randomAccessible.dimension( d );
			
			center.setPosition( size / 2 , d );
			minSize = Math.min( minSize, size );
		}
		
		// define the maximal radius of the small spheres
		int maxRadius = 5;
		
		// compute the radius of the large sphere so that we do not draw 
		// outside of the defined interval
		long radiusLargeSphere = minSize / 2 - maxRadius - 1;
		
		// instantiate a random number generator
		Random rnd = new Random( System.currentTimeMillis() );
		
		// define a hypersphere (n-dimensional sphere)
		HyperSphere< T > hyperSphere = 
			new HyperSphere<T>( randomAccessible, center, radiusLargeSphere );
		
		// create a cursor on the hypersphere
		HyperSphereCursor< T > cursor = hyperSphere.cursor();
		
		while ( cursor.hasNext() )
		{
			cursor.fwd();
			
			// the random radius of the current small hypersphere
			int radius = rnd.nextInt( maxRadius ) + 1;
			
			// instantiate a small hypersphere at the location of the current pixel 
			// in the large hypersphere
			HyperSphere< T > smallSphere = 
				new HyperSphere< T >( randomAccessible, cursor, radius );
			
			// define the random intensity for this small sphere
			double randomValue = rnd.nextDouble();
			
			// take only every 4^dimension'th pixel by chance so that it is not too crowded
			if ( Math.round( randomValue * 100 ) % Util.pow( 4, numDimensions ) == 0 )
			{
				// scale to right range
				randomValue = rnd.nextDouble() * ( maxValue - minValue ) + minValue;
				
				// set the value to all pixels in the small sphere if the intensity is 
				// brighter than the existing one
				for ( final T value : smallSphere )
					value.setReal( Math.max( randomValue, value.getRealDouble() ) );
			}
		}
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example4a();
	}
}
</source>

[[Image:ManySpheres.jpg|780px]]
''Shows the result of example 4a for the (a) two-dimensional, (b) three-dimensional and (c) four-dimensional case. The image series in (c) represents a movie of a three-dimensional rendering. The images of (b) and (c) were rendered using the ImageJ 3d Viewer.''

=== Example 4b - Finding and displaying local minima ===

In this example we want to find all local minima in an image an display them as small spheres. To not capture to much of the noise in the image data, we first perform an in-place Gaussian smoothing with a sigma of 1, i.e. the data will be overwritten with the result. A complete documentation of the gauss package for ImgLib2 can be found [[Gauss_Package_ImgLib2 | here]].

We display the results using a binary image. ''Note that the '''BitType''' only requires one bit per pixel and therefore is very memory efficient.''

The generic method for minima detection has some more interesting properties. The '''Type''' of the source image data actually does not require to be of '''Type''', it simply needs something that is comparable. The '''LocalNeighborhood''' will iterate n-dimensionally all pixels adjacent to a certain location, but skip the central pixel (this corresponds to an both neighbors in 1d, an 8-neighborhood in 2d, a 26-neighborhood in 3d, and so on ...). This allows to efficiently detect if a pixel is a local minima or maxima. Note that the '''Cursor''' that performs the iteration can have special implementations for specific dimensionalities to speed up the iteration. See below the example for a specialized three-dimensional iteration:

 Acces plan for a 3d neighborhood, starting at the center position marked by (x). The initial
 position is NOT part of iteration, which means the center pixel is not iterated. Note that 
 every step except for the last one can be done with a very simple move command.
 
 upper z plane (z-1)		center z plane (z=0)		lower z plane(z+1)
 -------------			-------------			-------------
 | 2 | 1 | 8 |			| 11| 10| 9 |			| 20| 19| 18|
 |------------			-------------			-------------
 | 3 | 0 | 7 |			| 12| x | 16|			| 21| 25| 17|
 |------------			-------------			-------------
 | 4 | 5 | 6 |			| 13| 14| 15|			| 22| 23| 24|
 -------------			-------------			-------------

Please note as well that if one would increase the radius of the sphere to more than one, it would fail as we would try to write image data outside of the defined boundary. '''OutOfBoundsStrategies''' which define how to handle such cases is discusses in example 5.

<source lang="java">
import ij.ImageJ;
import net.imglib2.Cursor;
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.algorithm.gauss.Gauss;
import net.imglib2.algorithm.region.hypersphere.HyperSphere;
import net.imglib2.algorithm.region.localneighborhood.LocalNeighborhood;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.img.ImgFactory;
import net.imglib2.img.array.ArrayImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.NativeType;
import net.imglib2.type.logic.BitType;
import net.imglib2.type.numeric.RealType;
import net.imglib2.view.Views;

/**
 * Here we use special cursors to find the local minima and 
 * display them with spheres in another image
 */
public class Example4b
{
	public < T extends RealType< T > & NativeType< T > > Example4a() 
		throws ImgIOException, IncompatibleTypeException
	{
		// open with ImgOpener
		Img< T > img = new ImgOpener().openImg( "DrosophilaWing.tif" );
		
		// first we do a small in-place gaussian smoothing with a sigma of 1
		Gauss.inDoubleInPlace( new double[]{ 1, 1 }, img );
		
		// find local minima and paint them into another image as spheres
		Img< BitType > display = 
			findAndDisplayLocalMinima( img, new ArrayImgFactory< BitType >(), new BitType() );

		// display output and input
		ImageJFunctions.show( img );
		ImageJFunctions.show( display );
	}

	/**
	 * Checks all pixels in the image if they are a local minima and 
	 * draws a circle into the output if they are
	 * 
	 * @param source - the image data to work on
	 * @param imageFactory - the factory for the output img
	 * @param outputType - the output type
	 * @return - an Img with circles on locations of a local minimum
	 */
	public static < T extends Comparable< T >, U extends RealType< U > > Img< U >
		findAndDisplayLocalMinima(
			RandomAccessibleInterval< T > source,
			ImgFactory< U > imageFactory, U outputType )
	{
		// we need the number of dimensions a lot
		final int numDimensions = source.numDimensions();

		// Create a new image for the output
		Img< U > output = imageFactory.create( source, outputType );
		
		// define an interval that is one pixel smaller on each side in each dimension,
		// so that the search in the 8-neighborhood (3x3x3...x3) never goes outside 
		// of the defined interval
		long[] min = new long[ numDimensions ];
		long[] max = new long[ numDimensions ];
		
		for ( int d = 0; d < numDimensions; ++d )
		{
			min[ d ] = source.min( d ) + 1;
			max[ d ] = source.max( d ) - 1;
		}

		// create a view on the source with this interval
		source = Views.interval( source, min, max );
		
		// create a Cursor that iterates over the source and checks in a 8-neighborhood 
		// if it is a minima
		Cursor< T > cursor = Views.iterable( source ).localizingCursor();

		// instantiate a local neighborhood that we will use all the time
		// it iterates all pixels adjacent to the center, but skips the center
		// pixel (this corresponds to an 8-neighborhood in 2d or 26-neighborhood in 3d, ...)
		LocalNeighborhood< T > localNeighborhood = 
			new LocalNeighborhood< T >( source, cursor );
		
		// iterate over the image
		while ( cursor.hasNext() )
		{
			cursor.fwd();
			
			// update the local neighborhood cursor to the position of the cursor
			localNeighborhood.updateCenter( cursor );
			
			// what is the value that we investigate
			final T centerValue = cursor.get();

			// keep this boolean true as long as no other value in the local neighborhood
			// is larger or equal
			boolean isMinimum = true;

			// check if all pixels in the local neighborhood that are smaller
			for ( final T value : localNeighborhood )
			{
				// test if the center is smaller than the current pixel value
				if ( centerValue.compareTo( value ) >= 0 )
				{
					isMinimum = false;
					break;
				}				
			}
			
			if ( isMinimum )
			{
				// draw a sphere of radius one in the new image
				HyperSphere< U > hyperSphere = new HyperSphere< U >( output, cursor, 1 );

				// set every value inside the sphere to 1
				for ( U value : hyperSphere )
					value.setOne();
			}
		}

		return output;
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example4b();
	}
}
</source>

[[Image:AllMinima.jpg|780px]]
''Shows the result of the detection of local minima after the Gaussian blurring. (a) depicts the input image, (b) the blurred version (sigma=1) and (c) all local mimina drawn as circles with radius 1.''

== Example 5 - Out of bounds ==

Many algorithms like ''convolutions'' require to access pixels outside of an '''Interval''', i.e. also pixel outside of an image. In ImgLib2 this is handled using '''Views''' which convert an '''RandomAccessibleInterval''' into an infinite '''RandomAccessible''' using an '''OutOfBoundsStrategy'''. Those infinite '''RandomAccesibless''' are able to return pixel values at any arbitrary location.

''Important: One should never access pixels outside of the defined '''Interval''' as it will in most cases result in unexpected behavior, depending on the kind of underlying '''RandomAccessible'''. If it is for example an '''Img''', it will return wrong values or throw an exception.'' 

Which '''OutOfBoundsStrategies''' to use depends on task you want to perform. For convolutions we suggest the mirror strategy as it introduces the least artifacts. When working on Fourier images, the periodic strategy applies best as it correctly mimics its spatial properties. Random Value strategies might be useful to avoid accidental correlations and constant value strategies are the most performant and might work well for simple operations or to avoid exceptions when accidental writing or reading outside of the Interval occurs.

<source lang="java">
import ij.ImageJ;
import net.imglib2.ExtendedRandomAccessibleInterval;
import net.imglib2.FinalInterval;
import net.imglib2.RandomAccessible;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.img.array.ArrayImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.outofbounds.OutOfBoundsConstantValueFactory;
import net.imglib2.type.numeric.real.FloatType;
import net.imglib2.view.Views;

/**
 * Illustrate outside strategies
 *
 */
public class Example5
{
	public Example5() throws ImgIOException, IncompatibleTypeException
	{
		// open with ImgOpener using an ArrayImgFactory
		Img< FloatType > image = new ImgOpener().openImg( "DrosophilaWingSmall.tif", 
			new ArrayImgFactory< FloatType >(), new FloatType() );

		// create an infinite view where all values outside of the Interval are 0
		RandomAccessible< FloatType> infinite1 = 
			Views.extendValue( image, new FloatType( 0 ) );

		// create an infinite view where all values outside of the Interval are 128
		RandomAccessible< FloatType> infinite2 = 
			Views.extendValue( image, new FloatType( 128 ) );

		// create an infinite view where all outside valuesare random in a range of 0-255
		RandomAccessible< FloatType> infinite3 = Views.extendRandom( image, 0, 255 );

		// create an infinite view where all values outside of the Interval are
		// the mirrored content, the mirror is the last pixel
		RandomAccessible< FloatType> infinite4 = Views.extendMirrorSingle( image ); 

		// create an infinite view where all values outside of the Interval are
		// the mirrored content, the mirror is BEHIND the last pixel, 
		// i.e. the first and last pixel are always duplicated
		RandomAccessible< FloatType> infinite5 = Views.extendMirrorDouble( image ); 
		
		// all values outside of the Interval periodically repeat the image content
		// (like the Fourier space assumes)
		RandomAccessible< FloatType> infinite6 = Views.extendPeriodic( image ); 
		
		// if you implemented your own strategy that you want to instantiate, it will look like this
		RandomAccessible< FloatType> infinite7 = 
			new ExtendedRandomAccessibleInterval< FloatType, Img< FloatType > >( image, 
				new OutOfBoundsConstantValueFactory< FloatType, Img< FloatType > >( 
				new FloatType( 255 ) ) );
		
		// visualize the outofbounds strategies
		
		// in order to visualize them, we have to define a new interval 
		// on them which can be displayed
		long[] min = new long[ image.numDimensions() ];
		long[] max = new long[ image.numDimensions() ];
		
		for ( int d = 0; d < image.numDimensions(); ++d )
		{
			// we add/subtract another 30 pixels here to illustrate
			// that it is really infinite and does not only work once
			min[ d ] = -image.dimension( d ) - 90 ;
			max[ d ] = image.dimension( d ) * 2 - 1 + 90;
		}
		
		// define the Interval on the infinite random accessibles
		FinalInterval interval = new FinalInterval( min, max );
		
		// now define the interval on the infinite view and display
		ImageJFunctions.show( Views.interval( infinite1, interval ) );
		ImageJFunctions.show( Views.interval( infinite2, interval ) );
		ImageJFunctions.show( Views.interval( infinite3, interval ) );
		ImageJFunctions.show( Views.interval( infinite4, interval ) );
		ImageJFunctions.show( Views.interval( infinite5, interval ) );
		ImageJFunctions.show( Views.interval( infinite6, interval ) );
		ImageJFunctions.show( Views.interval( infinite7, interval ) );
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example5();
	}
}
</source>

[[File:OutOfBounds.jpg|780px]]
''Illustrates the effect of various OutOfBoundsStrategies. (a) shows out of bounds with a constant value, (b) shows a mirroring strategy, (c) shows the periodic strategy, and (d) shows a strategy that uses random values.''

== Example 6 - Basic built-in algorithms ==

ImgLib2 contains a growing number of built-in standard algorithms. In this section, we will show some of those, illustrate how to use them and give some examples of what it might be used for. 

Typically algorithms provide static methods for simple calling, but they also have classes which you can instantiate yourself to have more options. 

''Important: Algorithms do not allow to work on a different dimensionality than the input data. You can achieve that by selecting hyperslices using Views (see Example 6a - version 4). In this way you can for example apply two-dimensional gaussians to each frame of a movie independently.''

=== Example 6a - Gaussian convolution ===

The Gaussian convolution has its own  [[Gauss_Package_ImgLib2 | wiki page]]. You can apply the Gaussian convolution with different sigmas in any dimension. It will work on any kind '''RandomAccessibleInterval'''. Below we show a examples of a simple gaussian convolution (variation 1), convolution using a different '''OutOfBoundsStrategy''' (variation 2), convolution of a part of an '''Interval''' (variation 3), and convolution of in a lower dimensionality than the image data (variation 4).

[[File:GaussExamples.jpg|780px]]
''Shows the result of the four examples for Gaussian convolution. (a) shows a simple Gaussian convolution with sigma=8. (b) shows the same Gaussian convolution but using an OutOfBoundsConstantValue instead. (c) shows the result when convolving part of the image in-place. (d) shows the result when individually convolving 1-dimensional parts on the image.''

==== Example 6a - Gaussian convolution (variation 1 - simple) ====

Here, we simply apply a Gaussian convolution with a sigma of 8. Note that it could be applied in-place as well when calling ''Gauss.inFloatInPlace( ... )''. The Gaussian convolution uses by default the '''OutOfBoundsMirrorStrategy'''.

<source lang="java">
import ij.ImageJ;
import net.imglib2.algorithm.gauss.Gauss;
import net.imglib2.img.Img;
import net.imglib2.img.array.ArrayImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.numeric.real.FloatType;

/**
 * Use of Gaussian Convolution on the Image
 *
 * @author Stephan Preibisch &amp; Stephan Saalfeld
 *
 */
public class Example6a1
{
	public Example6a1() throws ImgIOException
	{
		// open with ImgOpener using an ArrayImgFactory
		Img< FloatType > image = new ImgOpener().openImg( "DrosophilaWing.tif", 
			new ArrayImgFactory< FloatType >(), new FloatType() );
		
		// perform gaussian convolution with float precision
		double[] sigma = new double[ image.numDimensions() ];
		
		for ( int d = 0; d < image.numDimensions(); ++d )
			sigma[ d ] = 8;

		// convolve & display
		ImageJFunctions.show( Gauss.toFloat( sigma, image ) );
	}

	public static void main( String[] args ) throws ImgIOException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example6a1();
	}
}
</source>

==== Example 6a - Gaussian convolution (variation 2 - different OutOfBoundsStrategy) ====

<source lang="java">
import ij.ImageJ;
import net.imglib2.Point;
import net.imglib2.RandomAccessible;
import net.imglib2.algorithm.gauss.Gauss;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.img.array.ArrayImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.numeric.real.FloatType;
import net.imglib2.view.Views;

/**
 * Use of Gaussian Convolution on the Image
 * but convolve with a different outofboundsstrategy
 *
 * @author Stephan Preibisch &amp; Stephan Saalfeld
 *
 */
public class Example6a2
{
	public Example6a2() throws ImgIOException
	{
		// open with ImgOpener using an ArrayImgFactory
		Img< FloatType > image = new ImgOpener().openImg( "DrosophilaWing.tif", 
			new ArrayImgFactory< FloatType >(), new FloatType() );
		
		// perform gaussian convolution with float precision
		double[] sigma = new double[ image.numDimensions() ];
		
		for ( int d = 0; d < image.numDimensions(); ++d )
			sigma[ d ] = 8;

		// first extend the image to infinity, zeropad
		RandomAccessible< FloatType > infiniteImg = Views.extendValue( image, new FloatType() );
		
		// now we convolve the whole image manually in-place
		// note that is is basically the same as the call above, just called in a more generic way
		//
		// sigma .. the sigma
		// infiniteImg ... the RandomAccessible that is the source for the convolution
		// image ... defines the Interval in which convolution is performed
		// image ... defines the RandomAccessible target of the convolution
		// new Point( image.numDimensions() ) ... defines the offset for the target, here it is (0,0)
		// image.factory ... the image factory which is required to create temporary images
		Gauss.inFloat( sigma, infiniteImg, image, image, 
			new Point( image.numDimensions() ), image.factory() );
		
		// show the in-place convolved image (note the different outofboundsstrategy at the edges)
		ImageJFunctions.show( image );
	}

	public static void main( String[] args ) throws ImgIOException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example6a2();
	}
}
</source>

==== Example 6a - Gaussian convolution (variation 3 - only part of an Interval) ====

<source lang="java">
import ij.ImageJ;
import net.imglib2.FinalInterval;
import net.imglib2.Point;
import net.imglib2.RandomAccessible;
import net.imglib2.algorithm.gauss.Gauss;
import net.imglib2.img.Img;
import net.imglib2.img.array.ArrayImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.numeric.real.FloatType;
import net.imglib2.view.Views;

/**
 * Use of Gaussian Convolution on the Image
 * but convolve just a part of the image
 *
 * @author Stephan Preibisch &amp; Stephan Saalfeld
 *
 */
public class Example6a3
{
	public Example6a3() throws ImgIOException
	{
		// open with ImgOpener using an ArrayImgFactory
		Img< FloatType > image = new ImgOpener().openImg( "DrosophilaWing.tif", 
			new ArrayImgFactory< FloatType >(), new FloatType() );
		
		// perform gaussian convolution with float precision
		double[] sigma = new double[ image.numDimensions() ];
		
		for ( int d = 0; d < image.numDimensions(); ++d )
			sigma[ d ] = 8;
		
		// we need to extend it nevertheless as the algorithm needs more pixels from around 
		// the convolved area and we are not sure how much exactly (altough we could compute 
		// it with some effort from the sigma)
		RandomAccessible< FloatType> infiniteImg = Views.extendMirrorSingle( image );
		
		// define the area
		long[] min = new long[] { 100, 30 };
		long[] max = new long[] { 500, 250 };
		FinalInterval region = new FinalInterval( min, max );
		
		// call the gauss, we convolve only a region and write it back to the exact same coordinates
		Gauss.inFloat( sigma, infiniteImg, region, image, new Point( min ), image.factory() );
		
		ImageJFunctions.show( image );
	}

	public static void main( String[] args ) throws ImgIOException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example6a3();
	}
}
</source>

==== Example 6a - Gaussian convolution (variation 4 - with a lower dimensionality) ====

<source lang="java">
import ij.ImageJ;
import net.imglib2.Point;
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.algorithm.gauss.Gauss;
import net.imglib2.img.Img;
import net.imglib2.img.array.ArrayImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.numeric.real.FloatType;
import net.imglib2.view.Views;

/**
 * Use of Gaussian Convolution on the Image
 *
 * @author Stephan Preibisch &amp; Stephan Saalfeld
 *
 */
public class Example6a4
{
	public Example6a4() throws ImgIOException
	{
		// open with ImgOpener using an ArrayImgFactory
		Img< FloatType > image = new ImgOpener().openImg( "DrosophilaWing.tif", 
			new ArrayImgFactory< FloatType >(), new FloatType() );

		// perform all (n-1)-dimensional gaussian (in this case it means 1d) on 
		// some of the row/columns
		double[] sigma = new double[ image.numDimensions() - 1 ];
		
		for ( int d = 0; d < sigma.length; ++d )
			sigma[ d ] = 16;
		
		// iterate over all dimensions, take always a hyperslice
		for ( int dim = 0; dim < image.numDimensions(); ++dim )
			// iterate over all possible hyperslices
			for ( long pos = 0; pos < image.dimension( dim ); ++pos )
				// convolve a subset of the 1-dimensional views
				if ( pos/30 % 2 == 1 )
				{
					// get the n-1 dimensional "slice"
					RandomAccessibleInterval< FloatType > view = 
						Views.hyperSlice( image, dim, pos );
					
					// compute the gauss in-place on the view
					Gauss.inFloat( sigma, Views.extendMirrorSingle( view ), view, view, 
						new Point( view.numDimensions() ), image.factory() );
				}

		// show the result
		ImageJFunctions.show( image );
	}

	public static void main( String[] args ) throws ImgIOException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example6a4();
	}
}
</source>
