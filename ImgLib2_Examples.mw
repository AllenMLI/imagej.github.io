== Introduction & required files ==

This page shows ten increasingly complex examples of how to program with ImgLib2. The intention of these examples are not to explain ImgLib2 concepts, but rather to give some practical hints how to work with the library and to grasp the principles in a learning-by-doing way.

All examples presented on this page are always entire classes including a main method to run them. Simply copying them into your favorite editor and compiling it will run them. The required Java libraries (jar files) can be found in Fiji/jars:

* imglib2.jar (the core)
* imglib2-algorithms.jar (algorithms implemented in ImgLib2)
* imglib2-io.jar (input/output using LOCI bioformats)
* imglib2-ij.jar (the ImageJ interaction)
* ij.jar (ImageJ core, used for display)

and Fiji/plugins:

* loci_tools.jar (LOCI bioformats)

=== Overview of examples ===

* '''[[ImgLib2 Examples#Example 1 - opening, creating and displaying images | Example 1]]''': opening, creating and displaying images

== Example 1 - Opening, creating and displaying images ==

The first example illustrates the most basic operations of opening, creating, and displaying image content in ImgLib2. It will first focus on entires images ('''Img<T>'''), but also show how to display subsets only.

=== Example 1a - Wrapping ImageJ images ===

If you are already an ImageJ programmer, you might find it the easiest way to simply wrap an ImageJ image into ImgLib2. Here, the data is not copied, so editing the image in ImgLib2 will also modify the ImageJ ImagePlus. 

Internally, we use a compatibility '''Img''' to represent the data which is as fast as ImageJ but in the case of higher dimensionality (>2d) is slower than ImgLib2 can do with the '''ArrayImg'''. Furthermore you are limited in dimensionality (2d-5d), in the type of data ('''UnsignedByteType''', '''UnsignedShortType''', '''FloatType''' and '''ARGBType''') and maximal size of each 2d-plane (max. 46000x46000).

<source lang="java">
import java.io.File;

import net.imglib2.img.ImagePlusAdapter;
import net.imglib2.img.Img;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.type.numeric.NumericType;

import ij.ImageJ;
import ij.ImagePlus;
import ij.io.Opener;

/**
 * Opens a file with ImageJ and wraps it into an ImgLib {@link Image}.
 *
 * @author Stephan Preibisch &amp; Stephan Saalfeld
 *
 */
public class Example1a
{
	// within this method we define <T> to be a NumericType (depends on the type of ImagePlus)
	// you might want to define it as RealType if you know it cannot be an ImageJ RGB Color image
	public < T extends NumericType< T > > Example1a()
	{
		// define the file to open
		File file = new File( "DrosophilaWing.tif" );

		// open a file with ImageJ
		final ImagePlus imp = new Opener().openImage( file.getAbsolutePath() );

		// display it via ImageJ
		imp.show();

		// wrap it into an ImgLib image (no copying)
		final Img< T > image = ImagePlusAdapter.wrap( imp );

		// display it via ImgLib using ImageJ
		ImageJFunctions.show( image );
	}

	public static void main( String[] args )
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example1a();
	}
}
</source>

=== Example 1b - Opening an ImgLib2 image ===

The typical way to open an image in ImgLib2 is to make use of the LOCI bioformats importer. Below you see two examples of how open to an image as ''(a)'' its own type (e.g. '''UnsignedByteType''') and ''(b)'' as float ('''FloatType'''). For ''(a)'' we assume, however, that the file contains some real valued numbers as defined by the interface '''RealType''' (see here for a complete Type hierarchy). Color images are opened as well and color is represented as its own dimension (like in the ImageJ Hyperstacks). 

Note that for ''(a)'' we use an '''ArrayImg''' to hold the data. This means the data is held in one single java basic type array which results in optimal performance. The absolute size of image is, however, limited to 2^31-1 (~2 billion) pixels. The type of '''Img''' to use is defined by an '''ImgFactory'''. The '''ArrayImgFactory''' in this case has no arguments.

In ''(b)'' we use the '''CellImg''' instead. It partitions the image data into n-dimensional cells each holding only a part of the data. The size of each cell is defined in the '''CellImgFactory'''. If you use the maximal cell size of 2^31-1 pixels (i.e. a maximally sized java native type array), you can address up to 2^62 pixels (~4 exapixels or 4 billion gigapixels) in one '''Img'''.

The LOCI opener also requires '''Types''' that implement '''NativeType''', which means it is able to map the data into an java basic type array. All available '''Types''' until now are implementing '''NativeType''', if you want to work with some self-developed '''Type''' it would be easiest to copy the opened '''Img''' afterwards. Please also note that until now, the only '''Img''' that supports non-native types is the '''ListImg''' which stores every pixel as an individual object!

'''Important''': it does not matter which type of '''Img''' you use to hold the data as we will use '''Iterators''' and '''RandomAccesses''' to access the image content. It might be, however, important if you work on two '''Img''' at the same time using '''Iterators''', see Example2.

<source lang="java">
import java.io.File;

import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.img.ImgFactory;
import net.imglib2.img.array.ArrayImgFactory;
import net.imglib2.img.cell.CellImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.NativeType;
import net.imglib2.type.numeric.RealType;
import net.imglib2.type.numeric.real.FloatType;

import ij.ImageJ;

/**
 * Opens a file with ImgOpener Bioformats as an ImgLib2 Img.
 */
public class Example1b
{
	// within this method we define <T> to be a RealType and a NativeType which means the  	
	// Type is able to map the data into an java basic type array  
	public < T extends RealType< T > & NativeType< T > > Example1b() 
		throws ImgIOException, IncompatibleTypeException
	{
		// define the file to open
		File file = new File( "DrosophilaWing.tif" );

		// open with ImgOpener using an ArrayImgFactory, here the return type will be 
		// defined by the opener
		// the opener will ignore the Type of the ArrayImgFactory
		ImgFactory< ? > imgFactory = new ArrayImgFactory< T >();
		Img< T > image = new ImgOpener().openImg( file.getAbsolutePath(), imgFactory );

		// display it via ImgLib using ImageJ
		ImageJFunctions.show( image );

		// open with ImgOpener as Float using a CellImgFactory, it will be opened as float 	
		// independent of the type of the image
		// to enforce to open it as FloatType, an instance of FloatType has to be passed along
		Img< FloatType > imageFloat = new ImgOpener().openImg( file.getAbsolutePath(), 
			new CellImgFactory< FloatType >( 10 ), new FloatType() );

		// display it via ImgLib using ImageJ
		ImageJFunctions.show( imageFloat );
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example1b();
	}
}
</source>

=== Example 1c - Creating a new ImgLib2 image ===

Another important way to instantiate a new ImgLib2 '''Img''' is to create a new one from scratch. This requires you to define its '''Type''' as well as the '''ImgFactory''' to use. It additionally need one instance of the '''Type''' that it is supposed to hold. 

Once you have one instance of an '''Img''', it is very easy to create another one using the same '''Type''' and '''ImgFactory''', even if it has a different size. Note that the call '''img.firstElement()''' returns the first pixel of any '''Iterable''', e.g. an '''Img'''.

<source lang="java">
import net.imglib2.img.Img;
import net.imglib2.img.ImgFactory;
import net.imglib2.img.cell.CellImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.type.numeric.real.FloatType;
import ij.ImageJ;

/**
 * Create a new ImgLib2 Img of Type FloatType
 */
public class Example1c
{
	public Example1c()
	{
		// create the ImgFactory based on cells (cellsize = 5x5x5...x5) that will 
		// instantiate the Img
		final ImgFactory< FloatType > imgFactory = new CellImgFactory< FloatType >( 5 );

		// create an 3d-Img with dimensions 20x30x40 (here cellsize is 5x5x5)Ã˜
		final Img< FloatType > img1 = imgFactory.create( new long[]{ 20, 30, 40 }, new FloatType() );

		// create another image with the same size
		// note that the input provides the size for the new image as it implements 
		// the Interval interface
		final Img< FloatType > img2 = imgFactory.create( img1, img1.firstElement() );

		// display both (but they are empty)
		ImageJFunctions.show( img1 );
		ImageJFunctions.show( img2 );
	}

	public static void main( String[] args )
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example1c();
	}
}
</source>

=== Example 1d - Displaying images partly using Views ===

Using the concept of '''Views''' it is possible to display only parts of the image, display a rotated view and many more cool things. Note that you can also concatenate them. '''Views''' are much more powerful than shown in this example, they will be increasingly used throughout the examples.

A '''View''' almost behaves are like an '''Img''', they share important concepts. Both are '''RandomAccessible''' and '''Views''' that are not infinite are also an '''Interval''' (i.e. have a defined size) and can therefore be made '''Iterable'''. In ImgLib2, all algorithms are implemented for these abstract concepts like '''RandomAccessible''', '''Iterable''' or '''Interval'''. This enables us, like in this example, to simply display a '''View''' the same way as an '''Img'''.

<source lang="java">
import net.imglib2.RandomAccessibleInterval;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.img.array.ArrayImgFactory;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.numeric.real.FloatType;
import net.imglib2.view.Views;
import ij.ImageJ;

/**
 * Open an ArrayImg< FloatType > and display partly and rotated  
 */
public class Example1d
{
	public Example1d() throws ImgIOException, IncompatibleTypeException
	{
		// open file as float
		Img< FloatType > img = new ImgOpener().openImg( "DrosophilaWing.tif", 
				new ArrayImgFactory< FloatType >(), new FloatType() );

		// display image
		ImageJFunctions.show( img );
		
		// use a View to define an interval (min and max coordinate, including) to display
		RandomAccessibleInterval< FloatType > view = 
				Views.interval( img, new long[] { 200, 200 }, new long[]{ 500, 350 } );
		
		// display only the part of the Img
		ImageJFunctions.show( view );
		
		// or the same area rotated by 90 degrees (x-axis (0) and y-axis (1) switched)
		ImageJFunctions.show( Views.rotate( view, 0, 1 ) );
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example1d();
	}
}
</source>

== Example 2 - How to use Cursor, RandomAccess and Type ==

The following examples illustrate how to access pixels using '''Cursor''' and '''RandomAccess''', their basic properties, and how to modify their pixel values using '''Type'''.

Accessing pixels using a '''Cursor''' means to iterate all pixels in a way similar iterating Java collections. However, a '''Cursor''' only ensures to visit each pixel exactly once, the order of iteration is not fixed in order to optimize the speed of iteration. This implies that that the order of iteration on two different '''Img''' is not necessarily the same, see example 2b! '''Cursors''' can be created by any object that implements '''IterableInterval''', such as an '''Img'''. '''Views''' that are not infinite can be made iterable (see example 2c). ''Note that in general a '''Cursor''' has significantly higher performance than a '''RandomAccess''' and should therefore be given preference if possible''.

In contrast to iterating image data, a '''RandomAccess''' can be placed at arbitrary locations to query its value. It is possible to set them to a specific n-dimensional coordinate or move them relative to their current position. Note that relative movements are usually more performant. A '''RandomAccess''' can be created by any object that implements '''RandomAccessible''', like an '''Img''' or a '''View'''.

'''Localizable''' is implemented by '''Cursor''' as well as '''RandomAccess''', which means they are able to report their current location. However, for '''Cursor''' we differentiate between a '''LocalizingCursor''' and a normal '''Cursor'''. A '''LocalizingCursor''' updates his position on every move, no matter if it is queried or not whereas a normal '''Cursor''' computes its location on demand. Using a '''LocalizingCursor''' is more efficient if the location is queried for every pixel, a '''Cursor''' will be faster when localizing only occasionally.

The '''Sampler''' interface implemented by '''Cursor''' and '''RandomAccess''' provides access to the '''Type''' instance of the current pixel. Using the '''Type''' instance it is possible to read and write its current value. Depending on the capabilities of the '''Type''' more operations are available, e.g. +,-,*,/ if it is a '''NumericType'''.

Note that '''IterableInterval''' implements the java.lang.Iterable interface, which means it is compatible to specialized Java language constructs:
<source lang="java">
for ( UnsignedByteType type : img )
	type.add( 5 );
</source>

=== Example 2a - Duplicating an Img using a generic method ===

The goal of this example is to make a copy of an existing '''Img'''. For this task it is sufficient to employ '''Cursors'''. The order of iteration for both '''Img''' will be the same as it is instantiated using the same '''ImgFactory'''.

The copy method itself is a generic method, it will work on any kind of '''Type'''. In this particular case it works on a '''FloatType''', but would also work on anything else like for example a '''ComplexDoubleType'''. The declaration of the generic type is done in the method declaration:
<source lang="java">
public < T extends Type< T > > Img< T > copyImage( ... )
</source>
'''< T extends Type< T > >''' basically means that '''T''' can be anything that extends '''Type'''. These can be final implementations such as '''FloatType''' or also intermediate interfaces such as '''RealType'''. This, however, also means that in the method body only operations supported by '''Type''' will be available. As the method returns a '''T''' as well, 

<source lang="java">
import ij.ImageJ;

import java.io.File;

import net.imglib2.Cursor;
import net.imglib2.exception.IncompatibleTypeException;
import net.imglib2.img.Img;
import net.imglib2.img.display.imagej.ImageJFunctions;
import net.imglib2.io.ImgIOException;
import net.imglib2.io.ImgOpener;
import net.imglib2.type.Type;
import net.imglib2.type.numeric.real.FloatType;

/**
 * Here we want to copy an Image into another one using a generic method
 *
 * @author Stephan Preibisch &amp; Stephan Saalfeld
 *
 */
public class Example2a
{
	public Example2a() throws ImgIOException, IncompatibleTypeException
	{
		// define the file to open
		File file = new File( "DrosophilaWing.tif" );

		// open with ImgOpener using an ArrayImgFactory
		Img< FloatType > image = new ImgOpener().openImg( file.getAbsolutePath() );

		// copy the image, as it is a generic method it also works with FloatType
		Img< FloatType > duplicate = copyImage( image );

		// display the copy
		ImageJFunctions.show( duplicate );
	}

	/**
	 * Generic, type-agnostic method to create an identical copy of an Img
	 * 
	 * @param input - the Img to copy
	 * @return - the copy of the Img
	 */
	public < T extends Type< T > > Img< T > copyImage( final Img< T > input )
	{
		// create a new Image with the same properties
		Img< T > output = input.factory().create( input, input.firstElement() );

		// create a cursor for both images
		Cursor< T > cursorInput = input.cursor();
		Cursor< T > cursorOutput = output.cursor();

		// iterate over the input cursor
		while ( cursorInput.hasNext())
		{
			// move both forward by one pixel
			cursorInput.fwd();
			cursorOutput.fwd();

			// set the value of this pixel of the output image to the same as the input,
			// every Type supports T.set( T type )
			cursorOutput.get().set( cursorInput.get() );
		}

		// return the copy
		return output;
	}

	public static void main( String[] args ) throws ImgIOException, IncompatibleTypeException
	{
		// open an ImageJ window
		new ImageJ();

		// run the example
		new Example2a();
	}
}
</source>
