<h1>Clojure tutorial for ImageJ</h1>

<p>Check out [http://clojure.sourceforge.net clojure web site] and particularly the chapter on [http://clojure.sourceforge.net/reference/java_interop.html Java interoperability].</p>

<h3>Language basics</h3>
<p>A ';' defines the start of a comment, just like '//' does in Java.</p>
<p>A function definition declares parameters within [].</p>
<p>Local variables are declared with <i>let</i>, and global variables with <i>def</i>.</p>
<p>Functions are defined with <i>defn</i>, and are visible globally. Hence a function declared within a <i>let</i> statement has access to variables declared in it. This method enables closures.</p>
<p></p>

<h3>Calling methods and variables on a java object</h3>
<p>There are two ways, the second syntactic sugar of the first. Below, <b>imp</b> is a pointer to an ImagePlus:</p>
<pre>
; java-ish way:
(. imp (getProcessor))

; lisp-ish way:
(.getProcessor imp)
</pre>

<p>To call a method on an object returned by a method call, there is a simplified way:</p>
<pre>
; double way:
(. (. imp (getProcessor)) (getPixels))

; simplified double way:
(.. imp (getProcessor) (getPixels))

; or lisp-ish way:
(.getPixels (.getProcessor imp))
</pre>

<p>To call a variable or 'field', just do it like a method call but without the parentheses:</p>
<pre>
(. imp changes)

(. ij.plugin.filter.PlugInFilter DOES_ALL)
</pre>
<p>Above, notice how a class name is used instead of a pointer to call static fields.</p>

<p>To enhance readability, use <i>import</i> when appropriate. Imports remain visibile throughout the current namespace:</p>
<pre>
(import '(java.awt Color Rectangle)
        '(ij.plugin.filter PlugInFilter))

(new Rectangle 0 0 500 500)

(. PlugInFilter DOES_ALL)
</pre>

<p>Choose whatever matches your mental schemes best.</p>


<h3>Defining variables: obtaining the current image</h3>
As a local variable <b>imp</b> declared within a <i>let</i> statement:
<pre>
(let [imp (. ij.WindowManager (getCurrentImage))]
    ; print its name
    (println (. imp (getTitle))))

; Variable imp NOT visible from outside let statement:
(println (. imp (getTitle)))
---&gt; ERROR
</pre>
<p>As a general variable visible from the entire namespace:</p>
<pre>
(def *imp* (. ij.WindowManager (getCurrentImage)))

(println (. *imp* (getTitle)))

; Alternative syntax
(println (.getTitle *imp*))
</pre>
<p>By convention, in lisp global variables are written with asterisks in the name.</p>
<br />
<p>A <i>let</i> statement lets you declare any number of paired variable name / values, even referring to each other in sequence:</p>
<pre>
(let [imp (. ij.WindowManager (getCurrentImage))
      ip (. imp (getProcessor))
      pix (. ip (getPixels))
      pix2 (.. imp (getProcessor) (getPixels))]
    ; do some processing ...
    (println (str "number of pixels: " (count pix))))
</pre>
<p>Any number of <i>let</i> statements may be nested together:</p>
<pre>
(let [imp (. ij.WindowManager (getCurrentImage))]
    ; do whatever processing here
    (let [ip (. imp (getProcessor)]
        ; print first pixel
	(println (str (. ip (getPixel 0 0)))))))
</pre>


<h3>Defining a closure</h3>
<p>In the following a function is declared within the scope of the local variable <b>rand</b>, which contains an instance of java.util.Random. All calls to the function <i>rand-double</i> will use the same random number generator instance with seed 69997.</p>
<p>The <i>dotimes</i> loop will then print 10 different pseudo-random numbers. If the <b>rand</b> was a new Random with seed 69997 every time, all 10 numbers would be exactly the same.</p>
<p>You can think of a function inside a closure as a static function using a static variable (in Java), but it's more than that, since the function will be able to access parameters on the global namespace and also in any other local namespace in which the <i>let</i> is declared. For example, another <i>let</i>, or even another <i>defn</i>!</p>
<pre>
(let [rand (new java.util.Random 69997)]
    (defn rand-double []
        (. rand (nextDouble))))

(dotimes i 10
    (println (rand-double)))
</pre>

<h3>Looping an array of pixels</h3>
<p>For example, to find the min and max values:</p>
<pre>
; Obtain the pixels array from the current image
(let [imp (. ij.WindowManager (getCurrentImage))
      pixels (.. imp (getProcessor) (getPixels))
      min (apply min pixels)
      max (apply max pixels)]
    (println (str "min: " min ", max: " max)))
</pre>

<p>The above code does not explicitly loop the pixels: it simply applies a function to an array.</p>
<p>To loop pixels one by one, use any of the following:</p>
<pre>
(let [imp (.getCurrentImage ij.WindowManager)
      pixels (.. imp (getProcessor) (getPixels))]

      ; First loop with "dotimes"
      (dotimes i (count pixels)
          (println (aget pixels i)))

      ; Second loop: with "loop -- recur"
      (loop [i 0
             len (count pixels)]
         (if (&lt; i len)
            (let [pix (aget pixels i)]
                (println (str i ": " pix))
                (recur (inc i)
                       len))))

</pre>                                                                                                                                                                                                                
<p>Above, notice that the <i>loop -- recur</i> construct is essentially a <i>let</i> declaration, with a second call (<i>recur</i>) to reset the variables to something else. In this case, the next index in the array. Note how the len is simply given the same value over and over, just to avoid calling <i>(count pixels)</i> at each iteration.</p>
                                                                                                                                                                                                                      
<h3>Executing commands from the menus</h3>                                                                                                                                                                            
<p>Any ImageJ menu command may be run on the active image:</p>                                                                                                                                                        
<pre>                                                                                                                                                                                                                 
(.doCommand ij.IJ "Add Noise")                                                                                                                                                                                        
</pre>                                                                                                                                                                                                                
<p>Be aware that the above starts a new Thread and forks. For reliable control, try the run method, which will wait until the plugin finishes execution.</p>
<pre>
(.run ij.IJ "Add Noise")                                                                                                                                                                                              
</pre>

<h3>Creating and using Clojure scripts as ImageJ plugins</h3>
<p>Simply create a text file with the script inside, and place it in the plugins menu or any subfolder. Then call Plugins - Scripting - Refresh Clojure Scripts to make it appear on the menus.</p>

<p>If the macros/StartupMacros.txt includes a call to the Refresh Clojure Scripts inside the AutoRun macro, then all your Clojure scripts will appear automatically on startup.</p>

<p>To modify an script which exists already as a menu item, simply edit its file and run it by selecting it from the menus. No compiling necessary, and no need to call Refresh Clojure Scripts either (ther latter only for new scripts or at start up.)</p>

<p><b>Very important:</b> all scripts and commands from the interpreter will run within the same thread, and within the same clojure context.</p>

<h3>Using java beans for quick and convenient access to an object's fields</h3>
<p>Essentially it's all about using <i>get</i> methods in a trivial way. For example:</p>
<pre>
(let [imp (. ij.WindowManager (getCurrentImage))
      b (bean imp)]
   (println (:title b)
            (:width b)  
            (:height b)))
</pre>                                                                                                                                                                                                                
<p>Eventually Clojure may add support for <i>set</i> methods as well.</p>
