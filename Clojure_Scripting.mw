<h1>Clojure tutorial for ImageJ</h1>

<p>Check out [http://clojure.sourceforge.net clojure web site] and particularly the chapter on [http://clojure.sourceforge.net/reference/java_interop.html Java interoperability].</p>

<p>Clojure is <b>not</b> a scripting language: Clojure compiles directly to JVM bytecode, and thus runs at native speed. Thus one must think of Clojure as a true alternative to Java the language, but much more expressive, flexible and powerful.</p>

<h3>Language basics</h3>
<p>A ';' defines the start of a comment, just like '//' does in Java.</p>
<p>A function definition declares parameters within [].</p>
<p>Local variables are declared with <i>let</i>, and global variables with <i>def</i>.</p>
<p>Functions are defined with <i>defn</i>, and are visible globally. Hence a function declared within a <i>let</i> statement has access to variables declared in it. This method enables closures.</p>
<p></p>

<h3>Calling methods and variables on a java object</h3>
<p>There are two ways, the second syntactic sugar of the first. Below, <b>imp</b> is a pointer to an ImagePlus:</p>

<source lang="lisp">
; java-ish way:
(. imp (getProcessor))

; lisp-ish way:
(.getProcessor imp)
</source>

<p>To call a method on an object returned by a method call, there is a simplified way:</p>

<source lang="lisp">
; double way:
(. (. imp (getProcessor)) (getPixels))

; simplified double way:
(.. imp (getProcessor) (getPixels))

; or lisp-ish way:
(.getPixels (.getProcessor imp))
</source>

<p>To call a variable or 'field', just do it like a method call but without the parentheses:</p>

<source lang="lisp">
(. imp changes)
</source>
or more lisp-ish:

<source lang="lisp">
(.changes imp)
</source>

<p>To enhance readability, use <i>import</i> when appropriate. Imports remain visible throughout the current namespace:</p>

<source lang="lisp">
(import '(java.awt Color Rectangle)
        '(ij.plugin.filter PlugInFilter))

(new Rectangle 0 0 500 500)
; It's the same as:
(Rectangle. 0 0 500 500)

(. PlugInFilter DOES_ALL)
; or since it's a static field, call like a namespace:
(PlugInFilter/DOES_ALL)
</source>

<p>Choose whatever matches your mental schemes best.</p>

<h3>Calling static fields and methods: namespace syntax</h3>

<p>To call a <b>static</b> field or method, use namespace syntax:</p>

<source lang="lisp">
(ij.plugin.filter.PlugInFilter/DOES_ALL)

(ij.IJ/log "Some logged text")
</source>

<p>Above, notice how a class name is used instead of a pointer to call static fields and methods. Static fields and methods are just variables and functions that exist within the namespace of the class in which they are declared. Hence Clojure's namespace syntax makes way more sense than java code, that doesn't do such distinction and allows for loads of confusion (java allows invoking static methods and fields using a pointer to an instance of the class in which such static methods and fields are declared).</p>

<h3>Defining variables: obtaining the current image</h3>
As a local variable <b>imp</b> declared within a <i>let</i> statement:

<source lang="lisp">
(let [imp (ij.WindowManager/getCurrentImage)]
    ; print its name
    (println (.getTitle imp)))

; Variable imp NOT visible from outside let statement:
(println (.getTitle imp))
---&gt; ERROR
</source>
<p>As a general variable visible from the entire namespace:</p>

<source lang="lisp">
(def *imp* (ij.WindowManager/getCurrentImage))

(println (.getTitle *imp*))
</source>
<p>By convention, in lisp global variables are written with asterisks in the name.</p>
<br />
<p>A <i>let</i> statement lets you declare any number of paired variable name / values, even referring to each other in sequence:</p>

<source lang="lisp">
(let [imp (ij.WindowManager/getCurrentImage)
      ip (.getProcessor imp)
      pix (.getPixels ip)
      pix2 (.getPixels (.getProcessor imp))]
    ; do some processing ...
    (println (str "number of pixels: " (count pix))))
</source>
<p>Any number of <i>let</i> statements may be nested together:</p>

<source lang="lisp">
(let [imp (ij.WindowManager/getCurrentImage)]
    ; do whatever processing here
    (let [ip (.getProcessor imp]
        ; print first pixel
	(println (str (.getPixel ip 0 0))))))
</source>

<h3>Creating objects: invoking constructors</h3>

A constructor is invoked by adding a dot '.' to the name of a class, followed by the arguments. Below, we create an ImageProcessor and then an ImagePlus with it, and finally we print the ImagePlus, which invokes toString() on it (like in java):

<source lang="lisp">
(let [ip (ij.process.ByteProcessor. 400 400)
      imp (ij.ImagePlus. "my image" ip)]
  (println imp))
</source>

An alternative syntax is to use the java-like <i>new</i> keyword, but it's unnecessarily verbose:

<source lang="lisp">
(let [ip (new ij.process.ByteProcessor 400 400)
      imp (new ij.ImagePlus "my image" ip)]
  (println imp))
</source>


<h3>Defining a closure</h3>
<p>In the following a function is declared within the scope of the local variable <b>rand</b>, which contains an instance of java.util.Random. All calls to the function <i>rand-double</i> will use the same random number generator instance with seed 69997.</p>
<p>The <i>dotimes</i> loop will then print 10 different pseudo-random numbers. If the <b>rand</b> was a new Random with seed 69997 every time, all 10 numbers would be exactly the same.</p>
<p>You can think of a function inside a closure as a static function using a static variable (in Java), but it's more than that, since the function will be able to access parameters on the global namespace and also in any other local namespace in which the <i>let</i> is declared. For example, another <i>let</i>, or even another <i>defn</i>!</p>

<source lang="lisp">
(let [rand (java.util.Random. 69997)]
    (defn rand-double []
        (.nextDouble rand)))

(dotimes i 10
    (println (rand-double)))
</source>

<p>Above, note the dot '.' after Random, which indicates we are calling the constructor (with a single parameter 69997, the pseudorandom generator seed to be used). Alternatively, one may use the java-like syntax: (new java.util.Random 69997) -- note the absence of a dot now.</p>

<h3>Looping an array of pixels</h3>
<p>For example, to find the min and max values:</p>

<source lang="lisp">
; Obtain the pixels array from the current image
(let [imp (ij.WindowManager/getCurrentImage)
      pixels (.. imp (getProcessor) (getPixels))
      min (apply min pixels)
      max (apply max pixels)]
    (println (str "min: " min ", max: " max)))
</source>

<p>The above code does not explicitly loop the pixels: it simply applies a function to an array.</p>
<p>To loop pixels one by one, use any of the following:</p>

<source lang="lisp">
(let [imp (ij.WindowManager/getCurrentImage)
      pixels (.. imp (getProcessor) (getPixels))]

      ; First loop with "dotimes"
      (dotimes i (count pixels)
          (println (aget pixels i)))

      ; Second loop: with "loop -- recur"
      (loop [i 0
             len (count pixels)]
         (if (&lt; i len)
            (let [pix (aget pixels i)]
                (println (str i ": " pix))
                (recur (inc i)
                       len))))

</source>                                                                                                                                                                                                                
<p>Above, notice that the <i>loop -- recur</i> construct is essentially a <i>let</i> declaration, with a second call (<i>recur</i>) to reset the variables to something else. In this case, the next index in the array. Note how the len is simply given the same value over and over, just to avoid calling <i>(count pixels)</i> at each iteration.</p>

<p>Of course, there are lispier ways to loop an array of pixels. For example, to obtain the average of all pixels, we can use function <i>reduce</i>, which takes the first two elements of a list, applies a function to them, and then applies the function to the result and the next element, etc:</p>

<source lang="lisp">
(let [fp (.getProcessor (ij.IJ/getImage))
      pix (.getPixels fp)]
   (if (instance? ij.process.FloatProcessor fp)
      (println "Average pixel intensity" (/ (reduce + pix) (count pix)))
      (println "Not a 32-bit image")))
</source>

<p>Above, notice that one could have used also <i>apply</i> to apply <i>+</i> to all element of an array, with the same result:</p>
<source lang="lisp">
      (println "Average pixel intensity" (/ (apply + pix) (count pix)))
</source>

<p>To sum all pixels in an 8-bit image, one needs first to bit-and all bytes to 255, so they become integers and can be summed. But of course we should not <i>bit-and</i> the sum! To solve this, <i>reduce</i> accepts a first value (in this case, zero):</p>

<source lang="lisp">
(let [bp (.getProcessor (ij.IJ/getImage))
      pix (.getPixels bp)]
  (if (instance? ij.process.ByteProcessor bp)
    (println "Average intensity: " (float (/ (reduce (fn [x1 x2] (+ x1 (bit-and x2 255))) 0 pix) (count pix))))
    (println "Not an 8-bit image")))
</source>

<p>It could even be done using a local variable, but it's ugly and undesirable (why create it when it's not really needed)? Notice we need to create the local variable "sum" because variables declared by <i>let</i> are immutable.</p>

<source lang="lisp">
(let [bp (.getProcessor (ij.IJ/getImage))
      pix (.getPixels bp)]
  (if (instance? ij.process.ByteProcessor bp)
    (with-local-vars (sum 0)
      (doseq pixel pix
        (var-set sum (+ (var-get sum) (bit-and pixel 255))))
      (println (float (/ (var-get sum) (count pix)))))
    (println "Not an 8-bit image")))
</source>

<h3>Executing commands from the menus</h3>                                                                                                                                                                            
<p>Any ImageJ menu command may be run on the active image:</p>                                                                                                                                                        
<source lang="lisp">
(ij.IJ/doCommand "Add Noise")                                                                                                                                                                                        
</source>                                                                                                                                                                                                                
<p>Be aware that the above starts a new Thread and forks. For reliable control, try the run method, which will wait until the plugin finishes execution.</p>
<source lang="lisp">
(ij.IJ/run "Add Noise")                                                                                                                                                                                              
</source>

<h3>Creating and using Clojure scripts as ImageJ plugins</h3>
<p>Simply create a text file with the script inside, and place it in the plugins menu or any subfolder. Then call Plugins - Scripting - Refresh Clojure Scripts to make it appear on the menus.</p>

<p>If the macros/StartupMacros.txt includes a call to the Refresh Clojure Scripts inside the AutoRun macro, then all your Clojure scripts will appear automatically on startup.</p>

<p>To modify an script which exists already as a menu item, simply edit its file and run it by selecting it from the menus. No compiling necessary, and no need to call Refresh Clojure Scripts either (ther latter only for new scripts or at start up.)</p>

<p><b>Very important:</b> all scripts and commands from the interpreter will run within the same thread, and within the same clojure context.</p>

<h3>Using java beans for quick and convenient access to an object's fields</h3>
<p>Essentially it's all about using <i>get</i> methods in a trivial way. For example:</p>
<source lang="lisp">
(let [imp (ij.WindowManager/getCurrentImage)
      b (bean imp)]
   (println (:title b)
            (:width b)  
            (:height b)))
</source>                                                                                                                                                                                                                
<p>Eventually Clojure may add support for <i>set</i> methods as well.</p>

<h1>Examples</h1>

<h3>Fixing overexposed images: setting a pixel value to a desirable one for all overexposed pixels</h3>

The problem: [http://ami.scripps.edu/software/leginon/ Leginon] or the Gatan TEM camera acquired an overexposed image, and set all pixels beyond range to zero.

The solution: iterate all pixels; if the pixel is zero then set it to a desirable value, such as the maximum value of the main curve in the histogram (push 'auto' on the Brightness and Contrast dialog to see it.)

In the example below, the <i>fix</i> function is called with the current image and the value 32500 as a floating point number. Notice also the type definition (which is optional) of the float pixel array, to enhance execution speed:

<source lang="lisp">

 ; Assumes a FloatProcessor image
 (defn fix [imp max]
 (let [#^floats pix (.getPixels (.getProcessor imp))]
   (loop [i (int 0)]
     (if (< i (alength pix))
       (do
         (if (= 0 (aget pix i)) (aset pix i (float max)))
         (recur (inc i)))))))
 
 (let [imp (ij.IJ/getImage)]
   (fix imp (float 32500))
   (.updateAndDraw imp))
</source>

<h3>Creating a script for ImageJ</h3>

Simply write the clojure script in a text file, and follow these conventions:

 1. Add an underscore "_" to its file name, and the extension ".clj": fix_leginon_images.clj
 2. Save it under fiji/plugins/ folder, or a subfolder.

When done, just run the "PlugIns/Scripting/Refresh Clojure Scripts" plugin.

Once saved and in the menus, you need <b>not</b> call refresh scripts ever again for that script. Just edit and save it's text file, and run it again from the menus. Next time Fiji opens, the script will automatically appear in the menus.

See [[Scripting Help]] for more details, including how to use the built-in dynamic interpreter.

<h3>Example Clojure plugins included in Fiji</h3>
Open the plugins/Examples/ folder in Fiji installation directory. You'll find three Clojure examples:

* [http://pacific.mpi-cbg.de/cgi-bin/gitweb.cgi?p=fiji.git;a=blob;f=plugins/Examples/Multithreaded_Image_Processing.clj;hb=HEAD Multithreaded_Image_Processing.clj]: illustrate, with macros (via [http://clojure.org/macros#toc9 defmacro]), how to automatically multithread the processing of an image using arbitrary subdivision of the image, such as one line per thread, for as many threads as cores the CPU has.
* [http://pacific.mpi-cbg.de/cgi-bin/gitweb.cgi?p=fiji.git;a=blob;f=plugins/Examples/blend_two_images.clj;hb=HEAD blend_two_images.clj]: illustrates how to open two images from an URL, and blend the gray image into each channel of the color image.
* [http://pacific.mpi-cbg.de/cgi-bin/gitweb.cgi?p=fiji.git;a=blob;f=plugins/Examples/celsius_to_fahrenheit.clj;hb=HEAD celsius_to_fahrenheit.clj]: illustrates the usage of a Swing GUI, and how to instantiate anonymous classes from an interface (via [http://clojure.org/java_interop#toc20 proxy] Clojure function). This example is taken from the [http://clojure.org/jvm_hosted Clojure website].
* [http://pacific.mpi-cbg.de/cgi-bin/gitweb.cgi?p=fiji.git;a=blob;f=plugins/Examples/random_noise_example.clj;hb=HEAD random_noise_example.clj]: illustrates how to declare a function inside a closure (for private access to, in this case, a unique instance of a random number generator), and then fill all pixels of a ByteProcessor image with a random byte value.
* [http://pacific.mpi-cbg.de/cgi-bin/gitweb.cgi?p=fiji.git;a=blob;f=plugins/Examples/Command_Launchers/Command_Launcher_Clojure.clj;hb=HEAD Command_Launcher_Clojure.clj]: illustrates how to create a GUI with a KeyListener, so that the typed text changes color from red to black when it matches the name of an ImageJ command. This example is also under the [[Scripting comparisons]], along equivalent versions written in Java, [[Jython Scripting|Jython]], [[Javascript_Scripting|Javascript]] and [[JRuby_Scripting|JRuby]].


<h1>Appendix</h1>

<h3>Defining the output stream</h3>
The default output stream is at variable <i>*out*</i>. The Clojure Interpreter binds it to the PrintWriter that prints to the interpreter text area, by executing any typed in code within the following binding:
<source lang="lisp">
(binding [*out* (Clojure.Clojure_Interpreter/getStdOut)]
   ; any typed input here
   )
</source>

<h3>Namespaces</h3>
* To list all existing namespaces:
<source lang="lisp">
>>> (all-ns)
(#<Namespace: xml> #<Namespace: zip> #<Namespace: clojure> #<Namespace: set> #<Namespace: user>)
</source>

* To list all functions and variables of a specific namespace, first get the namespace object by name:
<source lang="lisp">
(ns-map (find-ns 'xml))
</source>
Note above the quoted string "xml" to avoid evaluating it to a (non-existing) value.

* To list all functions and variables of all namespaces:
<source lang="lisp">
(map ns-map (all-ns))
</source>

<h3>Forget/Remove all variables from a namespace</h3>
To forget all variables from the user namespace, do:
<source lang="lisp">
(map #(ns-unmap 'user %)
     (keys (ns-interns 'user)))
</source>
The above maps the function <i>ns-unmap</i> to each variable name declared in the <i>user</i> namespace (using # to create a [[Clojure_Scripting#Lambda functions|lambda function]]), which is the same as the prompt namespace. To get the names of the variables, we use <i>ns-interns</i> to retrieve the map of variable names versus the variable contents, and extract the keys from it into a list.

<i>Thanks to AWizzArd from #clojure at irc.freenode.net for the tip.</i>

<h3>JVM arguments</h3>
* To get the arguments passed to the JVM, see contents of variable *command-line-args*
<source lang="lisp">
(println *command-line-args*)
</source>

<h3>Reflection</h3>
* To list all methods of an object:

<source lang="lisp">
(defn print-java-methods [obj]
  (doseq method (seq (.getMethods (if (= (class obj) java.lang.Class)
                                    (identity obj)
                                    (class obj))))
    (println method)))
 
 ; Inspect an object named imp, perhaps an image
 (print-java-methods imp)

 public synchronized boolean ij.ImagePlus.lock()
 public void ij.ImagePlus.setProperty(java.lang.String,java.lang.Object)
 public java.lang.Object ij.ImagePlus.getProperty(java.lang.String)
 ...
</source>

* To list constructors, just use <i>.getConstructors</i> instead of <i>.getMethods</i>.

(Thanks to Craig McDaniel for posting the above function to Clojure's mailing list.)

<h3>Lambda functions</h3>
<h4>Declaration</h4>
* To declare functions on the fly, lambda style, with regex for arguments:

For example, declare a function that takes 2 arguments, and returns the value of the first argument divided by 10, and multiplied by the second argument:
<source lang="lisp">
(let [doer #(* (/ %1 10) %2)]
  (doer 3 2))
</source>
Of course there's no need to name the function, the above is just for illustration.

<h4>Mapping a function to all elements in a list</h4>

* To declare a nameless function, and apply it to each element of a list:
In this case, increment by one each value of a list from 0 to 9:
<source lang="lisp">
(let [numbers (range 10)
      add-one (fn [x] (+ x 1))]
  (map add-one numbers))
</source>
There is no need to declare the names, the above is just for illustration.
Above, we could have defined the function as #(+ %1 1):
<source lang="lisp">
(map #(+ %1 1) (range 10))
</source>
... or of course use the internal function <i>inc</i> which does exactly that:
<source lang="lisp">
(map inc (range 4))
</source>
Beware that the <i>map</i> function above applies the given function to each element of a list, and returns a <b>new</b> list with the results.

<h3>Built-in documentation</h3>
Use the function <i>doc</i> to query any other function. For example, the list generator function <i>range</i>:
<source lang="lisp">
(doc range)

-------------------------
clojure/range
([end] [start end] [start end step])
  Returns a lazy seq of nums from start (inclusive) to end
  (exclusive), by step, where start defaults to 0 and step to 1.
</source>
Above, notice the function has three groups of possible arguments, denoted in brackets.

<h3>A fibonacci sequence: lazy and infinite sequences</h3>

A beautiful example of using lazy sequences and applying functions to one or more sequences at a time.

Below, the sequence <i>fibs</i> is defined in such a way that it contains all possible [http://en.wikipedia.org/wiki/Fibonacci_number fibonacci numbers]. Since such sequence is infinite, we declared it as <i>lazy</i> sequence, that creates new elements only when they are asked for.

The <i>lazy-cat</i> clojure function creates such lazy sequence by concatenation of two sequences: the first sequence is <i>0, 1</i> (which takes the role of feeder or initialization sequence), and the second sequence is the result of a <i>map</i> operation over two subsets of the <i>fibs</i> sequence itself: the full and the full minus the first element (hence the <i>rest</i> operation to obtain the list of all elements without the first).

A <i>map</i> operation applies a function to each element of a sequence, or, when two or more sequences are provided, to the corresponding elements: those at index 0 in all sequences, those at index 1 in all sequences, etc.

To generate the fibonacci sequence of numbers, a sum <i>+</i> operation is mapped to the numbers contained in the <b>self sequence</b> <i>fibs</i> and to the corresponding elements of the self sequence <i>fibs</i> minus the first element, i.e. <b>shifted by one</b>.

In short, the lazy sequence <i>fibs</i> is an abstract way of representing a potentially infinite sequence, with an implementation containing a full abstract definition of <b>all</b> fibonacci numbers.

Then we just <i>take</i> the first 10 elements of such lazy sequence, which are created on the fly.

<source lang="lisp">
(def fibs (lazy-cat [0 1]
                    (map + fibs (rest fibs))))

(take 10 fibs)
</source>
Which outputs:
 (0 1 1 2 3 5 8 13 21 34)

<h3>Creating shallow and deep sequences from java arrays</h3>

Many clojure functions take sequences, not native java arrays, as arguments. A java native array can be wrapped by a shallow sequence like the following:

 >>> (def pixels (into-array (range 10)))
 #'user/pixels
 >>> pixels
 [Ljava.lang.Integer;@f30d8e
 >>> (def seq-pix (seq pixels))
 #'user/seq-pix
 >>> seq-pix
 (0 1 2 3 4 5 6 7 8 9)

Now if we modify the native array, the sequence will reflect that change too when read:
 >>> (aset pixels 3 99)
 99
 >>> seq-pix
 (0 1 2 99 4 5 6 7 8 9)

The array was <b>not</b> duplicated. The only new object created was the shallow sequence:
 >>> (class seq-pix)
 clojure.lang.ArraySeq

To create a true deep duplicate of the array, one can do:
 >>> (def pixels2 (vec pixels))
 #'user/pixels2
 >>> (class pixels2)
 clojure.lang.LazilyPersistentVector
 >>> pixels2
 [0 1 2 99 4 5 6 7 8 9]
 >>> (def seq-pix2 (seq pixels2))
 #'user/seq-pix2
 >>> (class seq-pix2)
 clojure.lang.APersistentVector$Seq

Or, in short:
 (def seq-pix2 (seq (vec pixels)))
 #'user/seq-pix2

So now any changes to the original <i>pixels</i> array will not affect the new sequence:
 >>> (aset pixels 3 101)
 101
 >>> seq-pix2
 (0 1 2 99 4 5 6 7 8 9)

<i>Thanks to Chouser and wwmorgan for examples on #clojure at irc.freenode.net</i>

[[Category:Scripting]]
