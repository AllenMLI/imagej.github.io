{{Infobox
| name                   = BoneJ experimental
| software               = ImageJ
| logo                     = [[File:Bonej-icon.png|96px]]
| author                 = {{Person|Michaeldoube}}, {{Person|Rdom}}, {{Person|Alessandro Felder}}
| maintainer             = {{Person|Michaeldoube}}, {{Person|Rdom}}, {{Person|Alessandro Felder}}
| source                 = {{GitHub|org=bonej-org|repo=BoneJ2}}
| released               = Dec 11<sup>th</sup>, 2017
| latest version         = cuneiform-experimental, Jun 28<sup>th</sup>, 2018
| status                 = Active, Experimental
}}
BoneJ is a collection of skeletal biology plug-ins for ImageJ.
This is the new experimental, modernized version of the software available through the ImageJ [http://imagej.net/Updater updater]. Its update site is called [http://sites.imagej.net/BoneJ BoneJ experimental]. For the old ImageJ1 version, see [[BoneJ]].

This version works with the latest Fiji, and complies with the modern ImageJ [[architecture]]. Most plug-ins also now support hyperstacks, i.e. images with multiple channels or time frames.

As the code is still experimental, it's still likely to change a lot. This means any scripts using the code might break, results can change, and plug-ins gain and lose parameters. Tools marked with ''WIP'' (work in progress), are more likely to undergo large changes. 

Below is the documentation for the plug-ins included in BoneJ experimental.

== Installation ==
[[File:Install-bonej.png|400 px|Installation steps]]
# [http://imagej.net/Downloads Download] the latest version of Fiji for your operating system
# Launch Fiji
# Select in the menu ''Help'' &gt; ''Update...''
# Click ''Manage update sites``
# Check ''BoneJ experimental``
# Click ''Close''
# Click ''Apply changes''
After the downloads have finished, close and restart Fiji.

== Analyse skeleton ==
Menu path ''Plugins &gt; BoneJ &gt; Analyse skeleton''.

This plug-in simply includes [[AnalyzeSkeleton]] in BoneJ. It adds some additional validation to check that your image suits the tool. It also skeletonizes your image by calling [[Skeletonize3D]] if needed.

==== Suitable images ====
The input image must be 2D or 3D, 8-bit and binary. Hyperstacks are not supported.

==== Differences to BoneJ1 ====
Calls the latest version of [[AnalyzeSkeleton]].

== Area/Volume fraction ==
Menu path ''Plugins &gt; BoneJ &gt; Fraction &gt; Area/Volume fraction''

''Area/Volume fraction'' calculates the fraction of bone in an image by it to the whole image. It counts all the foreground voxels, which it assumes represent bone, and compares them to the total number of voxels in the image. More formally defined, the plug-in calculates the fraction ''BV/TV'', which is the volume of mineralised bone ''BV'' per unit volume of the sample ''TV''. In case of a 2D image, it calculates the fraction ''BA/TA'', which is the area of bone per unit area of the sample.

==== Suitable images ====
A 2D or 3D binary image

==== Results ====
* '''Bone volume''': volume of the bone voxels.
* '''Total volume''': volume of the whole image.
* '''Volume ratio''': ratio of bone to total volume.

The measures are reported separately for each 2D/3D subspace in the image, i.e. for each channel and time frame. Results will be for ''area'' if image is 2D.

==== Differences to BoneJ1 ====
* In BoneJ1 the plug-in was called ''Volume fraction''
* Can process 2D images
* Supports hyperstacks 

== Calibrate SCANCO (WIP) ==
Menu path ''Plugins &gt; BoneJ &gt; Analyze &gt; Calibrate SCANCO''

Applies the ''mg HA/ccm'' pixel value calibration, i.e. ''HU'' or Hounfield unit calibration  stored in the .isq format metadata to the image.

==== Suitable images ====
An .isq format image generated by Scanco X-ray microtomography scanners.

== Check voxel depth (WIP) ==
Menu path ''Plugins &gt; BoneJ &gt; Stacks &gt; Check Voxel Depth''

Checks whether slice spacing has been calibrated correctly. Some DICOM images contain slice thickness data in the header information, but thickness is not necessarily the same as the physical distance between consecutive slices' positions.

==== Suitable images ====
A 3D image.

== Connectivity ==
Menu path ''Plugins &gt; BoneJ &gt; Connectivity''.

The Connectivity plug-in is designed to estimate the number of connected structures i.e. trabeculae in a trabecular network. This ''connectivity'' measure is related to a topological number <math>\chi</math> known as ''Euler characteristic'', ''Euler number'' or ''Euler-Poincaré characteristic''. Mathematically defined connectivity is <math>= 1 - (\chi + \Delta\chi)</math>. Roughly speaking, <math>\chi</math> describes the shape or structure of a topological space. It can also be expressed as <math>\chi = objects - handles + cavities</math>, where a handle is a hole that goes through an object (e.g the hole in a doughnut, or the ear of a coffee mug), and a cavity is enclosed inside one. When measuring trabecular cubes, you need to add <math>\Delta\chi</math> to <math>\chi</math> to get a more accurate estimate of the connectivity of the whole network. The term <math>\Delta\chi</math> corrects for the change in the topology of an object, when it's cut to pieces. 

NB some other Euler characteristic implementations report <math>\chi + \Delta\chi</math> as <math>\chi</math>, i.e. in them the correction <math>\Delta\chi</math> is implicit.

==== Suitable images ====
The input image must be 3D and binary. The plug-in assumes that there is only one particle in the foreground; to achieve this, run ''Purify''. Having more than one object often leads to negative connectivity.

==== Results ====
* '''Euler characteristic (χ)''': describes the shape of the object(s) in the image, <math>\chi = objects - handles + cavities</math>.
* '''Corrected Euler (χ + Δχ)''': the Euler characteristic of the part corrected for edge effects to fit the whole.
* '''Connectivity''': gives an estimate of the number of connected trabeculae in the image. Equal to <math>1 - (\chi + \Delta\chi)</math>.
* '''Conn. density''': connectivity divided by unit volume. 

The measures are reported separately for each 3D subspace in the image, i.e. for each channel and time frame.

==== Differences to BoneJ1 ====
* Supports hyperstacks
* The old version reported ''Corrected Euler (χ + Δχ)'' incorrectly as ''Δχ''

==== Related publications ====
* Odgaard A, Gundersen HJG (1993), ''Quantification of connectivity in cancellous bone, with special emphasis on 3-D reconstructions'', Bone 14: 173-182, [http://dx.doi.org/10.1016/8756-3282(93)90245-6 doi:10.1016/8756-3282(93)90245-6.]
* Toriwaki J, Yonekura T (2002), ''Euler number and connectivity indexes of a three dimensional digital picture'', [http://www.scipress.org/journals/forma/abstract/1703/17030183.html Forma 17: 183-209]

== Delete slice range (WIP) ==
Menu path ''Plugins &gt; BoneJ &gt; Stacks &gt; Delete slice range''

Removes a range of slices from a stack, so that cropping in the Z direction is practical.

==== Suitable images ====
A 3D image.

== Ellipsoid factor (WIP) ==
Menu path ''Plugins &gt; BoneJ &gt; Ellipsoid factor''.

Ellipsoid Factor is a new method for measuring rod/plate geometry. It uses the axis lengths from prolate, oblate and intermediate elipsoids to determine how prolate or oblate the trabecular space is at a particular point. Highly prolate (javelin-shaped, rod-like) ellipsoids have a single long axis (<math>c</math>) and two short axes (<math>a, b</math>) such that <math>a < b \ll c</math> , whereas highly oblate (discus-shaped, plate-like) ellipsoids have two longer axes (<math>b, c</math>) and one much shorter axis (<math>a</math>) so that <math>a \ll b < c</math>. Calculating <math>EF</math> as the difference in ratios, <math>EF = a/b - b/c</math> leads to a useful scale ranging from <math>-1</math> (oblate, <math>a/b \approx 0, b/c \approx 1</math>) to <math>+1</math> (prolate, <math>a/b \approx 1, b/c \approx 0</math>). <math>EF</math> of <math>0</math> indicates an intermediate ellipsoid where <math>a/b = b/c</math>, which is the case for spheres (<math>a = b = c</math>) and other ellipsoids with axis ratios <math>a:qa:q^{2}a</math>. Ellipsoid Factor runs [[Skeletonize3D]] to get the medial axis of the trabeculae, which is used as the seed for sampling. Ellipsoids are seeded from each voxel on the medial axis. A combination of dilation, contraction, rotation and a small amount of translation is run iteratively until the ellipsoid increases no further in volume.

The EF at a point in the structure is determined as the EF of the most voluminous ellipsoid which contains that point.

If you use Ellipsoid Factor in your work, please cite:
Doube M (2015), ''The Ellipsoid Factor for quantification of rods, plates and intermediate forms in 3D geometries'', Frontiers in Endocrinology, 6:15, [http://journal.frontiersin.org/Journal/10.3389/fendo.2015.00015/abstract doi: 10.3389/fendo.2015.00015]

==== Suitable images ====
A binary 3D image.

==== Parameters ====
* '''Sampling increment''': distance between sample points on each vector; should be less than the pixel spacing.
* '''Vectors''': number of vectors to sample at each seed point.
* '''Skeleton points per ellipsoid''': allows dense or sparse sampling, a value of <math>1</math> means that an ellipsoid is sampled at every seed point.
* '''Contact sensitivity''': how many vectors must touch the background before dilation stops.
* '''Maximum iterations''': how hard to try to find larger ellipsoids - fitting will stop if no improvement has been made after this number of iterations..
* '''Maximum drift''': how far the centroid may be displaced from its seed point.
* '''EF image''': stack containing EF values for each point contained by at least one ellipsoid and NaN elsewhere.
* '''Ellipsoid ID image''': stack containing the ID of the biggest ellipsoid at each point, ranked in descending order (<math>0</math> is the largest ellipsoid).
* '''Volume image''': image showing the volume of the largest ellipsoid containing that point.
* '''Axis ratio images''': images showing <math>a/b</math> and <math>b/c</math> ratios foreach point containing at least one ellipsoid and NaN elsewhere.
* '''Flinn peak plot''': plot of <math>a/b</math> vs <math>b/c</math> weighted by volume, so bright pixels indicate relatively more of the structure has that axis ratio.
* '''Gaussian sigma:''' amount to blur the Flinn peak plot - set to <math>0</math> for a precise but less 'beautiful' result.
* '''Flinn plot''': unweighted Flinn plot - every ellipsoid is represented by the same sized point regardless of ellipsoid size.

==== Results ====
* '''EF image''': stack containing EF values. NaN (not a number) values are used in the background. Summary statistics can be obtained by running Analyze > Histogram
* '''Short-Mid image''': stack containing the <math>a/b</math> ratios
* '''Mid-Long image''': stack contining the <math>b/c</math> ratios
* '''Volume image''': stack containing ellipsoid volumes
* '''Max id image''': stack containing the ID of the largest ellipsoid at each point; IDs relate to the sort order based on volume, so ID = 0 is the largest ellipsoid. <math>-1</math> is foreground and background is labelled with a large negative number.
* '''Flinn diagram''': plot of <math>a/b</math> versus <math>b/c</math> values present in the volume
* '''Weighted Flinn plot''': Flinn diagram with peaks of intensity proportional to volume occupied by each (<math>a/b</math>, <math>b/c</math>) ratio

==== Related publications ====
Salmon PL, Ohlsson C, Shefelbine SJ, Doube M (2015), ''Structure model index does not measure rods and plates in trabecular bone'', Frontiers in Endocrinology, 6:162, [http://dx.doi.org/10.3389/fendo.2015.00162 doi:10.3389/fendo.2015.00162].

== Fit ellipsoid ==
Menu path ''Plugins &gt; BoneJ &gt; Fit ellipsoid''.

Finds the ellipsoid that best fits a set of point or multi-point ROIs in the ROI Manager. ''Fit ellipsoid'' may fail to fit an ellipsoid. The more points you add, the more likely it is to succeed. Points are scaled to the spatial calibration (voxel widht, height &amp; depth) of the input image.

==== Suitable images ====
A 3D image.

==== Parameters ====
* '''ROI Manager''': ROIs with at least nine points in the ROI Manager.

==== Results ====
* '''Radii''': the radii ''a'', ''b'' and ''c'' of the fitted ellipsoid. Radius ''a'' is the shortest and ''c'' the longest.
* '''Centroid''': ''x'', ''y'' and ''z'' coordinates of the ellipsoid centre point.

==== Differences from BoneJ1 ====
* Supports multi-point ROIs.
* Plug-in cancels if an ellipsoid can't be found, instead of reporting invalid results.

== Fit sphere (WIP) ==
Menu path ''Plugins &gt; BoneJ &gt; Fit sphere''.

Finds the sphere that best fits a set of point ROIs, and optionally displays the image data bounded by the sphere in a new image window. Place a set of point ROIs on structures of interest, hitting [T] to add each point to the ROI Manager. Fit Sphere takes the coordinates of the points from the ROI Manager and applies a least-squares optimisation.

==== Suitable images ====
A 3D image.

==== Parameters ====
* '''ROI Manager''': populated with at least 5 point ROI's
* '''Copy Sphere''': Create a new stack containing image data from within the best-fit sphere.
* '''Padding''': Number of black pixels to put between the sphere and the sides of the image
* '''Inner Cube''': Create a new stack containing image data from the cube that just fits inside the best-fit sphere.
* '''Outer Cube''': Create a new stack containing image data from the cube that the best-fit sphere just fits inside.
* '''Crop Factor''': Radius used for generating new images is multiplied by crop factor so that a bigger or smaller volume can be produced.
* '''Add to ROI Manager''': Add the sphere to the ROI Manager as a set of circular ROIs
* '''Clear ROI Manager''': Clear any existing ROIs in the Manager prior to adding circles

==== Results ====
* '''X Centroid''': x-coordinate of sphere's centroid
* '''Y Centroid''': y-coordinate of sphere's centroid
* '''Z Centroid''': z-coordinate of sphere's centroid
* '''Radius''': length of radius
* '''Images (optional)''': images containing a copy of the original data within the sphere, or within cubes bounding or bounded by the sphere.

== Local thickness ==
Menu path ''Plugins &gt; BoneJ &gt; Thickness''.

This plug-in includes [[Local_Thickness]] in BoneJ, and provides some additional options &amp; results. Local thickness measures ''the diameter of the largest sphere that fits inside the object and contains the point'' for each point i.e. foreground voxel in an image. The plug-in calculates mean and standard deviation of the trabecular thickness (Tb.Th) or trabecular spacing (Tb.Sp) directly from pixel values in the resulting thickness map. Foreground voxels are considered trabeculae, and background voxels are the spacing. Processing time is heavily dependent on feature size (in pixels); large features can take a very long time to process.

==== Suitable images ====
The input image must be 3D, 8-bit and binary. Hyperstacks are not supported.

==== Parameters ====
* '''Calculate''': chooses which thickness maps to calculate - trabecular thickness, trabecular spacing, or both. In order to calculate trabecular spacing, the image voxels are inverted.
* '''Show thickness maps''': display the calculated thickness maps or not.
* '''Mask thickness maps''': remove artifacts from the thickness maps. Artifacts are foreground voxels not present in the original image.
* '''Crop to ROI manager''': create thickness maps only from the area bounded by the ROIs in the ROI manager. Checking this option requires you've added ROIs to the ROI manager.

==== Results ====
* The mean and standard deviation for each thickness map calculated.
* Displays thickness map images if ''Show thickness maps'' was selected. 

==== Differences to BoneJ1 ====
* Calls the latest version of [[Local_Thickness]].
* Thickness values for background voxels are marked ''NaN'' instead of ''0''.

==== Related publications ====
* Dougherty R, Kunzelmann K (2007), ''Computing local thickness of 3D structures with ImageJ'', Microsc. Microanal., 13: 1678-1679, [http://dx.doi.org/10.1017/S1431927607074430 doi:10.1017/S1431927607074430]
* Hildebrand T, Rüegsegger P (1997), ''A new method for the model-independent assessment of thickness in three-dimensional images'', J. Microsc., 185: 67-75, [http://dx.doi.org/10.1046/j.1365-2818.1997.1340694.x doi:10.1046/j.1365-2818.1997.1340694.x]

== Moments of inertia (WIP) ==
Menu path: ''Plugins &gt; BoneJ &gt; Moments of Inertia''

Calculates the three orthogonal principal axes and moments of inertia around those axes. It includes pixels with values between upper and lower limits, which can be defined in terms of unitless grey values or Hounsfield units (HU). It optionally creates a new stack with the image centred and rotated so that the principal axes are parallel to the image stack's x, y and z axes. Calculations are limited to a rectangular ROI if one is drawn. The plugin will guess whether the image is HU calibrated, and if so, apply HU limits of bone (0-4000 HU), otherwise it will calculate auto-thresholds based on the stack's histogram. If a calibration curve is known, the coefficients can be added to get weighted calculations. Aligning a bone with Moments of Inertia may be a useful step prior to Slice Geometry if bones are not aligned with the image z axis.

==== Suitable images ====
An 8-bit or 16-bit image.

==== Parameters ====
* '''Start slice''': First slice to include in calculations
* '''End slice''': Last slice to include in calculations
* '''HU Calibrated''': Plugin will guess whether the image is HU calibrated. If image is HU calibrated, make sure the box is checked and enter HU calibrated numeric values in the following fields
* '''Bone Min''': Lower threshold, in either uncalibrated greys or HU
* '''Bone Max''': Upper threshold, in either uncalibrated greys or HU
* '''Slope''': m where physical density = m × pixel value + c
* '''Y Intercept''': c where physical density = m × pixel value + c
* '''Align result''': Draw a new stack with the principal axes parallel to the image axes
* '''Show axes (2D)''': Draw the axes in white on the aligned image
* '''Show axes (3D)''': Display the stack and its principal axes in a 3D Viewer window

==== Results ====
* '''Image (optional)''': a copy of the input image centered and aligned with the principal axes
* '''Xc''': Centroid x-coordinate (mass-weighted by calibrated density)
* '''Yc''': Centroid y-coordinate
* '''Zc''': Centroid z-coordinate
* '''Vol''': Total volume of thresholded voxels
* '''Mass''': Mass of bone, from pixel values and density calibration coefficients
* '''Icxx''': Moment around x axis passing through centroid
* '''Icyy''': Moment around y axis passing through centroid
* '''Iczz''': Moment around z axis passing through centroid
* '''Icxy''': Off-axis term for constructing inertia tensor
* '''Icxz''': Off-axis term for constructing inertia tensor
* '''Icyz''': Off-axis term for constructing inertia tensor
* '''I1''': Moment around the shortest principal axis
* '''I2''': Moment around the middle principal axis
* '''I3''': Moment around the longest principal axis
* '''Verbose output in Log window'''
** '''Eigenvalues''': Result of of eigenvalue decomposition. Moments of inertia
** '''Eigenvectors of principal axes''': orientation of input image
** '''Inverse eigenvector matrix''': used to map voxel positions in the aligned image back to voxel positions in the original image
* Optional 3D display of principal axes

== Purify (WIP) ==
Menu path: ''Plugins &gt; BoneJ &gt; Purify''

Purify locates all particles in 3D and removes all but the largest foreground and background particles.

==== Suitable images ====
The input image must be 3D, 8-bit and binary.

==== Parameters ====
* '''Labelling algorithm''':
** '''Mapped''': Non-recursive, memory efficient and fast.
** '''Multithreaded''': use multiple cores and job chunking to reduce recursion. Fast on small stacks and if you have many CPU cores.
** '''Linear''': Non-recursive but heavy on RAM and single-threaded. Fast on big stacks, but only if you have the memory.
* '''Chunk Size''': number of slices to use in each particle labelling thread. If images are large, set this to 2
* '''Performance Log''': Show verbose performance information to help tune your system
* '''Make copy''': If checked, shows the result in a new window; if unchecked the result replaces the original image.

==== Results ====
* '''Performance metrics (optional)'''
** '''Threads''': Number of CPU cores used
** '''Slices''': Number of slices in the input image stack
** '''Chunks''': Number of chunks of slices, each chunk is processed independently
** '''Chunk size''': Number of slices per chunk
** '''Last chunk size''': size of the last chunk (the remainder chunk)
** '''Duration''': time in seconds to complete purification
* '''Purified image''': optionally in a new image window.

== Skeletonise ==
Menu path ''Plugins &gt; BoneJ &gt;Skeletonise''.

This plug-in simply includes [[Skeletonize3D]] in BoneJ. It adds some additional validation to check that your image suits the tool.

==== Suitable images ====
The input image must be 2D or 3D, 8-bit and binary. Hyperstacks are not supported.

==== Differences to BoneJ1 ====
Calls the latest version of [[Skeletonize3D]].

== Surface fraction ==
Menu path ''Plugins &gt; BoneJ &gt; Fraction &gt; Surface fraction''

''Surface fraction'' calculates the fraction of bone volume in an image by comparing surface meshes created from bone particles and the whole image. A mesh is a collection of triangular faces that defines the shape of an object in 3D graphics. The plug-in assumes that all foreground voxels represent bone. 

More formally defined, ''Surface fraction'' calculates the fraction ''BV/TV'', which is the volume of mineralised bone ''BV'' per unit volume of the sample ''TV''.

==== Suitable images ====
The input image must be 3D and binary.

==== Results ====
* '''Bone volume''': volume of the surface mesh created from bone voxels.
* '''Total volume''': volume of the surface mesh created from the whole image.
* '''Volume ratio''': ratio of bone to total volume.

The measures are reported separately for each 3D subspace in the image, i.e. for each channel and time frame.

==== Differences to BoneJ1 ====
* Supports hyperstacks.
* Results differ, because the marching cubes and mesh volume implementations are different.
* In BoneJ1 this plug-in was called ''Volume fraction''

== Where is my favorite plug-in? ==
We've decided to remove some plug-ins from BoneJ experimental (note that some have just not been documented here yet). These include ''Interpolate ROIs'', ''Neck shaft angle'', ''Optimise threshold'', ''Plateness'' and ''Structure model index'' have been discontinued. ''Dilate'' and ''Erode'' come pre-packaged with ImageJ, so there's no need to include them.

Support for ''Kontron IMG'', ''Scanco ISQ'' and ''Stratec pQCT'' file formats has been moved to [[SCIFIO]]. Just run ''Edit  &gt; Options  &gt; ImageJ2'', and check ''Use SCIFIO when opening files''. When the option is enabled, these kinds of files can be opened from `File > Open` or dragging &amp; dropping them like any other format. 

''Distribution analysis'' and other pQCT related tools can now be downloaded independently from the [[PQCT]] update site.

== License ==
BoneJ experimental is free, open-source software. You can redistribute it and/or modify it under the terms of the [https://github.com/bonej-org/BoneJ2/blob/master/LICENCE.md BSD 2-clause license]. The software is provided "as is" and any warranties are disclaimed. In no event shall the copyright holder or contributors be liable.

== Citation ==
If you'd like to cite the software, we will soon publish a paper about BoneJ experimental. We recommend you cite the specific release used in your research.
