{{scripting}}
== Introduction ==

This page is a primer of '''ImageJ2 only''' Python scripts. It means that the examples included here avoid IJ1 as much as possible, unless it's really necessary.

== Scripts ==

=== Z Projection ===

<source lang='python'>
# @ImageJ ij
# @Dataset data
# @String(label="Projection Type",choices={"Max","Mean","Median","Min", "StdDev", "Sum"}) proj_type


from net.imagej.axis import Axes
from net.imagej.ops import Ops


def proj_method(method):
    return {
        'Max': Ops.Stats.Max,
        'Mean': Ops.Stats.Mean,
        'Median': Ops.Stats.Median,
        'Min': Ops.Stats.Min,
        'StdDev': Ops.Stats.StdDev,
        'Sum': Ops.Stats.Sum,
    }.get(method, Ops.Stats.Max)


def main():

    # Select which dimension to project
    z_dim = data.dimensionIndex(Axes.Z)

    if z_dim == -1:
        print("Z dimension not found.")
        return

    if data.dimension(z_dim) < 2:
        print("Z dimension has only one frame.")
        return

    # Write the output dimensions
    projected_dimensions = [data.dimension(d) for d in range(0, data.numDimensions()) if d != z_dim]

    # Create the output image
    z_projected = ij.op().create().img(projected_dimensions)

    # Create the op and run it
    proj_op = ij.op().op(proj_method(proj_type), data)
    ij.op().transform().project(z_projected, data, proj_op, z_dim)

    # Create a dataset
    z_projected = ij.dataset().create(z_projected)

    # Set the correct axes (is that needed ?)
    axes = [data.axis(d) for d in range(0, data.numDimensions()) if d != z_dim]
    z_projected.setAxes(axes)

    print(z_projected)
    ij.ui().show("z_projected", z_projected)

main()

</source>

=== Apply Threshold ===


<source lang='python'>
# @ImageJ ij
# @Dataset data

method_threshold = "otsu"

# Get the histogram
histo = ij.op().run("image.histogram", data.getImgPlus())

# Get the threshold
threshold = ij.op().run("threshold.%s" % method_threshold, histo)

# Apply the threshold
thresholded = ij.op().run("threshold.apply", data.getImgPlus(), threshold)

# Create output
thresholded = ij.dataset().create(thresholded)

ij.ui().show("thresholded", thresholded))
</source>

A more direct way if you don't need to modify the threshold is:

<source lang='python'>

# @ImageJ ij
# @Dataset data

method_threshold = "otsu"

# Apply the threshold
thresholded = ij.op().run("threshold.%s" % method_threshold, data.getImgPlus())

# Create output
thresholded = ij.dataset().create(thresholded)

ij.ui().show("thresholded", thresholded)
</source>


=== Subtract stack to its first image ===

<source lang='python'>

# @ImageJ ij
# @Dataset data

from net.imglib2.util import Intervals
from net.imagej.axis import Axes
from net.imagej.ops import Ops

# Convert input
converted = ij.op().convert().float32(data.getImgPlus())

# Get the first frame (TODO: find a faser way !)
t_dim = data.dimensionIndex(Axes.TIME)
interval_start = []
interval_end = []
for d in range(0, data.numDimensions()):
	if d != t_dim:
		interval_start.append(0)
		interval_end.append(data.dimension(d) - 1)
	else:
		interval_start.append(0)
		interval_end.append(0)
		
intervals = interval_start + interval_end
intervals = Intervals.createMinMax(*intervals)

first_frame = ij.op().transform().crop(converted, intervals)

# Allocate output memory (wait for hybrid CF version of slice)
subtracted = ij.op().create().img(converted)

# Create the op
sub_op =  ij.op().op("math.subtract", first_frame, first_frame)

# Setup the fixed axis
fixed_axis = [d for d in range(0, data.numDimensions()) if d != t_dim]

# Run the op
ij.op().slice(subtracted, converted, sub_op, fixed_axis)

# Clip image to the input type
clipped = ij.op().create().img(subtracted, data.getImgPlus().firstElement())
clip_op = ij.op().op("convert.clip", data.getImgPlus().firstElement(), subtracted.firstElement())
ij.op().convert().imageType(clipped, subtracted, clip_op)

# Show it
ij.ui().show("subtracted", clipped)
</source>


=== Apply DOG Filter ===

<source lang='python'>
# @ImageJ ij
# @Dataset data

from net.imagej.axis import Axes

sigma1 = 4.2
sigma2 = 1.25

# IJ Ops version

pixel_type = data.getImgPlus().firstElement().class
converted = ij.op().convert().float32(data.getImgPlus())

# Allocate output memory (wait for hybrid CF version of slice)
dog = ij.op().create().img(converted)

# Create the op
dog_op = ij.op().op("filter.dog", converted, sigma1, sigma2)

# Setup the fixed axis
t_dim = data.dimensionIndex(Axes.TIME)
fixed_axis = [d for d in range(0, data.numDimensions()) if d != t_dim]

# Run the op
ij.op().slice(dog, converted, dog_op, fixed_axis)

# Clip image to the input type
clipped = ij.op().create().img(dog, data.getImgPlus().firstElement())
clip_op = ij.op().op("convert.clip", data.getImgPlus().firstElement(), dog.firstElement())
ij.op().convert().imageType(clipped, dog, clip_op)

# Show it
ij.ui().show("dog", clipped)
</source>

=== Apply a mask ===

Given a mask (binary image) and a raw image, remove background pixel from raw by keeping only those in the mase (different from 0).

<source lang='python'>

# @ImageJ ij
# @Dataset data
# @Dataset mask

output = ij.dataset().create(data)

targetCursor = output.localizingCursor()
dataRA = data.randomAccess()
maskRA = mask.randomAccess()

while targetCursor.hasNext():
	targetCursor.fwd()
	dataRA.setPosition(targetCursor)
	maskRA.setPosition(targetCursor)

	if maskRA.get().get() == 0:
		targetCursor.get().set(0)
	else:
		targetCursor.get().set(dataRA.get())

ij.ui().show("output", output)
</source>

=== Retrieve objects/particles from a mask ===

Get a list of <code>LabelRegion</code> and display the center of mass with the IJ1 ROI Manager.

<source lang='python'>
# @ImageJ ij
# @Dataset data
# @Dataset mask

from net.imagej.axis import Axes

from net.imglib2.algorithm.labeling.ConnectedComponents import StructuringElement
from net.imglib2.roi.labeling import LabelRegions

from ij.gui import PointRoi
from ij.plugin.frame import RoiManager

def get_roi_manager(new=False):
	rm = RoiManager.getInstance()
	if not rm:
		rm = RoiManager()
	if new:
		rm.runCommand("Reset")
	return rm

img = mask.getImgPlus()

labeled_img = ij.op().run("cca", img, StructuringElement.EIGHT_CONNECTED)

regions = LabelRegions(labeled_img)
region_labels = list(regions.getExistingLabels())

print("%i regions/particles detected" % len(region_labels))

# Now use IJ1 RoiManager to display the detected regions

rm = get_roi_manager(new=True)
for label in region_labels:
 
    region = regions.getLabelRegion(label)
 
    center = region.getCenterOfMass()
    x = center.getDoublePosition(0)
    y = center.getDoublePosition(1)
 
    roi = PointRoi(x, y)
    if center.numDimensions() >= 3:
        z = center.getDoublePosition(2)
        roi.setPosition(int(z))
     
    rm.addRoi(roi)

    # You can also iterate over the `data` pixel by LabelRegion

	cursor = region.localizingCursor()
	dataRA = data.randomAccess()
	while cursor.hasNext():
		cursor.fwd()
		dataRA.setPosition(cursor)
	
		x = cursor.getDoublePosition(0)
		y = cursor.getDoublePosition(1)

		# Pixel of `data`
		pixel = dataRA.get()

		# Do whatever you want here
		# print(x, y, pixel)
</source>

== Resources ==
* [[Jython_Scripting|Jython Scripting]]
* [[Jython_Scripting_Examples|Jython Examples]]

[[Category:Scripting]]
[[Category:ImageJ2]]
[[Category:Ops]]
[[Category:SciJava]]
