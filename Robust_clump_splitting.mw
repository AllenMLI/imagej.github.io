{{Infobox
| software               = Fiji
| name                   = Robust Clump Splitting
| author                 = {{Person|LouiseBloch}}, {{Person|Twagner}}
| maintainer             = {{Person|LouiseBloch}}, {{Person|Twagner}}
| filename               = ij_robust_split.jar []
| source                 = Github [https://github.com/thorstenwagner/ij-robust-split]
| latest version         = v1.0.0 (04 Sep 2016)
| status                 = active 
}}


== Purpose ==
This plugin is an implementation for concavity-based clump splitting of the algorithms described in:

''Kumar, S., Ong, S.-H., Ranganath, S., Ong, T., und Cheq, F.
(2005). A rule based Approach for robust clump splitting. Pattern Recognition,
39(6), pp.1088–1098.
''

''Farhan, M., Yli-Harja, O., und Niemistö, A. (2013). A novel
method for splitting clumps of convex objects incorporating image intensity and
using rectangular window-based concavity point-pair search. Pattern Recognition,
46(3), pp.741–751.''
 
and

''Wang, H., Zhang, H., und Nilanjan, R. (2011). Clump splitting via
bottleneck detection. IEEE International Conference Image Processing, 2, pp.61–64.''

The plugin provides an alternative to the ImageJ "build-in"-watershed-plugin. It does not perform better results on regular round clumps. Especially for big clumps with image disturbances and many holes in the clump the results of the watershed plugins are much more robust and it does not depends on so many parameters. For elongated indididual objects, the plugin can produce better results than the watershed.

It depends on the [http://imagej.net/IJ_Blob IJ-Blob] library, the [https://github.com/hharrison/vecmath Vecmath] library, the [https://www.csie.ntu.edu.tw/~cjlin/libsvm/ LIBSVM] library and the [http://java-ml.sourceforge.net/ JavaML] library.

==Plugin usage ==
If you start the plugin you can choose between two main uses. Choose if you either want to split clumps of an image or want to train SVM to optimize parameters <math>c_1</math> and <math>c_2</math>. To train the SVM you need to have input data.

[[File:Eingabemaske2.png]]
===Detection Types===
The plugin supports different types of split lines, concavity region detection and concavity pixel detection. If you want to split a clump you have to choose, what kind of detection you want to use.

[[File:PluginScreenshot1.png]]
====Split Lines====
The plugin supports different split line types which should be specified:

'''Straight Split Line:''' The straight split Line is a straight line between two concavity pixels. Use it, if no intensity information for better split lines is available.

[[File:StraightSplitline.png |300px]]

'''Geodesic Distance Split Line:''' The geodesic distance split line uses the path of maximum intensity change between two concavity pixels. It is detected by the algorithm of ''Wang et al.'' Use it, if the individual objects can be distinguished by intensity and the split lines are not too convex.

[[File:GeodesicDistanceSplitLine.png |300px]]

'''Maximum Intensity Split Line:''' The maximum intensity split line uses the path of maximum intensity between two concavity pixels. It is detected by the algorithm of ''Wang et al.'' Use it, if the intensity of the individual objects have higher at the edge, than in the center and the split lines are not too convex.

[[File:MaximumIntensitySplitLine.png |300px]]

'''Minimum Intensity Split Line:''' The minimum intensity split line uses the path of minimum intensity between two concavity pixels. It is detected by the algorithm of ''Wang et al.'' Use it, if the intensity of the individual objects is lower at the edge, than in the center and the split lines are not too convex.

[[File:MinimumIntensitySplitLine.png |300px]]

'''Maximum Intensity Split Line Farhan:''' The maximum intensity split line uses the path of maximum intensity between two concavity pixels. It is detected by the algorithm of ''Wang et al.'' Use it, if the intensity of the individual objects have higher at the edge, than in the center and there are no clumps without intensity information, and the split line does not often change orientation.

[[File:MaximumIntensitySplitLine.png |300px]]

'''Minimum Intensity Split Line Farhan:''' The minimum intensity split line uses the path of minimum intensity between two concavity pixels. It is detected by the algorithm of ''Farhan et al.'' Use it, if the intensity of the individual objects is lower at the edge, than in the center and there are no clumps without intensity information, and the split line does not often change orientation.

[[File:MinimumIntensitySplitLine.png |300px]]

====Concavity Region Detection====
The plugin supports different concavity region detection types. It specifies, in which way a concavity region is detected.

'''Detect outer concavity regions by convex hull:''' The concavity region detection by convex hull corresponds to the algorithm of ''Kumar et al.'' Concavity regions are detected, if there is a difference between convex hull and contour of the clump. Use this detection, if there are few clumps with less complex concavity regions. The blue shaded regions are the detected concavity regions.

[[File:ConvexHull.png |250px]]

'''Detect outer concavity regions locally:''' The local concavity region detection follows algorithm of ''Farhan et al.'' Concavity regions are detected, by iterate along the contour and look for local concavity regions. Use this detection, if there are complex clumps containing of many individual objects.

[[File:Farhan.png |250px]]

====Concavity Pixel Detection====
The plugin supports different concavity pixel detection types. The chosen type specifies which and how many concavity pixels can be detected.

'''Detect all concavity pixels:''' If all concavity pixels should be detected, the plugin is looking for all local concavity pixels. Use it, if you have choosen the concavity region detection by convex hull.

[[File:AllPixels.png |250px]]


'''Detect all concavity pixels with largest concavity depth:'''
If all concavity pixel with largest concavity depth should be detected, the plugin is looking for the global concavity pixels of a concavity region. Use it, if you have choosen the local concavity region detection.

[[File:LargestPixels.png |250px]]

===SVM===
The parameters <math>c_1</math> and <math>c_2</math> can be optimized by a linear SVM. This SVM is integrated in the plugin and uses the [https://www.csie.ntu.edu.tw/~cjlin/libsvm/ LIBSVM] library. 

If you want to train the SVM you first have to generate training and testdata. The way to generate it is not easy to use in the actual version. 

You first have to generate a image with optimal split lines manually. This could be time consuming and complex. The overlay of the plugin tries to aid at this point, but it could be complex as well. Therefoe it could be easier to separate individual clumps and split them separately. Now you have to generate traing data by the plugin. In the progress the SVM writes data and if it is a split line in a CSV-File. The data is the sum of concavity depths of the concavity pixels at the x axis and the distance between the points at y axis.

Now you have to look for a good cost- and epsilon parameter of the SVM. This could happen by a grid search for example.

[[File:SVMParameter.png]]

After this the SVM starts training. This could take some time. How long it takes depends on complexity and size of the training data.

Once the SVM was trained, there are two windows, which show the results. In the first window you can see a graphical representation of the SVM model. The blue points represent the split line class, the red points represent the no split line class data and the green line represents the dividing line of the SVM.

[[File:SVMModellGraphic.png]]

The second window shows the parameters of this model. The optimum <math>c_1</math> and <math>c_2</math> parameters, are given and the number of support vectors as well as a confidencial matrix to evaluate the model.

[[File:SVMModelNumbers.png |300px]]

==Parameters==
As already mentioned the main algorithm follows the publication of ''Kumar et al.'' The presented algorithm to specify a valid split line depends on lots of parameters, as you can see below. Not every parameter is needed for every split line type and concavity region detection

[[File:PluginScreenshot3.png]]

'''background color:''' Choose the color of your background. Choose white, if objects are darker than the background, and black if objects are lighter than the background.

'''is already preprocessed:''' Choose if your picture is already preprocessed. If it is unchecked, preprocessing will be executed before the algorithm is started. The default-preprocessing is: binarization, erosion, gaussian blur (<math>\sigma=2</math>), dilation

'''Show concavity regions:''' If it is checked, an overlay shows detected concavity regions, this could help to detect good thresholds and to detect mistakes in detection.

'''Show concavity pixels and split points:''' If it is checked, an overlay shows detected concavity pixels, this could help to detect good thresholds and to detect mistakes in detection.

'''write data in file to train SVM:''' If it is checked, data for the SVM-Model is written in a file you can choose.

'''binarization threshold:''' Threshold to binarize an image. Default: Detected value for the image by ImageJ default method.

'''concavity-depth threshold:''' Largest distance of a concavity region in pixels <math>CD_i</math>. Threshold should be smaller than smallest concavity-depth value of a valid concavity pixel. 

'''saliency-threshold:''' The ratio of concavity-depth and distance of two concavity pixels, increase, if less split lines are detected.
<math>SA_{i,j}=\frac{\min(CD_i,CD_j)}{\min(CD_i,CD_j)+ d(C_i,C_j)}</math>

'''concavity-concavity-alignment-threshold:''' Angle between orientation of the two concavity regions. <math>CC_{ij}= \pi - \cos^{-1}(v_i \cdot v_j)</math>. Threshold should be greater than <math>\max{|180-|\theta_i-\theta_j||}</math> of all valid split lines.

[[File:ConcavityConcavityAlignment.png |300px]]

'''concavity-line-alignment-threshold:''' Angle between orientation of the concavity pixel of a split line and the split line. <math>CL_{ij}=\max{\cos^{-1}(v_i \cdot u_{ij}),\cos^{-1}(v_j \cdot (-u_{ij})))}</math> 

[[File:ConcavityLineAlignment.png |300px]]

'''concavity-angle-threshold:''' Angle of a concavity region. <math>CA=\angle C_{i1}C_iC_{i2}</math> Threshold should be larger, than the largest angle of a concavity region where a split line between concavity pixel and contour point is expected.

[[File:ConcavityAngle.png |300px]]

'''concavity-ratio-threshold:''' Ratio between largest and second largest concavity region. <math>CR=\frac{CD_m}{CD_n}</math> Threshold should be smaller than the largest ratio of valid split line between concavity pixel and contour point.

'''inner-contour-parameter:''' Sampe constant for inner contour, if the inner contour is large and round, choose a large constant, else choose a small constant.

'''outer-contour-parameter:''' Sampe constant for outer contour. If concavity regions are big, choose a large value, otherwise choose a small value.

'''picture section for intensity:''' For split line detection of ''Wang et al.'' you need to determine a picture section, where the split line should be detected. Choose a large value if clumps and split lines are large and a small value if clumps and split lines are small.

[[File:PictureSelection.png |300px]]

'''<math>c_1</math>:''' Parameter to validate a splitline, for an optimal value train SVM.

'''<math>c_2</math>:''' Parameter to validate a splitline, for an optimal value train SVM.

'''<math>\chi</math>-threshold:''' Parameter to validate a splitline. <math>\chi = \frac{c_1*CD_i+c_1*CD_j+c_2}{d(C_i,C_j)+c_1*CD_i+ c_1*CD_j+c_2}</math> Decrease threshold value if there are less split lines.

=Installation=

If you use ImageJ just copy ij_robust_split.jar in your plugins folder and copy the [http://imagej.net/IJ_Blob IJ-Blob], [https://github.com/hharrison/vecmath Vecmath], the [https://www.csie.ntu.edu.tw/~cjlin/libsvm/ LIBSVM] and the [http://java-ml.sourceforge.net/ JavaML] jars into the plugins/jars folder.

=How to cite=

The best way to cite the formal methods is:

''Kumar, S., Ong, S.-H., Ranganath, S., Ong, T., und Cheq, F.
(2005). A rule based Approach for robust clump splitting. Pattern Recognition,
39(6), pp.1088–1098.''

''Farhan, M., Yli-Harja, O., und Niemistö, A. (2013). A novel
method for splitting clumps of convex objects incorporating image intensity and
using rectangular window-based concavity point-pair search. Pattern Recognition,
46(3), pp.741–751.''
 
and

''Wang, H., Zhang, H., und Nilanjan, R. (2011). Clump splitting via
bottleneck detection. IEEE International Conference Image Processing, 2, pp.61–64.''
