{{ComponentStats:net.imagej:imagej-ops}}ImageJ Ops is a framework for reusable image processing operations. Ops extends Java's mantra of &quot;write once, run anywhere&quot; to image processing algorithms.

The central goal is to enable programmers to code an image processing algorithm in the Ops framework, which is then usable as-is from any [[SciJava]]-compatible software project, such as [[ImageJ]], [[CellProfiler]], [[KNIME]], [[OMERO]] and [[Alida]].
{{TOC|small}}
{{DevelopMenu | tutorials}}
== Design goals ==

Ops has three major design goals:

# '''Easy to use and extend.''' There must be a wealth of easy-to-use image processing operations (&quot;ops&quot;), as well as an easy framework for extending those ops in new directions.
# '''Powerful and general.''' An op should be able to consist of any number of typed input and output parameters, operating on arbitrary data structures, including images of N dimensions stored in a myriad of different ways: as files on disk, programmatically generated in memory, or in remote databases. Using the powerful [[ImgLib2]] library achieves this ambitious goal.
# '''Very fast.''' Even though ImgLib2 is vastly more general than ImageJ 1.x's data model, that generality should not come at the expense of performance. Otherwise, users must pay a time tax to do the same things they could already do in ImageJ 1.x. The ImageJ Ops framework needs to provide a means to override ''any'' general-but-slow op with a faster-but-more-specific alternative, fully transparently to the user.

== Getting started ==

Start by reading these Jupyter notebooks:

* [https://nbviewer.jupyter.org/github/imagej/tutorials/blob/master/notebooks/1_-_Using_ImageJ/2_-_Introduction_to_ImageJ_Ops.ipynb Using ImageJ Ops] - to call ops from your scripts.
* [https://nbviewer.jupyter.org/github/imagej/tutorials/blob/master/notebooks/2_-_Extending_ImageJ/4_-_Writing_Op_plugins.ipynb Writing Op plugins] - to write your own ops.

Ops are a special type of ImageJ plugin, so a basic understanding of the [[Writing_Plugins|SciJava plugin framework]] is strongly recommended.

In addition to cloning the [https://github.com/imagej/imagej-ops imagej-ops] itself, the following components have useful Ops examples:

* {{GitHub|org=imagej|repo=imagej-tutorials|label=ImageJ-tutorials}} - examples of ImageJ plugins using Ops
* {{GitHub|org=imagej|repo=imagej-scripting|label=ImageJ-scripting}} - provides [[Script_Templates|templates in the Script Editor]]

== Tutorials and workshops ==

* [[Adding_new_ops|Step-by-step guide: Adding new ops]]
* [http://nbviewer.jupyter.org/github/imagej/tutorials/blob/master/notebooks/1_-_Using_ImageJ/2_-_Introduction_to_ImageJ_Ops.ipynb ImageJ Tutorial: Introduction to ImageJ Ops]
* [http://nbviewer.jupyter.org/github/imagej/tutorials/blob/master/notebooks/2_-_Extending_ImageJ/4_-_Writing_Op_plugins.ipynb Extending ImageJ: Ops]
* "Scripting in ImageJ - An introduction to ImageJ Ops" (February 2017 NEUBIAS2020) – [http://imagej.github.io/presentations/2017-02-12-imagej-ops-neubias/#/ slides]
* "ImageJ2 scripts: Parameters + ImageJ Ops" (ImageJ conference 2015) – [https://imagej.github.io/presentations/2015-09-04-imagej2-scripting/ slides], [https://vimeo.com/140098817 video 1], [https://vimeo.com/140098835 video 2]
* "The ImageJ Ops Framework: Image processing made easy" (January 2015) – [https://imagej.github.io/presentations/2015-01-12-imagej-ops/ slides]
* "Intro to ImageJ Ops - Usage and Development" (November 2015) – [http://workshops.imagej.net/IntroToOps.pdf slides]

== FAQ ==

=== Why not implement algorithms as "plain old Java" methods? ===
The Ops matching framework provides '''extensibility.''' Ops are plugins, so any developer can override the behavior of a particular op as needed—e.g., for improved performance of a special case. See "Design goals" above.

=== Can a C/C++ or MATLAB function be converted to an op? ===
Yes, but there is no automagic wrapping of native/external functionality in Ops.  The [https://github.com/imagej/ops-experiments ops-experimeents] project is an ongoing effort to work out a maven based build system for ops that use native code.  The efforts so far have focused on wrapping, cuda, mkl and tensorflow implementations of deconvolution algorithms using [https://github.com/bytedeco/javacpp javacpp].

=== Is there a list of Ops somewhere with brief descriptions of their functionalities? ===

For an interactive tool to see all available Ops, see the [[Op Finder]] documentation.

For the core Ops available, you can go to the {{Javadoc | package = ?net/imagej/ops | class=package-summary | label=ImageJ Ops}} javadocs. Any class under the package <code>net.imagej.ops</code> is related to Ops.

You can also use the [[Script Editor]] in ImageJ and actively search using Ops itself. For example in groovy language:

<source lang="groovy">
// @OpService ops
print ops.help()
</source>

in groovy will give a list of every Op signature. The <code>help</code> op can also provide information about ops or namespaces; e.g., <code>ops.help("add")</code> will return info about available <code>add</code> ops.

=== Are there any Ops for image processing? ===
Yes, there are. Take a look at the existing ops using the [[#Is there a list of Ops somewhere with brief descriptions of their functionalities? | Ops Browser]] or the <code>net.imagej.ops.*</code> packages in the [http://javadoc.imagej.net/ImageJ/ ImageJ javadocs].

=== What are the Ops that need to be developed in the future? ===
Ops is under development at the moment, as indicated by the 0.x.x version number. For ideas and discussions of future developments visit the [https://github.com/imagej/imagej-ops/ ImageJ Ops GitHub page] and take a look at the issues and pull requests.

=== Why is matching important? ===
This is a necessary part of any plugin-based infrastructure (see [https://en.wikipedia.org/wiki/Inversion_of_control inversion of control]). The core library (ImageJ Ops) has many built-in operations, but: 
<ol type="a">
<li>cannot possibly cover all possible implementations and</li>
<li>would be impractical if a user had to explicitly call the precise signature for their arguments.</li>
</ol>
Ops matching is an additional layer that allows plugin selection to be tailored to the arguments of the function being called.

A contrived example:
Suppose the default ops implementation of <code>add(array, array)</code> iterates over the arrays and combines their values.

Then guava comes up with a way to combine arrays that is 100x faster; we do not want a guava dependency in the base ops library, but we can have an "imagej-ops-guava" component that provides a <code>GuavaAddArrayOp</code>.

Then an independent developer comes up with a new way to add the arrays that's 50,000x faster. They turn it into a closed-source, proprietary Op and sell it.

Regardless of this proliferation of implementations, a user just has to write <code>ops.math().add(array1, array2)</code> and it will work. If they have the guava implementation on their classpath it will be faster, and if they purchase the proprietary implementation it will be faster still. But their code does not have to be adjusted.

== See also ==

* [[2014-04-04 - Announcing ImageJ Ops]] news post

[[Category:Ops]]
