== Introduction ==
ImageJ Ops is a framework for reusable image processing operations. Ops extends Java's mantra of &quot;write once, run anywhere&quot; to image processing algorithms.

The central goal is to enable programmers to code an image processing algorithm in the Ops framework, which is then usable as-is from any [[SciJava]]-compatible software project, such as [[ImageJ]], [[CellProfiler]], [[KNIME]], [[OMERO]] and [[Alida]].

== Design goals ==

Ops has three major design goals:

# '''Easy to use and extend.''' There must be a wealth of easy-to-use image processing operations (&quot;ops&quot;), as well as an easy framework for extending those ops in new directions.
# '''Powerful and general.''' An op should be able to consist of any number of typed input and output parameters, operating on arbitrary data structures, including images of N dimensions stored in a myriad of different ways: as files on disk, programmatically generated in memory, or in remote databases. Using the powerful [[ImgLib2]] library achieves this ambitious goal.
# '''Very fast.''' Even though ImgLib2 is vastly more general than ImageJ 1.x's data model, that generality should not come at the expense of performance. Otherwise, users must pay a time tax to do the same things they could already do in ImageJ 1.x. The ImageJ Ops framework needs to provide a means to override ''any'' general-but-slow op with a faster-but-more-specific alternative, fully transparently to the user.

== Getting started ==

An op is a function which takes a list of typed inputs, produces a list of typed outputs, and has no side effects.

== Tutorials and workshops ==

* {{GitHub | org=imagej | repo=imagej-tutorials | path=using-ops | label=ImageJ Tutorial: Using Ops}}
* For external developers: [[Adding_new_ops|adapting your code Ops]]
* {{GitHub | org=imagej | repo=imagej-tutorials | path=create-a-new-op | label=ImageJ Tutorial: Create A New Op}}
* "ImageJ2 scripts: Parameters + ImageJ Ops" (ImageJ conference 2015) – [https://imagej.github.io/presentations/2015-09-04-imagej2-scripting/ slides], [https://vimeo.com/140098817 video 1], [https://vimeo.com/140098835 video 2]
* "The ImageJ Ops Framework: Image processing made easy" (January 2015) – [https://imagej.github.io/presentations/2015-01-12-imagej-ops/ slides]
* "Intro to ImageJ Ops - Usage and Development" (November 2015) – [http://workshops.imagej.net/IntroToOps.pdf slides]

== FAQ ==

=== Why not implement algorithms as "plain old Java" methods? ===
The Ops matching framework provides '''extensibility.''' Ops are plugins, so any developer can override the behavior of a particular op as needed—e.g., for improved performance of a special case. See "Design goals" above.


=== Can a C/C++ or MATLAB function be converted to an op? ===


=== Is there a list of Ops somewhere with brief descriptions of their functionalities? ===
Unfortunately, we do not have such a list right now. To see the list of Ops we have, we can go to the [http://javadoc.imagej.net/ImageJ/ Javadoc page for ImageJ]. Any class under the package "net.imagej.ops" is related to Ops.

You can also use the [http://imagej.net/Script_Editor script editor] in ImageJ and actively search using Ops itself. for example:

<source lang="java">
// @OpService ops
print ops.help()
</source>

in groovy will give a list of every Op signature. The <code>help</code> op provides information about ops or namespaces; e.g., <code>ops.help("add")</code> will return info about available <code>add<code> ops.

A tree-based high-level view is [https://github.com/imagej/imagej-ui-swing/commit/9d54c38f57ac15b9986590bc4c5aa09d752f6e65 coming soon]...

=== Are there any Ops for image processing? ===


=== What are the Ops that need to be developed in the future? ===


=== Why is matching important? ===
This is a necessary part of any plugin-based infrastructure (see [https://en.wikipedia.org/wiki/Inversion_of_control inversion of control]). The core library (ImageJ-Ops) defines the available operations, but 

a) cannott possibly cover all possible implementations and 
b) would be impractical if a user had to explicitly call the precise signature for their arguments. 

Ops matching is just an additional layer that allows plugin selection to be tailored to the arguments of the function being called.

A contrived example:
Suppose the default ops implementation of "add(array, array) iterates over the arrays and combines their values.

Then guava comes up with a way to combine arrays that is 100x faster; we do not want a guava dependency in the base ops library, but we can have an "ImageJ-Guava" component that provides a GuavaAddArrayOp.

Then an independent developer comes up with a new way to add the arrays that's 50,000x faster. They turn it into a closed-source, proprietary Op and sell it.

Regardless of this proliferation of implementations, a user just has to write "ops.math().add(array1, array2)" and it will work. If they have the guava implementation on their classpath it will be faster, and if they purchase the proprietary implementation it will be faster still. But their code does not have to be adjusted.

== See also ==

* [[2014-04-04 - Announcing ImageJ Ops]] news post

[[Category:Ops]]
