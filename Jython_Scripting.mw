{{Learn | languages}}

== Introduction ==

Jython is an implementation of the Python programming language designed to run on the Java platform. <ref>[http://rsb.info.nih.gov/ij/plugins/index.html Wikipedia entry on Jython]. Accessed: 2016-08-30</ref> In ImageJ Jython is one of several [[Scripting#Supported_languages|supported languages]].

== When to use Jython ==

All scripting language supported by ImageJ can be used to access the [http://javadoc.imagej.net/ ImageJ API]. There are only differences in how the imports are handled and in the syntax of the selected language. Jython has a syntax that differs from most other language as indentations instead of brackets are used to group code blocks.

The following list will help you to decide if Jython is the right choice to create scripts for ImageJ:

* If you have experience with Python you can easily use Jython for ImageJ scripting. But you have to keep in mind that tools commonly used in many Python projects (e.g. Numpy) are not available in Jython. By building your [[Jython_Scripting#Self_written_Jython_modules_for_ImageJ|own modules]] you can create complex scripts that otherwise are only possible by writing ImageJ plugins in Java.
* If don't have any experience in programming, the Python language is a good choice to start with. If your only aim is to write scripts for ImageJ, there are other languages you should try first (e.g. [[Groovy_Scripting|Groovy]]).
* In Python many problems can be solved with less code than in other languages. Still the code is easy to read. Have a look at the examples on this page and decide if you want to start using Python for ImageJ scripting.

=== Explanation ===

The Java implementation of Python is limited in functionality. One can use the [https://docs.python.org/2/library/index.html standard library], but it's not possible to install additional Python modules. Moreover a growing number of projects build on Python3 which is not fully compatible with Python2 Jython is based on. If you want to start learning Python it's recommended to learn Python3.x instead of Python2.

Even with the given limitations Jython is a powerful language for ImageJ scripting. Hopefully the examples on this page can convince you of that.

== Jython basics for ImageJ ==

{{Notice|For an introduction in ImageJ scripting visit the page [[Scripting_basics|Scripting basics]].}}

=== Introduction ===

The aim of this page is not to teach how to program in Python. This purpose is much better fulfilled by the [https://docs.python.org/2/library/index.html documentation of Python2]. The focus of this page is to show how features of the Python language can be useful for ImageJ scripting.

That is why more complex examples are used that are fully functional. Just copy the code to the [[Using_the_Script_Editor|Script Editor]] and try them by yourself. Extensive in-line documentation is used to explain the implementation.

=== Image selection using the GenericDialog class ===

This example script will create up to 10 new images and create a GenericDialog to select 3 of them. Finally the names of the selected images are printed to the Log window. It is recommended to copy the code to the [[Using_the_Script_Editor|Script Editor]] and run it by yourself.

The following list links to documentation of the used Python features:
* [https://docs.python.org/2/library/__future__.html Future statement definitions]
* [https://docs.python.org/2/library/functions.html Built-in Functions]
* [https://docs.python.org/2/library/stdtypes.html#str.join str.join()-method]
* [https://docs.python.org/2/tutorial/datastructures.html#list-comprehensions List Comprehensions]
* [https://www.python.org/dev/peps/pep-0289/ Generator Expressions]
* [http://stackoverflow.com/questions/36901/what-does-double-star-and-star-do-for-python-parameters ** (double star) and * (star) parameters]
* [https://docs.python.org/2/library/%5F%5Fmain%5F%5F.html Top-level script environment (__main__)]
* [http://stackoverflow.com/questions/5893163/what-is-the-purpose-of-the-single-underscore-variable-in-python Purpose of the single underscore “_” variable]


{{GitHubEmbed|org=imagej|repo=imagej-scripting|path=src/main/resources/script_templates/Tutorials/Wiki_Jython_Tutorial_1.py}}

=== Using Scripting Parameters ===

The second example is inspired by atomic resolution images recorded with an Transmission Electron Microscope (TEM). Such images show a regular structure (a crystal), but the images are noisy because of the low signal. By using a Fourier filter the contrast can be enhanced.

The script will create a periodic structure and add some random noise. The user can control the parameters of the created image. This is realized using [[Script_parameters|Script parameters]]. The Fourier filtering has been created by using the [[Introduction_into_Macro_Programming#The_recorder|Recorder]]. Finally a simple image calculator is used to show that functions can be passed as parameters.

This list links to the documentation of Python features that are introduced with this example:

* [https://docs.python.org/2/library/functions.html#zip The zip() function]
* [http://stackoverflow.com/questions/8421337/rotating-a-two-dimensional-array-in-python Rotating a two-dimensional array]
* [https://docs.python.org/2/reference/expressions.html#lambda Lambda expressions]


{{GitHubEmbed|org=imagej|repo=imagej-scripting|path=src/main/resources/script_templates/Tutorials/Wiki_Jython_Tutorial_2.py}}

=== A batch opener using <code>os.walk()</code> ===

We have yet introduced some powerful functions build into Python. Another one is <code>walk()</code> from the <code>os</code> module. It can be used to go through a directory structure and process the contained files. In this example <code>walk()</code> is used to batch open images with ImageJ's function <code>openImage()</code>.

To read more about the used features, the following list provides links to additional information:

* [https://docs.python.org/2/library/os.html#os.walk The walk() function]
* [https://docs.python.org/2/library/os.path.html The documentation of os.path]
* [https://docs.python.org/2/library/os.html#os.listdir The listdir() function]
* [http://javadoc.imagej.net/ImageJ1/ Javadoc on IJ.openImage()]
* [https://docs.python.org/2/library/functions.html#isinstance Testing the type of an object using isinstance()]
* [https://docs.python.org/2/library/functions.html#type Identifying the type of an object using type()]
* [https://docs.python.org/2/reference/simple_stmts.html#continue Using continue to control a loop]
* [https://docs.python.org/2/library/stdtypes.html#truth-value-testing Truth Value Testing]


{{GitHubEmbed|org=imagej|repo=imagej-scripting|path=src/main/resources/script_templates/Tutorials/Wiki_Jython_Tutorial_3.py}}

=== Importing Java module and classes ===
Another great feature of Jython is the possibility to use functions from Java jar package that resides in the jar folder of imageJ. 

==== ImageJ and Fiji API ====
 The following API documentation lists all available module and functions :
* [http://javadoc.scijava.org/ImageJ1/ ImageJ]
* [http://javadoc.scijava.org/Fiji/ Fiji]

Those package are built-in with Fiji, but any package that resides in the jars folder can be imported provided you know the path to the class.

Let's show one example with the ImageJ package and the class [http://javadoc.scijava.org/ImageJ1/ij/plugin/frame/RoiManager.html RoiManager]. According to the javadoc the RoiManager class resides in <code>ij.plugin.frame</code>. Therefore the code will look like :

<code>
from ij.plugin.frame import RoiManager
RM = RoiManager()        # we create an instance of the RoiManager class
rm = RM.getRoiManager()  # "activate" the RoiManager otherwise it can behave strangely 
</code>

==== Using openCV in Jython ====
It is even possible to use most of opencv functionalities within Jython/Fiji. There are several options (see the [https://imagej.net/OpenCV wiki page about opencv]), yet the most straight forward is probably IJ-OpenCV which is available via the update sites.  It will automatically download the necessary packages and dependencies in your Fiji installation. 

A manual installation is also possible by putting the jar packages in the jar folder of imageJ. They are avalaible on the [https://github.com/joheras/IJ-OpenCV IJopenCV github], which even provides a maven option.  

The 1st things to know about openCV is that most functions works with openCV matrix object. Hopefully, the IJopenCV provides some converters :

<source lang="python">
#@ ImagePlus ImP 
from ijopencv.ij      import ImagePlusMatConverter
from ijopencv.opencv  import MatImagePlusConverter
from ij               import ImagePlus

# Convert ImagePlus (actually the contained ImageProcessor) to Matrix object
imp2mat = ImagePlusMatConverter()
ImMat = imp2mat.toMat(imp.getProcessor())
print ImMat

# Convert Matrix object to ImageProcessor
mat2ip = MatImagePlusConverter()
NewIP  = mat2ip.toImageProcessor(ImMat)
NewImp = ImagePlus("Matrix converted back to ImagePlus", NewIP)
print NewImP
</source>

Such kind of converter is also available for PointRoi to opencv keypoints...

Now to use opencv function, we use the [http://bytedeco.org/javacpp-presets/opencv/apidocs/ JavaCPP API] that contains almost all functions of opencv.
An simple example : creating an identity matrix of size 3x3
 
<source lang="python">
from org.bytedeco.javacpp.opencv_core	import Mat,CvMat

Id = Mat().eye(3,3,0).asMat()

print Id
print CvMat(Id) # nice to visualise the matrix
</source>
NB : The <code>org.bytedeco.javacpp.opencv_core.Mat</code> object is different than the <code>org.opencv.core.Mat</code> !! They dont have exactly the same attributes and functions. In Fiji we always use the <code>org.bytedeco.javacpp.opencv_core.Mat</code>.

Similarly there is some apparent redudancy for the function in the javacpp API. ex : Transform exists in 3 different places :
* <code>org.opencv.core.Core.transform</code>
This one takes <code>org.opencv.core.Mat</code> as input. It is currently challenging to have such object in Fiji.

* <code>org.bytedeco.javacpp.opencv_core.cvTransform</code>
using <code>CvArr</code> as input, but even if you manage to convert your input as a <code>CvArr</code> it crashes Fiji. Apparently it is a deprecated version.

* <code>org.bytedeco.javacpp.opencv_core.transform</code>
That's the one to use ! It takes only <code>org.bytedeco.javacpp.opencv_core.Mat</code> as input, which is the most approriate in Fiji/Jython

== Self written Jython modules for ImageJ ==

In Jython you can write all commands line by line in a single file and execute it. To create a neat program, [https://docs.python.org/2/tutorial/controlflow.html#defining-functions functions] and [https://docs.python.org/2/tutorial/classes.html classes] can be used to structure code. To prevent using copy&past for regularly used functions and classes, [https://docs.python.org/2/tutorial/modules.html modules] are the way to choose. Modules are files that contain functions and classes to import into other files.

To load modules, one has to save them to a directory where Jython will find them. Two lines of code will reveal these directories to you:

<source lang='python'>
from sys import path
print(path)
</source>

When running this code the result is an output like

<source lang='python'>
['/home/michael/Software/ImageJ.app/jars/Lib', '/home/michael/Software/ImageJ.app/jars/jython-shaded-2.7.0.jar/Lib', '__classpath__', '__pyclasspath__/']
</source>

This tells us that the folder <code>jars/Lib/</code> inside our ImageJ/Fiji directory is the right place to save modules. As <code>Lib/</code> does not exist by default, we have to create it.

When a module is imported for the first time, Jython will compile it to Java code. If there is a module named <code>myModule.py</code>, Jython will create a file called <code>myModule$py.class</code>. The next time the module is imported, Jython will use the class file instead of the py file. When modifying the module, it necessary to restart ImageJ/Fiji to use the modified one. A work around is the following code (found at [http://stackoverflow.com/questions/10531920/jython-import-or-reload-dynamically stackoverflow]) that will force Jython to recompile all modules:

<source lang='python'>
# Use this to recompile Jython modules to class files.
from sys import modules
modules.clear()
# Imports of Jython modules are placed below:
import myModule
</source>

=== Adding a custom directory ===

If you don't want to use <code>jars/Lib/</code> to save your modules, you have to extend the array <code>sys.path</code>:

<source lang='python'>
from sys import path
from java.lang.System import getProperty
 
# extend the search path by $FIJI_ROOT/bin/
# 'fiji.dir' works for plain ImageJ, too.
path.append(getProperty('fiji.dir') + '/bin')
# an alternative can be the users home directory
# path.append(getProperty('user.home') + '/JythonModules')
 
# Now you can import $FIJI_ROOT/bin/myModule.py
import myModule
</source>

The function <code>getProperty()</code> accepts many more strings. A list can be found at [https://docs.oracle.com/javase/tutorial/essential/environment/sysprop.html The Java Tutorials].

== Self written Jython packages for ImageJ ==

On the way to perfectly organize Jython code, [https://docs.python.org/2/tutorial/modules.html#packages packages] are the next step. In Jython, folders that contain modules are made packages by adding the file <code>__init__.py</code>. This file can be empty. An folder structure can look like this:

<source>
Imagej.app/jars/Lib/
-- myModule.py
-- myPackage/
   -- __init__.py
   -- mathTools.py
   -- customFilters.py
   -- fftTools.py
-- myPackage2/
   -- __init__.py
   -- mathTools.py
   -- stackProcessing.py
</source>

There are two packages and one module. The first package contains three modules and the second package contains two modules. We can import the modules on different ways:

<source lang='python'>
# Import the single module using the default name:
import myModule

# Import mathTools from the first package
import myPackage.mathTools
# Use a function from the imported module
myPackage.mathTools.aFunction()

# Import mathTools from the second package
from myPackage2 import mathTools
# Use a function from the imported module without prefixing the package
mathTools.aFunction()

# Import customFilters from the first package and rename it
from myPackage import customFilters as filters
# Use a function from customFilters.py
filters.aFunction()

# Importing all module from a package
from myPackage2 import *
# The next line will fail
stackProcessing.aFunction()
</source>

The reason for the last import to fail is the empty <code>__init__.py</code>. We have to define which modules of the package are imported when using <code>import *</code>. This is done by setting the variable <code>__all__</code> at <code>__init__.py</code>. For <code>myPackage2</code> this line of code is needed:

<source lang='python'>
__all__ = ["mathTools", "stackProcessing"]
</source>

Besides setting this variable, the file can contain normal Jython code that is executed on import.

== Bundle packages in a JAR file ==

An interesting feature of Jython is to search for packages and modules inside of [https://en.wikipedia.org/wiki/JAR_(file_format) JAR files]. The folder structure from the last section can be modified by packing everything into a single <code>myPackages.jar</code>. The name of the JAR file doesn't matter. All imports work the same as explained before.

<source>
Imagej.app/jars/Lib/
-- myPackages.jar
   -- myModule.py
   -- myPackage/
      -- __init__.py
      -- mathTools.py
      -- customFilters.py
      -- fftTools.py
   -- myPackage2/
      -- __init__.py
      -- mathTools.py
      -- stackProcessing.py
</source>

The advantage of this approach is that you can share your packages easily. For example you can upload the JAR file to an [[Update_Sites|update site]].    
It is possible to upload .py scripts to update sites too, without packaging into a jar. The advantage of jar are that they allow to define dependencies more systematically.  

'''NB''' : Script implementing "ImageJ menu macro" and "utilitary scripts" that are used as imported modules in other macros '''should be packed in separate jar files''' ! Indeed, if not explicitly mentioned, the jython interpreter only looks in the Jars/Lib folder to import module, so the .jar containing the "utilitary scripts" should be put there, while the jar containing the "ImageJ menu macro" can be put either in the Plugin or script/Plugin folder in order to appear in the ImageJ menu. 

Contrary to the scripts in Jars/Lib, the menu macro scripts are not compiled, and as explained above they can not be imported in other scripts since the Plugin folder do not reside in the Jython search path by default. 
      
This is the reason why a given project is rather distributed in 2 different jar files as explained [http://forum.imagej.net/t/using-self-written-jython-modules-in-imagej/2280 here].  
  
=== Using maven to build packages ===

Using maven you can automate the packaging of Jython code into JAR files. This approach is only recommended if you already use maven, as installing and learning how to use maven is not worth the time saving of automated packaging.

At GitHub you will find an [https://github.com/m-entrup/imagej-jython-package example project] that you can use as a template. Just run <code>mvn package</code> and maven will generate a JAR file at the <code>target</code> directory.

== Links ==

* [[Jython_Scripting_Examples|Jython Scripting Examples]]
* [[ImageJ2_Python_Scripts|ImageJ2 Python Scripts]]
* [https://www.ini.uzh.ch/~acardona/fiji-tutorial/ A Fiji Scripting Tutorial by Albert Cardona]

== References ==
<references />
