= Introduction =

Maven is a powerful tool to build Java projects and to manage their dependencies. It can build dependencies from sources, but if the sources are not available, it will look into Maven repositories to download the dependencies from.

Example: let's assume that you want to build a new plugin for ImageJ 1.x that builds on, say, the [[3D Viewer]] and commons-math. You do not want to rebuild them from scratch unless you need to debug issues you suspect might be bugs in said components. This is where Maven comes in: you tell it that the dependencies are ImageJ 1.x, 3D Viewer and commons-math and what version(s) you require. It is Maven's job to find and get them, no matter whether you just built them locally or not.

Many convenient IDEs (integrated development environments) including [http://eclipse.org/ Eclipse], [http://netbeans.org/ Netbeans] and [https://www.jetbrains.com/idea/ IntelliJ] support Maven projects; Therefore, using Maven is an excellent choice when trying to let every developer choose their preferred development environment.

= What does it take to make a new Maven project? =

== POM and directory structure ==

All it really takes is a ''pom.xml'' file and a certain directory structure:

<pre>
pom.xml
src/
   main/
       java/
           <package>/
                    <name>.java
                    ...
       resources/
                <other-files>
                ...
</pre>

Technically, you can override the default directory layout in the ''pom.xml'', but why do so? It only breaks expectations and is more hassle than it is worth, really.

So the directory structure is: you put your .java files under ''src/main/java/'' and the other files you need to be included into ''src/main/resources/''. Should you want to apply the best practices called "regression tests" or even "test-driven development": your tests' ''.java'' files go to ''src/test/java/'' and the non-''.java'' files you might require unsurprisingly go into ''src/test/resources/''.

So what does a ''pom.xml'' look like? This is a very simple example:

<source lang="xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
    http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>sc.fiji</groupId>
  <artifactId>my-uber-library</artifactId>
  <version>2.0.0-SNAPSHOT</version>
</project>
</source>

The first 6 lines are of course just a way to say "Hi, Maven? How are you today? This is what I would like you to do:".

The only relevant parts are the ''groupId'', which by convention is something like the inverted domain name (similar to the Java package convention), the name of the artifact to build (it will be put into ''target/'', under the name ''<artifactId>-<version>.jar''). And of course the version.

== Maven repositories ==

Maven is not only a build tool but first and foremost a dependency management tool. It has so-called Maven repositories where it stores compiled artifacts. [http://developer.imagej.net/ ImageJ2] has a [http://maven.imagej.net/ Maven repository]. (For those familiar with Fiji's previous build system: it is like [[Fake|Fiji Build]]'s precompiled/ directory, but done right.)

For Maven to know what you are looking for, you typically have to add the dependencies into the ''pom.xml'' file. For example, every ImageJ 1.x plugin will depend on ImageJ 1.x. So let's add that (before the final ''</project>'' line):

<source lang="xml">
<dependencies>
  <dependency>
    <groupId>net.imagej</groupId>
    <artifactId>ij</artifactId>
    <version>1.45b</version>
  </dependency>
</dependencies>
</source>

As you can see, dependencies are referenced under the same ''groupId'', ''artifactId'' and ''version'' triplet (also known as ''GAV parameters'') that you had to declare for the current project.

For Maven to find the dependencies, it has to know about the location of the repositories. As you know, we are strong proponents of collaboration within the scientific community, so we started the [http://scijava.org/ scijava effort] at the hackathon in December 2011. To this end, scijava has a [https://github.com/scijava/scijava-common/blob/master/pom-scijava/pom.xml super POM] which declares repositories we use (and other metadata as well, such as current artifact versions we provide). To benefit from this in your project, add this to your ''pom.xml'':

<source lang="xml">
<parent>
  <groupId>org.scijava</groupId>
  <artifactId>pom-scijava</artifactId>
  <version>1.15</version>
</parent>

<repositories>
  <!-- NB: for project parent -->
  <repository>
    <id>imagej.releases</id>
    <url>http://maven.imagej.net/content/repositories/releases</url>
  </repository>
</repositories>
</source>

== Releases and snapshots ==

There are two different sorts of Maven artifacts (i.e., JAR files): releases and snapshots. The snapshot versions are "in-progress" versions. If you declare a dependency with a ''-SNAPSHOT'' suffix in the version, Maven will look once a day for new artifacts of the same versions; otherwise, Maven will look whether it has that version already and not bother re-downloading.

== Producing multiple JAR files ==

So what if you have multiple ''.jar'' files you want to build in the same project? Then these need to live in their own subdirectories and there needs to be a common parent POM, a so-called ''aggregator'' or ''multi-module'' POM (only this POM needs to have the scijava POM as parent, of course). [https://github.com/imagej/imagej-tutorials/blob/577286474be8399eb38d30d66cf0c35ee50bd929/pom.xml#L47-L62 Here is an example]. Basically, it is adding the ''<packaging>pom</packaging>'' entry at the top, as well as some subdirectory names to the ''<modules>'' section.

Note, however, that most of the [[SciJava]] software stack ([[SciJava Common]], [[ImgLib2]], [[SCIFIO]], [[ImageJ]] and [[Fiji]]) now structures each project as its own single-module project in its own Git repository, since using multi-module projects can complicate versioning.

== Convention over configuration ==

There are many more things you can do with Maven, but chances are you will not need them.

The simplicity of the ''pom.xml'' you need comes from the fact that Maven defines implicit defaults. It calls that ''convention over configuration''.  But since we are not converting projects (or at least since we are flexible enough to adapt), it is strongly recommended to stay with the defaults as much as possible. It also makes your project more accessible, something that Fiji and the other projects in scijava excel at.

Now, in the context of scijava, you will most likely never write a ''pom.xml'' from scratch. You will rather more likely edit an existing one, possibly after having copied it. We recommend using the [https://github.com/imagej/imagej-tutorials/tree/master/load-and-display-dataset ImageJ "Load and Display a Dataset" tutorial] as a starting point!

= How to find a dependency's groupId/artifactId/version (GAV)? =

Most popular open source libraries upon which you might want to depend are stored in the [http://search.maven.org/ Maven Central repository]. However, the ImageJ and Fiji JARs are not yet stored there, but in our own Maven repository. Fortunately, you can search both at once, by visiting:

  http://maven.imagej.net:8081/

For example, let's suppose you want to depend on the [http://snakeyaml.org snakeyaml] library. Typing "snakeyaml" into the search box at [http://maven.imagej.net maven.imagej.net] tells us to use a <code>groupId</code> of <code>org.yaml</code>, <code>artifactId</code> of <code>snakeyaml</code>, with available versions ranging from <code>1.4</code> to <code>1.10</code>. In the case of many results, you can click the "Drill down" link to view more details of that specific GAV combination. You can also click an entry to get a formatted <code>dependency</code> block for direct copy-pasting into your POM.

If you need to depend on a library that is not present in either Maven Central or the ImageJ Maven repository, you will need to [http://maven.apache.org/guides/mini/guide-3rd-party-jars-local.html install it into your local Maven repository cache yourself]. The command is <code>mvn install:install-file</code>. For example, if you have a library <code>foo.jar</code> to install, you could run:

  mvn install:install-file -Dfile=/path/to/foo.jar -DgroupId=org.foo \
    -DartifactId=foo -Dversion=1.0.0 -Dpackaging=jar

For the <code>groupId</code>, it is typically best to use the reversed domain name of the library's web site. For libraries that are not explicitly versioned, you may want to use a datestamp such as "20120920" for the <code>version</code>, rather than inventing your own versioning scheme.

'''WARNING:''' If you use <code>install:install-file</code>, others will not be able to build your code unless they also use <code>install:install-file</code> to install the library on their systems. Before resorting to this technique, double check the project's web site for any documentation on using their library with Maven. They might provide their own public Maven repository which you could use instead (by adding a <code>&lt;repository&gt;</code> to the <code>&lt;repositories&gt;</code> section of your POM). Alternately, you could [http://developer.imagej.net/mailing-lists contact the ImageJ & Fiji maintainers] to get your needed dependency added to the ImageJ Maven repository, so that everyone can build your code more easily.

= Further reading =

* Our very own [[Maven - Frequently Asked Questions|Frequently Asked Questions]]
* [http://maven.apache.org/guides/getting-started/ Maven's Getting Started]
* [http://books.sonatype.com/mvnref-book/reference/public-book.html Maven: The Complete Reference]
* [http://books.sonatype.com/mvnex-book/reference/public-book.html Maven by Example]
* [http://books.sonatype.com/nexus-book/reference/ Nexus Book: Repository Management with Nexus]
