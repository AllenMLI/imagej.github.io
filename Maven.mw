= Introduction =

Maven is a powerful tool to build Java projects and to manage their dependencies. It can build dependencies from sources, but if the sources are not available, it will look into Maven repositories to download the dependencies from.

Example: let's assume that you want to build a new plugin for ImageJ 1.x that builds on, say, the [[3D Viewer]] and commons-math. You do not want to rebuild them from scratch unless you need to debug issues you suspect might be bugs in said components. This is where Maven comes in: you tell it that the dependencies are ImageJ 1.x, 3D Viewer and commons-math and what version(s) you require. It is Maven's job to find and get them, no matter whether you just built them locally or not.

= What does it take to make a new Maven project? =

All it really takes is a ''pom.xml'' file and a certain directory structure.  Technically, you can override the default directory layout in the ''pom.xml'', but why do so? It only breaks expectations and is more hassle than it is worth, really.

So the directory structure is: you put your .java files under ''src/main/java/'' and the other files you need to be included into ''src/main/resources/''. Should you want to apply the best practices called "regression tests" or even "test-driven development": your tests' ''.java'' files go to ''src/test/java/'' and the non-''.java'' files you might require unsurprisingly go into ''src/test/resources/''.

So what does a ''pom.xml'' look like? This is a very simple example:

<source lang="xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
    http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>sc.fiji</groupId>
  <artifactId>my-uber-library</artifactId>
  <version>2.0.0-SNAPSHOT</version>
</project>
</source>

The first 6 lines are of course just a way to say "Hi, Maven? How are you today? This is what I would like you to do:".

The only relevant parts are the ''groupId'', which by convention is something like the inverted domain name (similar to the Java package convention), the name of the artifact to build (it will be put into ''target/'', under the name ''<artifactId>-<version>.jar''). And of course the version.

Maven is not only a build tool but first and foremost a dependency management tool. It has so-called Maven repositories where it stores compiled artifacts. [http://developer.imagej.net/ ImageJ2] has a [http://maven.imagej.net:8081/ Maven repository] (if you are unable to access port 8081, you can access it via [http://maven.imagej.net/ http://maven.imagej.net/] as well, but some functionality is limited then). It is like [[Fake|Fiji Build]]'s precompiled/ directory, but done right.

For Maven to know what you are looking for, you typically have to add the dependencies into the ''pom.xml'' file. For example, every ImageJ 1.x plugin will depend on ImageJ 1.x. So let's add that (before the final ''</project>'' line):

<source lang="xml">
<dependencies>
  <dependency>
    <groupId>net.imagej</groupId>
    <artifactId>ij</artifactId>
    <version>1.45b</version>
  </dependency>
</dependencies>
</source>

As you can see, dependencies are referenced under the same ''groupId'', ''artifactId'' and ''version'' triplet (also known as ''GAV parameters'') that you had to declare for the current project.

For Maven to find the dependencies, it has to know about the location of the repositories. As you know, we are strong proponents of collaboration within the scientific community, so we started the [http://scijava.org/ scijava effort] at the hackathon in December 2011. To this end, scijava has a [https://github.com/scijava/scijava-common/blob/master/pom-scijava/pom.xml super POM] which declares repositories we use (and other metadata as well, such as current artifact versions we provide). To benefit from this in your project, add this to your ''pom.xml'':

<source lang="xml">
<parent>
  <groupId>org.scijava</groupId>
  <artifactId>pom-scijava</artifactId>
  <version>1.15</version>
</parent>

<!-- NB: for project parent -->
<repositories>
  <repository>
    <id>imagej.releases</id>
    <url>http://maven.imagej.net/content/repositories/releases</url>
  </repository>
  <repository>
    <id>imagej.snapshots</id>
    <url>http://maven.imagej.net/content/repositories/snapshots</url>
  </repository>
</repositories>
</source>

You will see that there are two different repository types: releases and snapshots. The snapshot versions are "in-progress" versions. If you declare a dependency with a ''-SNAPSHOT'' suffix in the version, Maven will look once a day for new artifacts of the same versions; otherwise, Maven will look whether it has that version already and not bother re-downloading.

So what if you have multiple ''.jar'' files you want to build in the same project? Then these need to live in their own subdirectories and there needs to be a common parent POM, a so-called ''aggregator'' POM (only this POM needs to have the scijava POM as parent, of course). For an example, look at Fiji's [https://github.com/fiji/fiji/blob/master/src-plugins/pom.xml src-plugins/pom.xml]. Basically, it is adding the ''<packaging>pom</packaging>'' entry as well as a couple of subdirectory names to the ''<modules>'' section.

There are many more things you can do with Maven, but chances are you will not need them.

The simplicity of the ''pom.xml'' you need comes from the fact that Maven defines implicit defaults. It calls that ''convention over configuration''.  But since we are not converting projects (or at least since we are flexible enough to adapt), it is strongly recommended to stay with the defaults as much as possible. It also makes your project more accessible, something that Fiji and the other projects in scijava excel at.

Now, in the context of scijava, you will most likely never write a ''pom.xml'' from scratch. You will rather more likely edit an existing one, possibly after having copied it.
