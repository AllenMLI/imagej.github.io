{{Notice | This page describes the core [[SciJava]] ''software release process''.
* For an overview of ''distribution methods'', see [[Distribution]].
* To ''download'' software releases, see [[Downloads]].}}
{{DevelopMenu | tutorials}}The SciJava [[philosophy]] is to [[Philosophy#Release_early.2C_release_often|release early, release often]]. At the same time, we always want to preserve [[reproducible builds|scientific reproducibility]]. To make this possible we lean on several [[project management]] tools. The purpose of this guide is to take you through the process of using these tools with the goal of releasing new versions of your software, and then providing those releases to users.

= Phases of development =

[[ImageJ]] and [[Fiji]] are developed according to the [[Philosophy|SciJava philosophy]], thus these applications are used throughout this tutorial to illustrate the development lifecycle.

Whether adding new features, fixing bugs, improving performance, etc... '''development''' is the process of making changes, with the goal of exposing these changes to users. To accomplish this, actively developed projects cycle through four general "phases":

{{Box
| title = What are Maven artifacts?
| width = 30%
| float = right
| text =
Artifacts are files, most commonly a '''[[wikipedia:JAR_%28file_format%29|JAR]]''' encapsulating the compiled classes for a component. Other files that may be produced as artifacts include:
* The project's '''[https://maven.apache.org/pom.html POM]'''
* A jar with the original source files
* A jar with any generated javadoc
* A jar with any test files
}}
# '''In development.''' The source code is modified to add new features, fix bugs, etc... these modifications are expressed as ''commits'' by [[Git]], whether on your local filesystem, a topic branch, or a repository fork.
# '''On master.''' When you have a set of one or more ''commits'' that you are happy with (i.e. the feature is complete, or the bug is fixed) they are moved to the <code>master</code> branch of the project's repository on GitHub. This ensures the <code>master</code> branch is always ''release ready''.
# '''Released.''' When there is a need to make the current <code>master</code> branch public (i.e. it has a critical bug fix or cool new feature that users have requested) [[Maven]] is used to ''cut a release'', which is then ''deployed as an artifact'' to the [http://maven.imagej.net/index.html#welcome ImageJ Maven repository]. Developers can now use the new version in their own projects.
# '''Uploaded.''' Once we've tested our latest release artifact to ensure it doesn't conflict with other components, it can be uploaded to an ImageJ [[update site]] - making it available to end users.

The following sections will discuss these phases, and their associated tools and workflows, in more depth.

= Relationship with Maven SNAPSHOTs =

Another way of thinking about the development cycle is through the Maven version number given associated with the code. The idea behind reproducible builds is that from a given version of a plugin, the state of the code producing that version can be determined unambiguously. Typically, that state is determined by a unique [[Git]] commit. However, it would be impractical and unrealistic to change the Maven version with every single Git commit.

This is why [https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm#MAVEN401 SNAPSHOT] versions are used while "in development" (phases 1 and 2 - "SNAPSHOT coupling"). Using a SNAPSHOT version is saying "no guarantees are made as to the reproducibility of this artifact." For this reason, to best facilitate reproducible science, SNAPSHOT versions of code are not provided to users (except potentially for testing).

To provide users with an updated version of an artifact (phases 3 and 4) the version is changed to a unique, non-SNAPSHOT, version for a single Git commit. Then the next commit returns to SNAPSHOT versioning for further development. Thus the cycle repeats.

= Phases in-depth =
{{Box | float=right | title=When to use a topic branch? | text = [[Architecture|Core SciJava components]] employ a "release ready master branch" approach:
* The tip of the master branch is always stable enough to be released, "as good or better" than the state of its last release.
* Each commit on the master branch should compile with passing tests. This has several advantages—e.g., better [https://git-scm.com/book/en/v2/Git-Tools-Debugging-with-Git#Binary-Search bisect-style debugging].

Topic branches are great for isolating potentially disruptive and/or unfinished changes from the master branch, so that it always remains release ready. However, pushing directly to master has a huge time savings over filing a PR and awaiting review for days, weeks or months. Getting changes onto master quickly has many advantages:
* '''Fewer conflicts.''' It avoids conflicts between multiple long-running topic branches.
* '''SNAPSHOT builds.''' [[Jenkins]] builds the change into the latest SNAPSHOT build, making it available from the [[ImageJ Maven repository]].
* '''Faster support.''' Supporting the community is less convoluted, with changes released to users more rapidly. Yes, you can link to changes on a topic branch. And yes, you can upload binary builds from that branch. But each extra manual step costs time—better to link directly to the latest SNAPSHOT build. There are even ImageJ [[update sites]] which serve the latest builds from master, to make it easier for non-technical users to test changes.
* '''Less complex.''' The more topic branches you have—and in particular, the more integration branches you have—the more complex the system becomes, the more supporting tooling, CI jobs, etc. are needed. And the more developer time is needed to maintain the tooling, sort through topic branches, keep track of open PRs... leaving less time for developing new features and fixing bugs.

Hence, when exactly to use a topic branch is a judgment call, but some good times to use a topic branch are:
* '''Breaking.''' The changes break [[backwards compatibility]].
* '''New API.''' The changes introduce significant new API which will need to remain backwards compatible in the future, and review is desired before committing to that API.
* '''Unfinished.''' The changes are unfinished.
* '''Regressing.''' The changes leave the codebase in a "worse" state somehow.
* '''Discussion.''' To solicit discussion from the [[community]], especially if the changes might be contentious.

Conversely, some situations to push directly to master:
* '''Correct.''' Bug-fixes where the developer is confident the fix is correct.
* '''No new API.''' Small new additions which do not introduce significant future maintenance burden.
* '''Unstable.''' Changes to unstable or experimental components still in their "incubation" period of development (i.e., versioned at 0.x), since there is no promise of backwards compatibility.
* '''Unsupported.''' Changes to "unsupported" components which make no guarantee of backwards compatibility.

Lastly, keep in mind that SciJava favors the [[RERO|release early, release often]] style of development, to maximize iterations of community feedback. Just because a change makes it to the master branch, does not mean it is set in stone: if a problem is later found, the change can be amended or reverted as quickly as it was added—easy come, easy go.
}}
== Phase 1: In development ==

Repositories on GitHub are referred to as '''remotes'''; when you ''[https://help.github.com/articles/cloning-a-repository/ clone]'', or ''check out'', a remote you get a local copy of the repository. Development progresses by making changes to your local copy and pushing them back to the remote. GitHub provides tools for controlling [https://help.github.com/articles/permission-levels-for-a-user-account-repository/ user permission levels] for each remote repository, therefore how you develop a project depends on whether you are able to ''push'' (write) to that project's remote repository or not.

* '''Collaborating developer.''' If you have permission to push directly to the project's remote repository, then you can simply use [[Git]] and [[GitHub]] to [https://help.github.com/articles/cloning-a-repository/ clone the repository] and make your changes. For non-trivial changes, you will typically [[Git_topic_branches|create a topic branch]] to develop and test the changes. This also provides a forum for discussion and review with your fellow developers.

* '''External developer.''' If you do not have push rights, then you need to go through an additional step called '''[http://www.dataschool.io/simple-guide-to-forks-in-github-and-git/ Forking the repository]'''. This will create a remote copy of the repository, to which you have push rights. Your remote fork is referred to as ''downstream'' of the original remote repository (which is ''upstream'' of your fork). Your development will then take place on your fork, with an additional step later to reconcile with the upstream repository.

== Phase 2: On master ==

Once a feature or fix is complete it can move to the <code>master</code> branch of the repository. How you accomplish this depends on how the changes were developed in Phase 1.

* '''Collaborating developer.''' Minimal changes can be pushed back directly to <code>master</code> on the remote repository. If your work is on a [[Git_topic_branches|topic branch]] then you should use a [https://help.github.com/articles/using-pull-requests/ pull request] (PR) so that the topic branch can be reviewed before being merged to <code>master</code>.

* '''External developer.''' First push your changes back to a branch of your forked repository (it doesn't necessarily have to be <code>master</code>). Then you can file a [https://help.github.com/articles/using-pull-requests/ pull request] (PR) on [[GitHub]] to merge your branch back to the official repository. This invites code review from other interested developers. Reviewers might ask for changes to the code to address any issues. After any needed revisions have been made, a [[Governance|project maintainer]] will accept your changes and then merge to the official <code>master</code> branch.

== Phase 3: Released ==

''Note:'' This step can only be performed by a [[Governance|project maintainer]].

Once the <code>master</code> branch of a component has your desired new functionality, the next step is to cut a ''release'' version of the component. Normally, the Maven version (in the [https://maven.apache.org/pom.html#Introduction pom.xml]) on master is a ''SNAPSHOT'' version, meaning it is [[Reproducible builds|unstable]] and not yet released. However, a [[Reproducible_builds|stable]] ''release'' artifact can be deployed to the ImageJ Maven repository in one of three methods, described below.  As a rule of thumb, SciJava developers currently use:
* The '''[[#Method 1: Release-Version Jenkins job|Release-Version Jenkins job]]''' to release components of the [[Architecture|ImageJ software stack]] (SciJava, ImgLib2, SCIFIO and ImageJ).
* The '''[[#Method 2: release-version.sh|release-version.sh script]]''' to release most [[Fiji]] components.
* The '''[[#Method 3: Double push to master|Double push to master]]''' approach to release other [[Fiji]] components.

=== Method 1: Release-Version Jenkins job ===

The special <code>Release-Version</code> job of Jenkins (which is visible only to logged in Jenkins users) is triggered to release a particular artifact. There are several advantages to this approach:

* A tag is created on GitHub to easily reference the release commit
* The "bump to next release cycle" commit is done automatically
* The Maven POM references the correct tag rather than <code>HEAD</code>
* This job is capable of releasing certain artifacts to OSS Sonatype (and hence to Maven Central) as appropriate

'''Prerequisites:'''
* You will need an ImageJ Jenkins account. If you haven't set this up yet, contact the [[Mailing_Lists|ImageJ-devel list]] and ask for an account. A maintainer will send you instructions.

'''Steps to release:'''
# Visit the [http://jenkins.imagej.net/job/Release-Version/ Release-Version Jenkins job] web page.
# Click "Build with Parameters" from the left-hand menu.
# Select your component from the dropdown list.
# Enter the commit hash corresponding to the most recent commit of the master branch.
# Enter the desired version number of the release.
# Click the Build button.
# Grab a coffee.

Jenkins will take care of all the steps, including pushing the relevant commits and tags, building the code, and deploying the resultant artifact to the ImageJ Maven repository.

=== Method 2: release-version.sh ===

The [https://github.com/scijava/scijava-scripts/blob/aab7cfe805638efc25615fdd7c78cedaae3c7197/release-version.sh release-version.sh] script is what the [[#Release-Version Jenkins job|Release-Version Jenkins job]] uses under the hood to perform releases. It relies on the [http://maven.apache.org/maven-release/maven-release-plugin/ Maven Release plugin] to do most of the heavy lifting, but also does some extra work (e.g., to ensure releases are deployed to the correct repository).

'''Prerequisites:'''

<ul>
<li>Install the release-version.sh script. The best way to do this is to clone the complete [https://github.com/scijava/scijava-scripts SciJava-scripts] repository. That will give you access to other useful scripts and help keep them all up to date.</li>
<li>('''optional''') If you want to easily use these scripts from any directory, you can [http://askubuntu.com/q/97897 add the scijava-scripts folder to your PATH].</li>
<li>You will need an account for [http://maven.imagej.net maven.imagej.net] and the local Maven configuration to deploy to this repository. If you haven't set this up yet, contact the ImageJ developers on the [[ImageJ Forum]] to ask for an account. Then follow [https://maven.apache.org/guides/mini/guide-encryption.html this guide] to configure your <code>settings.xml</code> and <code>settings-security.xml</code> appropriately on your local machine. In particular, you will need the following block in <code>settings.xml</code>:
<pre>
	<servers>
		<server>
			<id>imagej.releases</id>
			<username>{your Nexus username}</username>
			<password>{your Nexus password hash}</password>
		</server>
		<server>
			<id>imagej.snapshots</id>
			<username>{your username}</username>
			<password>{your Nexus password hash}</password>
		</server>
	</servers>
</pre></li>
</ul>

'''Steps to release:'''

# From your project's directory, simply run:
    release-version.sh <NEW_VERSION>

{{Notice | If your project is a [https://maven.apache.org/guides/mini/guide-multiple-modules.html multi-module build], first make a commit commenting out any modules that should not be released. Then run the script from the aggregator pom directory.}}

=== Method 3: Double push to master ===

Historically, the "double push to master" approach was the recommended way to release—but it has now been replaced by the other two approaches. Nonetheless, there are a few components of Fiji that still use it to do their releases. A push to master happens with the POM version set to a non-SNAPSHOT—e.g., {{GitHub | org=fiji | repo=Trainable_Segmentation | commit=fd92658524dd90da8d505dad295c6f6ce3e3a188 | label=this Trainable_Segmentation commit releasing version 2.2.1}}. A second push to master is then typically done to "bump to next release cycle" after Jenkins starts building the release—e.g., {{GitHub | org=fiji | repo=Trainable_Segmentation | commit= | label=this Trainable_Segmentation commit bumps to 2.2.2-SNAPSHOT}}. This second push avoids accidentally having two different commits that purport to be the same non-SNAPSHOT version (since release versions must be unique and immutable).

'''Prerequisites:'''
* The repository for your project needs to be linked with a [[Project_management#Continuous_integration|continuous integration tool]] that will automatically build and deploy Maven artifacts in response to changes on GitHub, e.g. using [[Travis#Automatic_Deployment_of_Maven_Artifacts|Travis]] or [http://jenkins.imagej.net/ Jenkins]. If you're not sure if your project has this automation, [[Contact|contact us]] and we'll help you find out.
* Familiarize yourself with the concept of [[Maven]], and in particular the idea of [http://stackoverflow.com/q/5901378 SNAPSHOT and release artifacts]. When Jenkins deploys to Maven, it is actually uploading to a separate release or SNAPSHOT repository based on the version defined in the project's pom.xml. SNAPSHOTs can be changed; releases cannot.
* Familiarize yourself with the [http://git-scm.com/book/en/v2/Git-Basics-Tagging Git tagging process]. You will need to tag a commit and push the tag to a remote repository for the release process. Although Git tags can be changed or deleted over time, the convention of creating a tag to match each release creates a nice "bookmark" system for developers when they check out the code.


'''Steps to release:'''
# Make a commit '''on master''' that changes the version of your project to a non-SNAPSHOT.
# Push your commit to GitHub to trigger the deployment of a Maven release.
# Tag the release commit with an appropriate name. Core projects use a standard "component name"-"version" naming scheme, e.g. <code>mysoftware-1.2.3</code>.
# Make a second commit incrementing the version to the next SNAPSHOT version.
# Push again to GitHub—both the SNAPSHOT-version master branch '''and the release tag'''.

The disadvantage to this method is that, since the steps are not automated, there is room for error and inconsistency—not pushing the tag, not making a commit go back to a SNAPSHOT version, etc.

{{Warning | This process works because Jenkins automatically builds the project in response to commits on master. Whether they are deployed as [[Maven]] releases or SNAPSHOTs is determined entirely by the version number in the pom.xml for the project. This is why it is especially important to change the version back to a SNAPSHOT after the release: only one release for a given version can exist, and once it exists it cannot be overwritten. If you create multiple git commits at the same release version, it becomes unclear which one is the [[Reproducible builds|"real" release in Maven terms]].}}

== Phase 4: Uploaded ==
{{Box
| title = What are ImageJ update sites?
| width = 30%
| float = right
| text =
ImageJ [[update sites]] are what ImageJ actually queries to download updates. These update sites are versioned, but do not rely on other tools (e.g., [[Git]] or [[Maven]]) in order to function. Rather, component developers upload new versions of their component(s) using the [[ImageJ Updater]], which makes them available to end users. Typically, update sites are available as web sites via HTTP, with uploads functioning via [https://github.com/imagej/imagej-plugins-uploader-webdav WebDAV] or [https://github.com/imagej/imagej-plugins-uploader-ssh SSH/SFTP/SCP].
}}
Deploying to the Maven repository creates a stable release artifact of a software component, but for ImageJ-related components, that alone does not put it into the hands of users. To do that, the component must then be ''uploaded'' to an ImageJ [[update site]].

=== ImageJ and Fiji update sites ===

For core projects, there is an additional layer tying User-facing and Developer-facing components together: the [[Architecture#Bill_of_Materials|Bill of Materials]] (BOM). To ensure users and developers see the same functionality, components should only be uploaded to the core update sites when their version is also updated in the corresponding BOM.

When you have a new version of your plugin to release, you should follow the [[#Phase 1: In development|External developer]] instructions for contributing to corresponding BOM (i.e. {{GitHub | org=fiji | repo=pom-fiji | label=pom-fiji}} in this case). By [https://help.github.com/articles/using-pull-requests/ submitting a pull request] that simply modifies the [https://github.com/fiji/pom-fiji/blob/pom-fiji-15.7.0/pom.xml#L129-L259 managed version of your component], you will signal to the core Fiji developers that your project is ready for upload.

=== External update sites ===

An update site can be hosted anywhere, though the ImageJ web server at http://sites.imagej.net/ offers a [[personal update site]] service.

See the '''[[Distribution|distribution]]''' page for a discussion of pros and cons of distributing your plugin on a core versus a personal update site.

If you do manage [[How to set up and populate an update site|your own update site]], you can upload your release yourself.

See the [[Update Sites|documentation on update sites]] for further instructions.

= Further reading =

* The SciJava [[Architecture#Versioning|versioning guidelines]] will help you choose appropriate version numbers for your software when performing Maven releases.

[[Category:Development]]
[[Category:Tutorials]]
