{{Development}}{{Sidebox | title = How does it work? | body = We use an [https://en.wikipedia.org/wiki/Java_annotation#Processing annotation processor] at compile time (derived from the [https://github.com/jglick/sezpoz SezPoz] project) which writes the plugin metadata to a special file inside the JAR file: <code>META-INF/json/org.scijava.plugin.Plugin</code>. Reading these files allows the system to discover Java annotations at runtime very quickly ''without'' loading the plugin classes in advance.}}Extensibility is [[ImageJ]]'s greatest strength. [[ImageJ2]] has an powerful plugin discovery mechanism, driven by the [[SciJava Common]] library, that finds all plugins available on the Java classpath, without knowing in advance what they are or where they are located.

ImageJ2 provides several different types of plugins. It is even possible to extend the system with your own new types of plugins.

The most familiar sort of plugin is the ''command'', which is a runnable operation. Most commands can be written in a manner completely independent of the user interface. You define the command's ''inputs'' and ''outputs'' by labeling them with the <code>@Parameter</code> annotation. ImageJ automatically takes care of filling in the inputs (typically by prompting the user for input using a dialog box), as well as displaying the outputs after the command has run.

== Example commands ==

You can find some [https://github.com/imagej/imagej-tutorials/tree/master/simple-command/src/main/java example commands] in the [https://github.com/imagej/imagej-tutorials ImageJ tutorials].

== See also ==

* [[Writing ImageJ2 plugins]]
