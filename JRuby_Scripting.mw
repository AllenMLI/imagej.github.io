[http://jruby.codehaus.org/ JRuby] is a marvellous project created a complete implementation of Ruby that runs in the JVM.  The excellent work of the authors of JRuby has made it very simple for us to add JRuby scripting into ImageJ.

JRuby scripting in ImageJ is a nice alternative to scripting using ImageJ's macro language.  It has the following advantages:

* You don't have to learn a new language to script ImageJ (assuming you know Ruby)
* You're not limited to using the functionality exposed by the macro language: you can use any class in ImageJ, one of its plugins or standard Java
* Developing JRuby scripts is very fast compared to developing plugins in Java

(These advantages, of course, are shared by the [[Jython Scripting]], [[Clojure Scripting]], Beanscript and [[Javascript Scripting]] bundled in Fiji.)

== Tutorial ==

Let's start writing some JRuby right away - start up the interpreter by going to "Plugins > Scripting > JRuby Interpreter".  The interpreter window will pop up, but it may take a little time for the JRuby runtime to be ready.  You should initially see the message:

  Starting JRuby ...

... and when it's ready, the line:

  Done.

Now you can start typing Ruby expressions into that window, such as:

  >>> "hello there".upcase[1..4]
  ELLO

It would be a good idea to take a quick look at the page on [[Scripting Help]] for tips on using this interpreter window.l

Try loading one of the ImageJ sample images by going to "File > Open Samples > T1 Head (2.4M, 16-bits)".  Once you've done that we'll examine the image using JRuby.  You can get a reference to the current image with ij.IJ.getImage.  Try assigning the result to a variable, like this:

  >>> i = ij.IJ.getImage
  imp[t1-head.tif 256x256x129]

Now we can find out the width and the depth of the stack like this:

  >>> w = i.getWidth
  256
  >>> d = i.getStackSize
  129

Many of the operations that you might want to perform on the image are available via the ImageProcessor associate with a slice.  For example, to invert the current slice do:

  i.getProcessor.invert

That won't actually produce a visible effect on the image until you also call i.updateAndDraw on the image:

  i.updateAndDraw

If you scroll through the stack now you should find that one of the slices is inverted.

=== Note On Names ===

You might find the use of "ij.IJ.getImage" above slightly suspicious if you're used to Java and the ImageJ API.  "ij" is the Java package name, "IJ" is the class name in that package and "getImage" is a static method in that class which returns a reference to an ImagePlus object representing the current image or null if there is none.  How does this work?  We have set up the JRuby interpreter in ImageJ so that if a method or class name can't be found it will look for a correponding class or method name in the ij.* packages.  JRuby by default does exactly this for the java.* classes, so for example the following works without having to explicitly include the java.util.Random class:

  >>> rng = java.util.Random.new
  java.util.Random@bf9a12
  >>> rng.nextInt 1024
  603
  >>> rng.nextInt 1024
  94

Note that this is an example of creating an object in JRuby; you use the usual Something.new syntax of Ruby, but it creates an object of the standard Java class.  Hopefully you're thinking "Excellent!" or something similar at this stage...

If you need to use classes that aren't in the java.* or ij.* hierarchy, you will have to include them explicitly.  For example, in the classpath of Fiji there is a useful class called util.BatchOpener, that has static methods for opening files as arrays of ImagePlus objects (one per channel) without showing them.  To use these methods, you would have to do:

  >>> include_class 'util.BatchOpener'
  util.BatchOpener

Then you can, for example, do the following:

  >>> a = BatchOpener.open "/home/mark/confocal/test.lsm"
  [Lij.ImagePlus;@b1406b
  >>> a.length
  2
  >>> a[0].getTitle
  C1-test.lsm
  >>> a[1].getTitle
  C2-test.lsm
  >>> a[1].show

== Example: Generating a Plasma Cloud ==

In this first example, we'll just create a small script to create a fractal "plasma cloud" image.  We'll start of experimenting in the interpreter to make sure we've got the code to create images correctly.  To create the RGB image in the first place, we create a ColorProcessor and then an ImagePlus from that:

  >>> w = 800
  800
  >>> h = 600
  600
  >>> cp = ij.process.ColorProcessor.new(w,h)
  ip[width=800, height=600, min=0.0, max=255.0]
  >>> i = ij.ImagePlus.new "Plasma Cloud", cp
  imp[Plasma Cloud 800x600x1]

... and now show it:

  >>> i.show

We'll manipulate the pixel array directly, so it's worth checking that this will work OK.  Here we try to set half of the image to green:

  >>> i
  imp[Plasma Cloud 800x600x1]
  >>> pixels = cp.getPixels
  [I@e038c4
  >>> 0.upto( w * (h / 2) - 1) { |j| pixels[j] = 0x0000FF00 }
  0
  >>> i.updateAndDraw

Hopefully that worked OK.  The color value specified there is in ARGB format.  You may have noticed that this step was rather slow - there is quite a bit of magic involved in JRuby's transparent access between Ruby and Java, which has an inevitable performance cost.  So, JRuby scripting isn't an ideal job for this kind of script, but hopefully this example will be instructive nonetheless.

You would probably proceed at this stage by switching to a text editor and creating a script in the Fiji plugins directory.

== Example: Batch Converting File Formats ==

''FIXME: complete this section''

== Example: Generating Red/Cyan Anaglyphs ==

''FIXME: add notes here on figuring out the parameters to pass to plugins, citing the example in Examples/Anaglyph_for_Red_Cyan_glasses.rb''

=== Converting ImageJ Macros to JRuby ===

''FIXME: complete this section, mention the start that's been made on implementing similarly named JRuby functions that do the equivalent of the standard ImageJ macros; see Plugins/JRuby/imagej.rb''

=== What next? ===

[You may want to first have a quick look at the [[Scripting Help]] page for generic instructions in using the interpreter and script interfaces, and the [[Scripting comparisons]] page for an example written in several of the different scripting languages available.]
