==2011-03-16==
Tobias and Saalfeld found it a great idea to create this discussion page that, if ever possible, will be filled with the daily conceptual discussions and results.  That way, all interested people can contribute and keep track on what we're trying to tackle next.

===We discussed the View concept:===
Summary is that <code>View<T></code> would be an interface that can return its target <code>T</code>, the data it is generated from:

<source lang="java">
public interface View<T> {
    public T getTarget();
}
</source>

A <code>View</code> is an <code>[&hellip;]Accessible</code> that provides possibly transformed access to a subset of this target data. 

Since we could not see any reasonable application for the bare ''View'' interface, we will not implement it but use it in informal speech about virtualized access. We will also use ''Target'' to refer to the underlying data.

Examples are <code>IterableIntervalSubset</code>, arbitrary Neighborhoods, <code>RandomAccessibleView</code> (formerly called View), <code>RealRandomAccessibleView</code>, <code>TransformedRandomAccessibleView</code>,
<code>StructuredElement</code>,
<code>HyperShpere</code>,
<code>SuperInterval</code>&hellip;


===We discussed the View concept (again) and Transforms:===
We agreed that for Views that give transformed access it is more natural
to specify the transform with respect to the underlying data.
That is, the transform is applied to a coordinate in the data system to
obtain a coordinate in the view system.

In matrix notation, a transform would look like
'''y = Tx'''.
Here, it is natural to refer to '''x''' as the ''source''
vector and to '''y''' as the ''target'' vector.

Applied to Views, we will therefore completely reverse our previous opinion and
refer to the underlying data as the ''Source''.

The <code>View<T></code> interface would look like
<source lang="java">
public interface View<T> {
    public T getSource();
}
</source>

For Transforms, we will adapt and simplify the <code>CoordinateTransform</code> and related interfaces from Fiji's mpicbg submodule.  There will be an integer and a real version as for <code>Positionable</code> and <code>Localizable</code>.  <code>Transform</code> and <code>RealTransform</code> can specify the number of dimensions of its source and target domain.  They look like
<source lang="java">
public interface Transform {
    public int numSourceDimensions();
    public int numTargetDimensions();
    apply(long[] source, long[] target);
    apply(Localizable source, Positionable target);
}

public interface RealTransform {
    public int numSourceDimensions();
    public int numTargetDimensions();
    apply(double[] source, double[] target);
    apply(RealLocalizable source, RealPositionable target);
}
</source>
The apply methods transfer source coordinates into target coordinates.

There will be an invertible version for each of these interfaces
<source lang="java">
public interface IvertibleTransform extends Transform {
    applyInverse(long[] source, long[] target);
    applyInverse(Positionable source, Localizable target);
    InvertibleTransform inverse();
}

public interface IvertibleRealTransform extends RealTransform {
    applyInverse(double[] source, source[] target);
    applyInverse(RealPositionable source, RealLocalizable target);
    InvertibleRealTransform inverse();
}
</source>
Note that <code>target</code> is transferred into <code>source</code> in that case.

We have extensively discussed the fact that for rendering a mapped image, an inverse transformation is required whereas one prefers to define transformations in the forward manner.  Nevertheless, a view (renderer) should use the forward defined instance of a <code>Transform</code> to create its result with changes applied to that transform having a direct effect on the result (no creation of a fresh `inverse').  Other than in mpicbg, we will achieve this by implementing Renderers for forward transformations (those transformations that can be specified in one direction only will be defined as forward transformations).  For invertible transformations, the Renderer will use a final <code>Inverter</code> that is a forward transformations that uses the inverse apply methods of an invertible transformation for its apply method.

===How to proceed with the imglib2 namespace?===

We think that it would be a great idea to be able to run both imglib and imglib2 together.  This would relieve us from the need to port all the legacy imglib code into imglib2.  Also, a shorter package hierarchy would be nice.  With org.imglib2, we would match the Maven convention and the URL is still not registered...

==2011-03-21==

===Efficient access for RandomAccessibleViews===

I've been thinking all day about a reasonable concept for concatenation and simplification of <code>Transforms</code> for <code>RandomAccessibleViews</code>.
No satisfying result so far, so at least I want to start writing down what
it might look like in the end and what the problems are.

====Simplifying View Transformations====
The idea is that a view should always give you a <code>RandomAccess</code>
that is as efficient as possible.
When views are layered on top of each other it is often possible to combine
and simplify their transformations.

Assume that we have a 90 degree rotated view '''A''' of an image '''I'''.
and a 90 degree rotated view '''B''' of that view '''A'''.
A <code>RandomAccess</code> on '''B''' could simply rotate by 90 degree and
wrap a <code>RandomAccess</code> on '''A'''.
The <code>RandomAccess</code> on '''A''' would in turn simply rotate by 90 degree and wrap a <code>RandomAccess</code> on '''I'''.

However, this would not a good idea for a hierarchy of many views.
Instead, when we request a <code>RandomAccess</code> from '''B''' then we would like one that directly wraps a <code>RandomAccess</code> on '''I''' and rotates coordinates by 180 degree.

===== Transformable (leek) =====

Coincidentally, I was playing around with an idea for ROIs that might be applicable here. You'd like to be able to take a ROI in one space, apply a transform and get a ROI in the transformed space by transforming key internal coordinates. So that lead me to think of making ROIs implement "Transformable" if they wanted to. The some could be applied to a transform itself - have a transform implement transformable so that its internal matrix could get re-jiggered to operate in the new space.

Here's the interface that I was planning on implementing:

 package mpicbg.imglib.transform;
 /**
  * @author leek
  *
  * A class is transformable if it can produce a copy of
  * itself in the transformed space using the supplied transform.
  * 
  * Note that a class may require either a Transform or an InvertibleTransform
  * depending on whether the strategy is to transform coordinates in the
  * source space into the destination space or to generate the object in
  * the destination space by sampling invert-transformed points in the
  * source space.
  * 
  */
 public interface Transformable<O,T extends Transform> {
    /**
     * Generate a copy of the object in the transformed space.
     * @param t the transform that maps points in the source space to those
     *          in the destination space.
     * @return a copy built to operate similarly in the transformed space.
     */
    public O transform(final T t);
 }

You'd only want to implement Transformable in cases where the object has internal state which allows the transformed object to operate more efficiently than transformation of the object's inputs, followed by application of the object's function. For ROIs, the savings are clear - cost to transform a handful of vertices in a polygon versus cost of back-transforming millions of coordinates into the original space.

Now it obviously can be made to work for ROIs and it can be made to work to combine two linear transformations (dot product of matrices, right?). But other things are more complex and require more thought. At the end of it, each output is a function of the inputs and the trick is to composite a function that performs the operation. For a transform T1 to be transformable by transform T2, it seems that you need to combine and reduce an equation on the inputs of T1 for each of the outputs of T2. It's a difficult enough problem that you might not want to make a transform generally transformable - you might want to have compositors with special knowledge regarding which classes can be combined to yield a new one and how it's done.

====Out-Of-Bounds Handling====
In imglib2, out-of-bounds access is handled by [http://pacific.mpi-cbg.de/cgi-bin/gitweb.cgi?p=imglib.git;a=blob;f=imglib/src/main/java/mpicbg/imglib/ExtendedRandomAccessibleInterval.java;h=31dacac73d7c4377d2e2335681b3417e2c8665f4;hb=refs/heads/imglib2-dirty <code>ExtendedRandomAccessibleInterval</code>]
If you have a <code>RandomAccessibleInterval</code> you can wrap it into
an <code>ExtendedRandomAccessibleInterval</code> which extends to infinity.
Like so:
<source lang="java">
F interval; // where F extends RandomAccessibleInterval< T >
OutOfBoundsFactory< T, F > factory = new OutOfBoundsMirrorFactory< T, F >( OutOfBoundsMirrorFactory.Boundary.SINGLE );
RandomAccessible< T > extended = new ExtendedRandomAccessibleInterval< T >( randomAccessible, factory );
</source>

<code>ExtendedRandomAccessibleInterval</code> is also a <code>RandomAccessibleView</code>.
It might be inserted at any point in a view hierarchy.
Here is an example:
<source lang="java">
Img< FloatType > img = LOCI.openLOCIFloatType(...);
RandomAccessibleView< FloatType > view1 = Views.extend( img );	
RandomAccessibleIntervalView< FloatType > view2 = Views.superIntervalView( view1, new long[] {-20, -20}, new long[] {157, 157} );		
RandomAccessibleView< FloatType >         view3 = Views.extend( view2 );	
RandomAccessibleIntervalView< FloatType > view4 = Views.superIntervalView( view3, new long[] {-100, -100}, new long[] {357, 357} );
</source>


The original <code>img</code> looks like this:

[[File:Imglib2views_img.png‎]]

This is extended to infinity (using mirroring strategy)
resulting in the unbounded <code>RandomAccessible view1</code>.
A crop of <code>view1</code> looks like this:

[[File:Imglib2views_ext1.png‎]]

Then we take a subview <code>view2</code> (which is again a bounded interval)

[[File:Imglib2views_extsub1.png‎]]

We extend that to get <code>view3</code> and take a subview <code>view4</code>
which looks like this:

[[File:Imglib2views_extsub1extsub2.png‎]]

Now assume that we want <code>RandomAccess</code> into <code>view4</code>.
If we know in advance interval in which we will use the access, <code>view4</code> can possibly provide more efficient access.
Consider this:

[[File:Imglib2views_extsub1extsub2regions.png‎]]

If we want to access only the green region, the <code>RandomAccess</code>
can fall through all the way to the original <code>img</code> without needing
out-of-bounds values. We simply wrap a <code>RandomAccess</code> on <code>img</code> with a coordinate translation to the top-left corner of <code>view4</code>

If we need to access the red region, we wrap a out-of-bounds <code>RandomAccess</code> on <code>view1</code> (which wraps a <code>RandomAccess</code> on the <code>img</code>).

If we need to access the blue region, we wrap a out-of-bounds <code>RandomAccess</code> on <code>view3</code> (which wraps a out-of-bounds <code>RandomAccess</code> on <code>view1</code>, which which wraps a <code>RandomAccess</code> on the <code>img</code>).

A view hierarchy may consist of an arbitrary sequence of views that do
coordinate transforms and extending views. Depending on interval we
want to access, sometimes the extending views "disappear". In this case,
transforms before and after the extending view can be concatenated and simplified if possible.

[[Category:ImgLib]]
