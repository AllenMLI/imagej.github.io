__TOC__


This page describes the segmentation function of the [[CIP|CIP scripting]] package

{{CIP Navigation}}

='''threshold'''=

<span style="font-size:110%">'''Description'''</span><br>
this function creates a binary image from an input graylevel image

<span style="font-size:110%">'''Signatures'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>outputImage = cip.threshold( inputImage* , threshold*)</code>

&nbsp;&nbsp;&nbsp;&nbsp;<code>outputImage, threshold = cip.threshold( inputImage* , method*, output)</code>

<span style="font-size:110%">'''Input'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;'''inputImage*''' : the image to process<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''threshold*''' : a scalar value use to threshold the image<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''method*''' : a string in {'huang', 'ij1', 'intermodes', 'isoData', 'li', 'maxEntropy', 'maxLikelihood', 'mean', 'minError', 'minimum', 'moments', 'otsu', 'percentile', 'renyiEntropy', 'rosin', 'shanbhag', 'triangle', 'yen'}.<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''output''' : a string in {'image', 'value', 'both'}defining the type of output.

<span style="font-size:110%">'''Output'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;'''outputImage''': the processed image.
&nbsp;&nbsp;&nbsp;&nbsp;'''threshold''': the threshold value calculated for the image and method provided as input.

<span style="font-size:110%">'''Example'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>img2 = cip.threshold( img1 , 500 )</code>
[[File:CIP_threshold.PNG|none|400px]]<br>

<span style="font-size:110%">'''Implementation'''</span><br>
the threshold method wraps ops threshold methods

='''label'''=
<span style="font-size:110%">'''Description'''</span><br>
This function threshold an image and label its connected component (i.e. it sets the pixels of each region to a distinct integer value). 

<span style="font-size:110%">'''Signature'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>outputImage = cip.label( inputImage* , threshold)</code>

<span style="font-size:110%">'''Input'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;'''inputImage*''' : the image to process<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''threshold''' : a scalar value to threshold the image. If the input image is binary no threshold is needed<br>

<span style="font-size:110%">'''Output'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;'''outputImage''': a label map (an image with background 0 and where each identified region has a distinct integer value).

<span style="font-size:110%">'''Example'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>img2 = cip.label( img1 )</code>
[[File:CIP_label.PNG|none|400px]]<br>

<span style="font-size:110%">'''Implementation'''</span><br>
The labeling is performed our custom implementation. It uses a union find approach relying pixel runs to speed up to labeling process. The source code is available on [https://github.com/benoalo/ImgAlgo/blob/master/src/main/java/invizio/imgalgo/label/RleCCL.java github]. The principle of the algorithm was described in [1].

[1] Cabaret, Laurent, Lionel Lacassagne, and Louiza Oudni. "A review of world's fastest connected component labeling algorithms: Speed and energy estimation." Design and Architectures for Signal and Image Processing (DASIP), 2014 Conference on. IEEE, 2014.

='''maxima'''=
<span style="font-size:110%">'''Description'''</span><br>
This function detects the intensity maxima of an imaget and return a labeled image of these maximage. 

<span style="font-size:110%">'''Signature'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>outputImage = cip.maxima( inputImage* , threshold, heightMin, areaMin, distanceMin, scaleMin, scaleMax, method, pixelSize)</code>

<span style="font-size:110%">'''Input'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;'''inputImage*''' : the image to process<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''threshold''' : the minimum intensity of the maxima<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''heightMin''' : the minimum dynamics of the maxima peak. defining this value triggers an extended maxima detection unless scale parameters are defined<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''areaMin''' : the minimum area in pixel of the maxima peak. if heightMin is defined this value is ignored. <br>
&nbsp;&nbsp;&nbsp;&nbsp;'''areaMin''' : the minimum distance in pixel between the maxima. if heightMin or areaMin are defined this value is ignored.  <br>
&nbsp;&nbsp;&nbsp;&nbsp;'''scaleMin''' : if that value is defined a multiscale maxima detection is ran and this value represent the minimum scale  of the maxima<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''scaleMax''' : if that value is defined a multiscale maxima detection is ran and this value represent the maximum scale  of the maxima<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''method''' : a string in {'classic', 'height', 'area', 'distance', 'multiscale'} defining the method to be used for maxima detection<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''pixelSize''' : a scalar or a list of scalar defining pixel size to use for multiscale detection. by default this value is 1<br>

<span style="font-size:110%">'''Output'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;'''outputImage''' : a label image of the detected maxima<br>

<span style="font-size:110%">'''Example'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>img2 = cip.maxima( img1 , 'hmin', 200 )</code>
[[File:CIP_maxima.PNG|none|400px]]
the illustration above show the contour of the detected region on top of the original data

<span style="font-size:110%">'''Implementation'''</span><br>
Each maxima detection method rely on a custom implementation

'''[https://github.com/benoalo/ImgAlgo/blob/master/src/main/java/invizio/imgalgo/label/Maxima.java Classic]''' method is a union find implementation of maxima detection<br>
'''[https://github.com/benoalo/ImgAlgo/blob/master/src/main/java/invizio/imgalgo/label/HMaxima.java Height]''' and '''[https://github.com/benoalo/ImgAlgo/blob/master/src/main/java/invizio/imgalgo/label/AreaMaxima.java Area]''' methods are derived from attribute filtering approaches [1] simply using a different attribute peak height or area as criteria to merge peaks and stop their extension.<br>
'''[https://github.com/benoalo/ImgAlgo/blob/master/src/main/java/invizio/imgalgo/label/WindowMaxima.java Distance]''' is simpler but efficient approach that pass a filter window over the image and check is all pixel values in the window are lower or equal to the center pixel. This method can make errors if image contains plato.<br>
'''[https://github.com/benoalo/ImgAlgo/blob/master/src/main/java/invizio/imgalgo/label/MultiScaleMaxima.java MultiScale]''' method builds a difference of gaussian pyramid and detection in that scale space. The implementation principle is well described in [2].

='''watershed'''=
<span style="font-size:110%">'''Description'''</span><br>
Watershed algorithm partitions an image in regions and outputs a label image of these regions. Initialized with image maxima or or user defined regions the algorithm grow these seed regions following the shape of, i.e. flooding, intensity peaks. 

<span style="font-size:110%">'''Signature, Input 1'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>outputImage = cip.watershed( inputImage* , threshold, heightMin, peakFlooding, method)</code>

&nbsp;&nbsp;&nbsp;&nbsp;'''inputImage*''' : the image to process<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''threshold''' : an intensity value at which the region growing will stop<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''heightMin''' : the minimum dynamics of the maxima used to initialize the watershed. default is 5 percent of the image dynamics<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''peakFlooding''' : a percentage of peak flooding. 0 mean the region will be reduced to its maxima while 100 give the full region.<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''method''' : a string in {'<u>gray</u>','binary'} defining if the watershed is calculated on the gray level image or a distance map<br>

<span style="font-size:110%">'''Signature, Input 2'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<code>outputImage = cip.watershed( inputImage* , seed, threshold)</code>

&nbsp;&nbsp;&nbsp;&nbsp;'''inputImage*''' : the image to process<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''seed''' : a label image of the region that will initialize the watershed process<br>
&nbsp;&nbsp;&nbsp;&nbsp;'''threshold''' : an intensity value at which the region growing will stop<br>

<span style="font-size:110%">'''Output'''</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;'''outputImage''' : a label image of the detected maxima<br>

<span style="font-size:110%">'''Example'''</span><br>
<code>img2 = cip.watershed( img1 , 'threshold', 500, 'hmin', 300 )</code><br>
In that example the starting point of the watershed are the extended maxima of the input image.
[[File:CIP_watershed.PNG|none|400px]]<br>

<span style="font-size:110%">'''Implementation'''</span><br>
Both seeded watershed and H-watershed are implemented based on the image foresting transform approach [1]. The H-watershed adds the construction of a hierarchical tree of segment that can be used in further applications. Both  implementations can be found [https://github.com/benoalo/ImgAlgo/blob/master/src/main/java/invizio/imgalgo/label/SeededWatershed.java here] and [https://github.com/benoalo/ImgAlgo/blob/master/src/main/java/invizio/imgalgo/label/HWatershed.java there]

[1] Lotufo, R. D. A., Falc√£o, A. X., & Zampirolli, F. A. (2002). IFT-watershed from gray-scale marker. In Computer Graphics and Image Processing, 2002. Proceedings. XV Brazilian Symposium on (pp. 146-152). IEEE.
